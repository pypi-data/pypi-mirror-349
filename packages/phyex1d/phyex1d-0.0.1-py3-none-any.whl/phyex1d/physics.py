"""
Implementation of a PHYEX timestep
"""

import sys
import os
import importlib.util
import logging
import tempfile
import netCDF4
import numpy
from scipy.interpolate import RegularGridInterpolator
import f90nml
from pppy import PPPY
from . import Phyex1DError
from . import Cst
from ctypesForFortran import MISSING

class PhysicsBase(PPPY):
    """
    Implementation of the forcing
    This class is not intended to be used directly
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, prognostic_variables,
                 pyphyex=None, namel=None, dx=0, dy=0):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param prognostic_variable: List of prognostic variables
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        """
        super().__init__(dt, method, name, tag, inputfile=inputfile, grid=grid.filename)
        self.inputfile = inputfile
        self.grid = grid
        self.prognostic_variables = prognostic_variables
        self.pyphyex = pyphyex  # file path
        self._pyphyex = None  # module
        self.namel = namel
        self.dx = dx
        self.dy = dy
        if self.namel is not None and not isinstance(namel, dict):
            if self.namel.endswith('.namel') and os.path.exists(self.namel):
                # namelist is a filename provided by the user
                namelist_file = self.namel
            else:
                # look for a namelis with the name provided in the user's directory,
                # then in the package directory
                user_dir = os.path.join(os.environ['HOME'], '.phyex1d', 'namelists')
                package_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'namelists')
                for namel_dir in (user_dir, package_dir):
                    namelist_file = os.path.join(namel_dir, self.namel + '.namel')
                    if os.path.exists(namelist_file):
                        break
            if namelist_file is None:
                raise Phyex1DError('Namelist not found')

            with open(namelist_file, 'r', encoding='UTF-8') as f:
                self.namel = f90nml.read(f)

        class Case():  # pylint: disable=too-few-public-methods
            """Empty class to store case attributes"""
            def __init__(self, inputfile):
                self.adv_ua = 0
                self.adv_va = 0
                with netCDF4.Dataset(inputfile, 'r') as nc:  # pylint: disable=no-member
                    for k in nc.ncattrs():
                        setattr(self, k, getattr(nc, k))
        self.case = Case(inputfile)
        self.interpolators = {}

        self.cst = Cst()

    def setup(self, init_state, duration):
        """
        :param init_state: intial state
        :param duration: duration of the simulation
        """
        try:
            if self.pyphyex is None:
                # pyphyex.py should be found by python
                import pyphyex  # pylint: disable=import-outside-toplevel
            else:
                # We import pyphyex.py by file path
                spec = importlib.util.spec_from_file_location('pyphyex', self.pyphyex)
                pyphyex = importlib.util.module_from_spec(spec)
                sys.modules['pyphyex'] = pyphyex
                spec.loader.exec_module(pyphyex)
        except ModuleNotFoundError:
            logging.error("The module pyphyex has not been found. " +
                          "This module can be built with the PHYEX package " +
                          "(available on github). Details on the compilation " +
                          "process can be found in the PHYEX documentation.")
            raise
        self._pyphyex = pyphyex

        def set_default(nml):
            """
            Set default values for schemes
            """
            if 'PHYEX' not in nml:
                nml['PHYEX'] = {}
            nml['PHYEX']['CMICRO'] = nml['PHYEX'].get('CMICRO', 'ICE3')
            nml['PHYEX']['CSCONV'] = nml['PHYEX'].get('CSCONV', 'EDKF')
            nml['PHYEX']['CTURB'] = nml['PHYEX'].get('CTURB', 'TKEL')

        with tempfile.NamedTemporaryFile() as namel:
            nml = f90nml.read(namel.name)
            if self.namel is not None:
                for k, v in self.namel.items():
                    nml[k] = v
            set_default(nml)
            nml.write(namel.name, force=True)
            # First call to really initialize
            try:
                zdzmin = self.grid.get_altitude('FLUX', init_state, self.prognostic_variables).min()
            except (KeyError, Phyex1DError):
                logging.warning('Unable to compute true minimal thickness, use 20m instead')
                zdzmin = 20.
            numnml = 20
            pyphyex.PYINI_PHYEX('PHX1D', 33, namel.name, False, numnml, 0, 1, self._dt, zdzmin,
                                nml['PHYEX']['CMICRO'], nml['PHYEX']['CSCONV'],
                                nml['PHYEX']['CTURB'],
                                LDCHANGEMODEL=True, LDDEFAULTVAL=True, LDREADNAM=True,
                                LDCHECK=True, KPRINT=0, LDINIT=True)
            os.remove(f'fort.{numnml}')
            # Second call to only write the namelist
            numnml = 21
            pyphyex.PYINI_PHYEX('PHX1D', 33, namel.name, False, numnml, 0, 1, self._dt, zdzmin,
                                nml['PHYEX']['CMICRO'], nml['PHYEX']['CSCONV'],
                                nml['PHYEX']['CTURB'],
                                LDCHANGEMODEL=False, LDDEFAULTVAL=False, LDREADNAM=False,
                                LDCHECK=False, KPRINT=1, LDINIT=False)
            self.namel = f90nml.read(f'fort.{numnml}')
            set_default(self.namel)
            os.remove(f'fort.{numnml}')

    def finalize(self):
        """
        Close open resources
        """
        super().finalize()
        self._pyphyex.close()

    def execute(self, previous_state, timestep, timestep_number):
        """
        This method do the computational part of the time advance

        :param previous_state:  dictionary holding all the variables.
        :param timestep: timestep (s)
        :param timestep_number: current time step
        :returns: a 'state' dictionary containing variable values after time integration
        """
        # PHYEX
        new_state = self.phyex(previous_state, timestep, timestep_number)

        # Forcings
        new_state = self.forcing(new_state, timestep, timestep_number)

        # Vertical coordinate
        self.add_vertical_coordinate(new_state)

        # Conversions
        self.add_conversions(new_state)

        return new_state

    def add_vertical_coordinate(self, state):
        """
        Adds the vertical coordinate to the current state
        :param state: current state
        """
        state['Z_mass'] = self.grid.get_altitude('MASS', state, self.prognostic_variables)
        state['P'] = self.grid.get_pressure('MASS', state, self.prognostic_variables)

    def add_conversions(self, state):
        """
        Add some derived variables to the current state
        :param state: current state
        """
        pressure_mass = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        exner = (pressure_mass / 1.E5) ** (self.cst.Rd / self.cst.Cpd)
        if 'T' in self.prognostic_variables:
            state['Theta'] = state['T'] / exner
        elif 'Theta' in self.prognostic_variables:
            state['T'] = state['Theta'] * exner

        if 'qv' in self.prognostic_variables:
            qt = state['qv'].copy()
            for var in ('qc', 'qi', 'qr', 'qs', 'qg', 'qh'):
                qt += state[var]
            state['qt'] = qt
            for v in ('v', 'c', 'i', 'r', 's', 'g', 'h'):
                state['r' + v] = state['q' + v] / (1. - qt)
        elif 'rv' in self.prognostic_variables:
            rt = state['rv'].copy()
            for var in ('rc', 'ri', 'rr', 'rs', 'rg', 'rh'):
                rt += state[var]
            state['rt'] = rt
            for v in ('v', 'c', 'i', 'r', 's', 'g', 'h'):
                state['q' + v] = state['r' + v] / (1. + rt)

    def build_init_state(self, init_state):
        """
        Initial state
        """
        init_state = super().build_init_state(init_state)
        nc_names = {'Theta': 'theta',
                    'T': 'ta',
                    'Zs': 'orog',
                    'Ps': 'ps',
                    'qv': 'qv',
                    'qc': 'ql',
                    'qi': 'qi',
                    'qr': 'qr',
                    'qs': 'qs',
                    'qg': 'qg',
                    'qh': 'qh',
                    'rv': 'rv',
                    'rc': 'rl',
                    'ri': 'ri',
                    'rr': 'rr',
                    'rs': 'rs',
                    'rg': 'rg',
                    'rh': 'rh',
                    'u': 'ua',
                    'v': 'va',
                    'w': 'wa',
                    'sshf': 'hfss',
                    'slhf': 'hfls',
                    'z0': 'z0',
                    'z0h': 'z0h',
                    'z0q': 'z0q',
                    'tke': 'tke',
                    'Tskin': 'tskin',
                    'ustar': 'ustar',
                    'Ts': 'ts'}

        with netCDF4.Dataset(self.inputfile, 'r') as nc:  # pylint: disable=no-member
            # Surface fields
            for var in ('Zs', 'Ps', 'sshf', 'slhf', 'z0', 'z0h', 'z0q', 'Tskin', 'Ts', 'ustar'):
                if nc_names[var] in nc.variables:
                    init_state[var] = nc[nc_names[var]][0]
                else:
                    logging.warning('%s not found in the netCDF driver!', nc_names[var])

            # We perform the interpolation on the natural vertical coordinate
            if self.grid.kind in ('H', 'hybridH'):
                input_coord = nc['zh'][0, :] + nc['orog'][0]
                output_coord = self.grid.get_altitude('MASS', init_state, self.prognostic_variables)
            elif self.grid.kind in ('P', 'hybridP'):
                input_coord = nc['pa'][0, :]
                output_coord = self.grid.get_pressure('MASS', init_state, self.prognostic_variables)
            else:
                raise Phyex1DError('Wrong grid kind')

            # Interpolation of initial profiles
            for var in self.prognostic_variables:
                if var in ('qc', 'qi', 'qr', 'qs', 'qg', 'qh',
                           'rc', 'ri', 'rr', 'rs', 'rg', 'rh',
                           'w') and nc_names[var] not in nc.variables:
                    init_state[var] = numpy.zeros(output_coord.shape)
                    logging.warning('%s not found in the netCDF driver!', nc_names[var])
                else:
                    interp = RegularGridInterpolator((input_coord, ), nc[nc_names[var]][0, :],
                                                     bounds_error=False, fill_value=None)
                    init_state[var] = interp(output_coord)
            init_state['tke'] = numpy.maximum(self.namel['NAM_TURBn']['XTKEMIN'], init_state['tke'])

        # Vertical coordinates
        self.add_vertical_coordinate(init_state)

        # Conversions
        self.add_conversions(init_state)

        # Arrays needed to keep memory from one timestep to the other
        for var in ('sigs', 'WEIGHT_MF_CLOUD', 'CF_MF', 'rc_MF', 'ri_MF',
                    'HLC_HRC_MF', 'HLC_HCF_MF', 'HLI_HRI_MF', 'HLI_HCF_MF'):
            init_state[var] = numpy.zeros(init_state['P'].shape)

        # Initial value
        init_state['CF'] = numpy.zeros(init_state['P'].shape)

        return init_state

    def forcing(self, state, timestep, timestep_number):
        """
        This method do the computational part of the time advance

        :param state:  dictionary holding all the variables.
        :param timestep: timestep (s)
        :param timestep_number: current time step
        :returns: a 'state' dictionary containing variable values after time integration
        """

        def get_interpolator(var, nc):
            """
            Get from cache or build the interpolator
            :param var: variable name
            :param nc: netcdf file
            :return: interpolator, netcdf file
            """
            if var in self.interpolators:
                interp = self.interpolators[var]
            else:
                if nc is None:
                    nc = netCDF4.Dataset(self.inputfile, 'r')  # pylint: disable=no-member
                input_times = nc['time'][...]
                if len(nc[var].shape) == 2:
                    if self.grid.kind in ('H', 'hybridH'):
                        input_coord = nc['zh_forc'][0, :]
                    elif self.grid.kind in ('P', 'hybridP'):
                        input_coord = nc['pa_forc'][0, :]
                    else:
                        raise Phyex1DError('Wrong grid kind')
                    interp = RegularGridInterpolator((input_times, input_coord), nc[var][...],
                                                     bounds_error=False, fill_value=None)
                else:
                    interp = RegularGridInterpolator((input_times, ), nc[var][...],
                                                     bounds_error=False, fill_value=None)
            return interp, nc

        time = timestep * timestep_number
        if self.grid.kind in ('H', 'hybridH'):
            output_coord = self.grid.get_altitude('MASS', state, self.prognostic_variables)
        elif self.grid.kind in ('P', 'hybridP'):
            output_coord = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        else:
            raise Phyex1DError('Wrong grid kind')

        nc = None

        # Temperature advection and nudging, radiative tendency
        if 'Theta' in self.prognostic_variables:
            if self.case.adv_theta == 1:  # pylint: disable=no-member
                interp, nc = get_interpolator('tntheta_adv', nc)
                state['Theta'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                            output_coord))) * timestep
            if self.case.nudging_theta == 1:  # pylint: disable=no-member
                raise NotImplementedError('Nudging theta')
            if self.case.radiation == 'tend':  # pylint: disable=no-member
                interp, nc = get_interpolator('tntheta_rad', nc)
                state['Theta'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                            output_coord))) * timestep
        elif 'T' in self.prognostic_variables:
            if self.case.adv_ta == 1:  # pylint: disable=no-member
                interp, nc = get_interpolator('tnta_adv', nc)
                state['T'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                        output_coord))) * timestep
            if self.case.nudging_ta == 1:  # pylint: disable=no-member
                raise NotImplementedError('Nudging ta')
            if self.case.radiation == 'tend':  # pylint: disable=no-member
                interp, nc = get_interpolator('tnta_rad', nc)
                state['T'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                        output_coord))) * timestep

        # Hydrometeors advection and nudging
        if 'rv' in self.prognostic_variables:
            if self.case.adv_rv == 1:  # pylint: disable=no-member
                interp, nc = get_interpolator('tnrv_adv', nc)
                state['rv'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                         output_coord))) * timestep
            if self.case.nudging_rv == 1:  # pylint: disable=no-member
                raise NotImplementedError('Nudging rv')
        elif 'qv' in self.prognostic_variables:
            if self.case.adv_qv == 1:  # pylint: disable=no-member
                interp, nc = get_interpolator('tnqv_adv', nc)
                state['qv'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                         output_coord))) * timestep
            if self.case.nudging_qv == 1:  # pylint: disable=no-member
                raise NotImplementedError('Nudging qv')

        # Wind advection and nudging
        if self.case.adv_ua == 1:
            interp, nc = get_interpolator('tnua_adv', nc)
            state['u'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                    output_coord))) * timestep
        if self.case.adv_va == 1:
            interp, nc = get_interpolator('tnva_adv', nc)
            state['v'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                    output_coord))) * timestep
        if self.case.nudging_ua == 1:  # pylint: disable=no-member
            raise NotImplementedError('Nudging u')
        if self.case.nudging_va == 1:  # pylint: disable=no-member
            raise NotImplementedError('Nudging v')
        if self.case.forc_wa == 1:  # pylint: disable=no-member
            raise NotImplementedError('Vertical velocity')
        if self.case.forc_geo == 1:  # pylint: disable=no-member
            print('geostrophic forcing must be implemented')

        # Surface
        if 'Ts' in state:
            interp, nc = get_interpolator('ts_forc', nc)
            state['Ts'] = interp([time])[0]
        if 'Ps' in state:
            interp, nc = get_interpolator('ps_forc', nc)
            state['Ps'] = interp([time])[0]
        if self.case.surface_forcing_temp == 'surface_flux':  # pylint: disable=no-member
            interp, nc = get_interpolator('hfss', nc)
            state['sshf'] = interp([time])[0]
        if self.case.surface_forcing_moisture == 'surface_flux':  # pylint: disable=no-member
            interp, nc = get_interpolator('hfls', nc)
            state['slhf'] = interp([time])[0]
        if 'z0' in state:
            interp, nc = get_interpolator('z0', nc)
            state['z0'] = interp([time])[0]
        if 'z0h' in state:
            interp, nc = get_interpolator('z0h', nc)
            state['z0h'] = interp([time])[0]
        if 'z0q' in state:
            interp, nc = get_interpolator('z0q', nc)
            state['z0q'] = interp([time])[0]

        if nc is not None:
            nc.close()

        return state


class PhysicsArome(PhysicsBase):
    """
    Implementation of a PHYEX timestep using the AROME way
    This class is not intended to be used directly
    """

    def phyex(self, state, timestep, timestep_number):
        """
        This method do the computational part of the time advance

        :param state:  dictionary holding all the variables.
        :param timestep: timestep (s)
        :param timestep_number: current time step
        :returns: a 'state' dictionary containing variable values after time integration
        """

        # Save initial state
        state0 = {k: v.copy() for (k, v) in state.items()}

        # Preparation: grid and other dimensions
        pressure = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        z_mass = self.grid.get_altitude('MASS', state, self.prognostic_variables)
        z_flux = self.grid.get_altitude('FLUX', state, self.prognostic_variables)
        if self.grid.ascending:
            dzz = numpy.diff(z_flux)
            if dzz[-1] == numpy.inf:
                dzz[-1] = dzz[-2]
        else:
            dzz = -numpy.diff(z_flux)
            if dzz[0] == numpy.inf:
                dzz[0] = dzz[1]
        nijt = 1
        nkt = len(pressure)
        if self.namel['PHYEX']['CMICRO'] == 'ICE3':
            krr = 6
        elif self.namel['PHYEX']['CMICRO'] == 'ICE4':
            krr = 7
        else:
            raise Phyex1DError('Unknowm microphysics scheme')
        ksv = 0

        # Preparation: conversions
        exner = (pressure / 1.E5) ** (self.cst.Rd / self.cst.Cpd)
        if 'T' in self.prognostic_variables:
            theta = state['T'] / exner
            temperature = state['T']
        else:
            theta = state['Theta']
            temperature = exner * theta
        if 'qv' in self.prognostic_variables:
            qdm = 1.
            for var in ('qv', 'qc', 'qr', 'qi', 'qs', 'qg', 'qh'):
                qdm -= state[var]
            gas_constant = self.cst.Rd + state['qv'] * (self.cst.Rv - self.cst.Rd)
            for var in ('qc', 'qr', 'qi', 'qs', 'qg', 'qh'):
                gas_constant += - state[var] * self.cst.Rd
            rho = pressure / (gas_constant * temperature)
            rhodref = rho * qdm
            rv = state['qv'] / qdm
            rc = state['qc'] / qdm
            rr = state['qr'] / qdm
            ri = state['qi'] / qdm
            rs = state['qs'] / qdm
            rg = state['qg'] / qdm
            rh = state['qh'] / qdm
        else:
            rv = state['rv']
            rc = state['rc']
            rr = state['rr']
            ri = state['ri']
            rs = state['rs']
            rg = state['rg']
            rh = state['rh']
            div = 1 + state['rv']
            for var in ('rc', 'rr', 'ri', 'rs', 'rg', 'rh'):
                if var in self.prognostic_variables:
                    div += state[var]
            gas_constant = (self.cst.Rd + state['rv'] * self.cst.Rv) / div
            rho = pressure / (gas_constant * temperature)
            rhodref = pressure / ((self.cst.Rd + rv * self.cst.Rv) * theta * exner)

        # Preparation: derived fields
        rhodj = dzz * rho

        # Preparation: tendencies
        us = state['u'] / timestep
        vs = state['v'] / timestep
        ws = state['w'] / timestep
        tkes = state['tke'] / timestep
        rvs = rv / timestep
        rcs = rc / timestep
        rrs = rr / timestep
        ris = ri / timestep
        rss = rs / timestep
        rgs = rg / timestep
        rhs = rh / timestep
        thetas = theta / timestep
        if 'qv' in self.prognostic_variables:
            dqv = numpy.zeros((nkt, ))
            dqc = numpy.zeros((nkt, ))
            dqr = numpy.zeros((nkt, ))
            dqi = numpy.zeros((nkt, ))
            dqs = numpy.zeros((nkt, ))
            dqg = numpy.zeros((nkt, ))
            dqh = numpy.zeros((nkt, ))
        if 'T' in self.prognostic_variables:
            dtemperature = numpy.zeros((nkt, ))

        # Preparation: misc fields
        sigqsat = numpy.ones((nijt, )) * self.namel['NAM_NEBn']['VSIGQSAT']
        mfconv = numpy.zeros((nkt, ))
        sv = numpy.zeros((ksv, nkt))
        svs = sv / timestep

        ##################################################################
        ##################################################################
        #                       ADJUSTMENT
        ##################################################################
        ##################################################################
        if self.namel['PHYEX']['CMICRO'] == 'ICE3':
            if 'qv' in self.prognostic_variables:
                rvsin = rvs.copy()
                rcsin = rcs.copy()
                risin = ris.copy()
            if 'T' in self.prognostic_variables:
                thsin = thetas.copy()
            x = numpy.newaxis
            result = self._pyphyex.PYICE_ADJUST(
                                 nijt, nkt, 1 if self.grid.ascending else -1, 0,
                                 krr, 'DEPO', timestep,
                                 sigqsat, rhodj[:, x],
                                 exner[:, x], rhodref[:, x], state['sigs'][:, x], False,
                                 mfconv[:, x], pressure[:, x], z_mass[:, x], exner[:, x],
                                 state['CF_MF'][:, x], state['rc_MF'][:, x],
                                 state['ri_MF'][:, x], state['WEIGHT_MF_CLOUD'][:, x], rv[:, x],
                                 rc[:, x], rvs[:, x], rcs[:, x],
                                 theta[:, x], thetas[:, x],
                                 True, rr[:, x], ri[:, x],
                                 ris[:, x], rs[:, x], rg[:, x], 0,
                                 PRH=rh if krr == 7 else MISSING,
                                 PHLC_HRC_MF=state['HLC_HRC_MF'][:, x],
                                 PHLC_HCF_MF=state['HLC_HCF_MF'][:, x],
                                 PHLI_HRI_MF=state['HLI_HRI_MF'][:, x],
                                 PHLI_HCF_MF=state['HLI_HCF_MF'][:, x])
            result = [array[:, 0] for array in result]
            (_, _, _, _, _, rvs, rcs, thetas, src, state['CF'], ris, _, _, _, _,
            hlc_hrc, hlc_hcf, hli_hri, hli_hcf) = result
            theta = thetas * timestep
            temperature = theta * exner
            rv = rvs * timestep
            rc = rcs * timestep
            ri = ris * timestep

            if 'qv' in self.prognostic_variables:
                qdm = 1.
                for var in (rv, rc, rr, ri, rs, rg, rh):
                    qdm += var
                qdm = 1. / qdm
                qv = rv * qdm
                qc = rc * qdm
                qr = rr * qdm
                qi = ri * qdm
                qs = rs * qdm
                qg = rg * qdm
                qh = rh * qdm
                gas_constant = self.cst.Rd + state['qv'] * (self.cst.Rv - self.cst.Rd)
                for var in ('qc', 'qr', 'qi', 'qs', 'qg', 'qh'):
                    if var in self.prognostic_variables:
                        gas_constant += - state[var] * self.cst.Rd
                rho = pressure / (gas_constant * temperature)
                rhodref = rho * qdm
                dqv += (rvs - rvsin) * qdm
                dqc += (rcs - rcsin) * qdm
                dqi += (ris - risin) * qdm
            else:
                div = 1. + state['rv']
                for var in ('rc', 'rr', 'ri', 'rs', 'rg', 'rh'):
                    if var in self.prognostic_variables:
                        div += state[var]
                gas_constant = (self.cst.Rd + state['rv'] * self.cst.Rv) / div
                rho = pressure / (gas_constant * temperature)
                rhodref = pressure / ((self.cst.Rd + rv * self.cst.Rv) * theta * exner)

            if 'T' in self.prognostic_variables:
                dtemperature += (thetas - thsin) * exner

            # Update state to be able to recompute pressure and altitude
            if 'qv' in self.prognostic_variables:
                state['qv'] = state0['qv'] + dqv * timestep
                state['qc'] = state0['qc'] + dqc * timestep
                state['qr'] = state0['qr'] + dqr * timestep
                state['qi'] = state0['qi'] + dqi * timestep
                state['qs'] = state0['qs'] + dqs * timestep
                state['qg'] = state0['qg'] + dqg * timestep
                state['qh'] = state0['qh'] + dqh * timestep
            else:
                state['rv'] = rvs * timestep
                state['rc'] = rcs * timestep
                state['rr'] = rrs * timestep
                state['ri'] = ris * timestep
                state['rs'] = rss * timestep
                state['rg'] = rgs * timestep
                state['rh'] = rhs * timestep
            if 'T' in self.prognostic_variables:
                state['T'] = state0['T'] + dtemperature * timestep
            else:
                state['Theta'] = thetas * timestep
            pressure = self.grid.get_pressure('MASS', state, self.prognostic_variables)
            z_mass = self.grid.get_altitude('MASS', state, self.prognostic_variables)
            z_flux = self.grid.get_altitude('FLUX', state, self.prognostic_variables)
            if self.grid.ascending:
                dzz = numpy.diff(z_flux)
                if dzz[-1] == numpy.inf:
                    dzz[-1] = dzz[-2]
            else:
                dzz = -numpy.diff(z_flux)
                if dzz[0] == numpy.inf:
                    dzz[0] = dzz[1]
        else:
            raise NotImplementedError('Adjustment not implemented in the not ICE3 case')

        ##################################################################
        ##################################################################
        #                       RADIATION
        ##################################################################
        ##################################################################
        if self.case.radiation == 'on':  # pylint: disable=no-member
            raise NotImplementedError('radiation')

        ##################################################################
        ##################################################################
        #                       SURFACE
        ##################################################################
        ##################################################################
        if self.case.surface_forcing_temp == 'none':  # pylint: disable=no-member
            # Nothing to do with none
            pass
        elif self.case.surface_forcing_temp == 'surface_flux':  # pylint: disable=no-member
            sshf = state['sshf']
        else:
            raise NotImplementedError('surface_forcing_temp')
        if self.case.surface_forcing_moisture == 'none':  # pylint: disable=no-member
            # Nothing to do with none
            pass
        elif self.case.surface_forcing_moisture == 'surface_flux':  # pylint: disable=no-member
            slhf = state['slhf']
        else:
            raise NotImplementedError('surface_forcing_moisture')
        if self.case.surface_forcing_wind == 'none':  # pylint: disable=no-member
            # Nothing to do with none
            pass
        elif self.case.surface_forcing_wind == 'z0':  # pylint: disable=no-member
            print('z0 forcing must be implemented')
            sfu = 0
            sfv = 0
        else:
            raise NotImplementedError('surface_forcing_wind')

        sfsv = numpy.zeros((ksv, ))

        if 'Ts' in state:
            surface_temperature = state['Ts']
        else:
            if self.grid.ascending:
                surface_temperature = temperature[0]
            else:
                surface_temperature = temperature[-1]
        if surface_temperature > self.cst.Tt:
            latent_heat = self.cst.LvTt - (self.cst.Cpv - self.cst.Cl) * \
                          (surface_temperature - self.cst.Tt)
        else:
            latent_heat = self.cst.LsTt - (self.cst.Cpv - self.cst.Ci) * \
                          (surface_temperature - self.cst.Tt)
        sfrv = slhf / (latent_heat * rho[0 if self.grid.ascending else -1])
        sfth = sshf / (self.cst.Cpd * rho[0 if self.grid.ascending else -1])

        ##################################################################
        ##################################################################
        #                       SHALLOW CONVECTION
        ##################################################################
        ##################################################################

        # Updraft properties
        pthl_up = numpy.zeros((nkt, ))
        prt_up = numpy.zeros((nkt, ))
        prv_up = numpy.zeros((nkt, ))
        prc_up = numpy.zeros((nkt, ))
        pri_up = numpy.zeros((nkt, ))
        pu_up = numpy.zeros((nkt, ))
        pv_up = numpy.zeros((nkt, ))
        ptke_up = numpy.zeros((nkt, ))
        pthv_up = numpy.zeros((nkt, ))
        pw_up = numpy.zeros((nkt, ))
        pfrac_up = numpy.zeros((nkt, ))
        pemf = numpy.zeros((nkt, ))

        # Other arrays
        rm = numpy.array([rv, rc, rr, ri, rs, rg, rh])
        if self.grid.ascending:
            z_flux_trunc = z_flux[:-1]
        else:
            z_flux_trunc = z_flux[1:]

        x = numpy.newaxis
        result = self._pyphyex.PYSHALLOW_MF(
                             nijt, nkt, 1 if self.grid.ascending else -1,
                             0, krr, 2, 3, 0, False, 0, 0,
                             timestep, dzz[:, x], z_flux_trunc[:, x], rhodj[:, x], rhodref[:, x],
                             pressure[:, x], exner[:, x],
                             numpy.ones((nijt, )) * sfth, numpy.ones((nijt, )) * sfrv, theta[:, x],
                             rm[:krr, :, x], state['u'][:, x], state['v'][:, x], state['tke'][:, x],
                             sv[:, :, x], pthl_up[:, x], prt_up[:, x], prv_up[:, x], prc_up[:, x],
                             pri_up[:, x], pu_up[:, x], pv_up[:, x], ptke_up[:, x], pthv_up[:, x],
                             pw_up[:, x], pfrac_up[:, x], pemf[:, x],
                             self.dx, self.dy, PRSVS=svs[:, :, x], KBUDGETS=0)
        result = [array[..., 0] for array in result]
        (du_mf, dv_mf, dtke_mf, dthl_mf, drt_mf, dsv_mf, sigs_mf,
         state['rc_MF'], state['ri_MF'], state['CF_MF'], state['HLC_HRC_MF'], state['HLC_HCF_MF'],
         state['HLI_HRI_MF'], state['HLI_HCF_MF'], state['WEIGHT_MF_CLOUD'],
         flxzthvmf, flxzthmf, flxzrmf, flxzumf, flxzvmf, flxztkemf) = result[:21]
        us += du_mf
        vs += dv_mf
        tkes += dtke_mf
        svs += dsv_mf
        if 'Theta' in self.prognostic_variables:
            thetas += dthl_mf
        else:
            dtemperature += dthl_mf * exner
        if 'rv' in self.prognostic_variables:
            rvs += drt_mf
        else:
            dqv += drt_mf * qdm

        ##################################################################
        ##################################################################
        #                       TURBULENCE
        ##################################################################
        ##################################################################
        hlbcx = hlbcy = numpy.array(['cycl', 'cycl'], dtype=('S', 4))
        kgradientsleo, kgradientsgog, khalo, ksplit = 0, 0, 1, 1
        ocloudmodiflm = False
        ksv_lgbeg, ksv_lgend = 0, 0
        ksv_lima_nr, ksv_lima_ns, ksv_lima_ng, ksv_lima_nh = 0, 0, 0, 0
        o2d, onomixlg, oflat, ocouples = False, False, False, False
        oblowsnow, oibm, oflyer, ocompute_src = False, False, True, True
        rsnow = 1.
        oocean, odeepoc, odiag_in_run = False, False, False
        hturblen_cl, helec = 'DELT', 'NONE'
        dxx = dyy = dzx = dzy = numpy.ndarray((nkt, ))
        dircosxw = dircosyw = dircoszw = cosslope = 1.
        sinslope = 0.
        hgradleo = numpy.ndarray((kgradientsleo, nkt))
        hgradgog = numpy.ndarray((kgradientsgog, nkt))
        lengthm, lengthh = numpy.zeros((nkt, )), numpy.zeros((nkt, ))
        mfmoist = numpy.zeros((nkt, ))
        cei = numpy.zeros((nkt, ))
        cei_min, cei_max = 0.001E-06, 0.01E-06
        coef_ampl_sat = 5.
        kbudgets = 12
        bl_depth, sbl_depth = 0., 0.
        rm = numpy.array([rv, rc, rr, ri, rs, rg, rh])
        rs = numpy.array([rvs, rcs, rrs, ris, rss, rgs, rhs])
        thvref = theta * (1 + rv * self.cst.Rv / self.cst.Rd) / (1 + rm.sum(axis=0))
        nvext_turb = 1
        krrl = 2
        krri = 3 if krr == 6 else 4
        def x(array, reverse=False):
            """Extend vertical dimension and add horizontal one"""
            if not reverse:
                try:
                    len(array)
                    if len(array.shape) == 1:
                        new = numpy.ndarray((array.shape[0] + 2, ))
                        new[1:-1] = array
                        new[0] = new[1]
                        new[-1] = new[-2]
                        return new[:, numpy.newaxis]
                    if len(array.shape) == 2:
                        new = numpy.ndarray((array.shape[0], array.shape[1] + 2))
                        new[:, 1:-1] = array
                        new[:, 0] = new[:, 1]
                        new[:, -1] = new[:, -2]
                        return new[:, :, numpy.newaxis]
                except TypeError:
                    return numpy.ones((nijt, )) * array
                raise ValueError(type(array), str(array))
            else:
                if len(array.shape) == 3:
                    return array[:, 1:-1, 0]
                if len(array.shape) == 2:
                    return array[1:-1, 0]

        us = us * rhodj
        vs = vs * rhodj
        ws = ws * rhodj
        thetas = thetas * rhodj
        tkes = tkes * rhodj
        rs = rs * rhodj[numpy.newaxis, :]
        svs = svs * rhodj
        if self.grid.ascending:
            z_flux_trunc = z_flux[:-1]
        else:
            z_flux_trunc = z_flux[1:]

        result = self._pyphyex.PYTURB(
                nijt, nkt + 2 * nvext_turb, 1 if self.grid.ascending else -1, nvext_turb,
                krr, krrl, krri, hlbcx, hlbcy, kgradientsleo, kgradientsgog,
                khalo, ksplit, ocloudmodiflm, ksv, ksv_lgbeg, ksv_lgend,
                ksv_lima_nr, ksv_lima_ns, ksv_lima_ng, ksv_lima_nh,
                o2d, onomixlg, oflat, ocouples, oblowsnow, oibm, oflyer,
                ocompute_src, rsnow, oocean, odeepoc, odiag_in_run,
                hturblen_cl, self.namel['PHYEX']['CMICRO'], helec, timestep, 999,
                x(dxx), x(dyy), x(dzz), x(dzx), x(dzy), x(z_flux_trunc),
                x(dircosxw), x(dircosyw), x(dircoszw), x(cosslope), x(sinslope),
                x(rhodj), x(thvref), x(hgradleo), x(hgradgog), x(state['Zs']),
                x(sfth), x(sfrv), sfsv[:, numpy.newaxis], x(sfu), x(sfv),
                x(pressure), x(state['u']), x(state['v']), x(state['w']),
                x(state['tke']), x(sv), x(src), x(lengthm), x(lengthh), x(mfmoist),
                x(bl_depth), x(sbl_depth), x(cei), cei_min, cei_max, coef_ampl_sat,
                x(theta), x(rm[:krr, ...]), x(us), x(vs), x(ws), x(thetas),
                x(rs[:krr, ...]), x(svs), x(tkes),
                x(flxzthvmf), x(flxzumf), x(flxzvmf),
                kbudgets, missingOUT=['PEDR', 'PLEM', 'PDPMF', 'PTPMF',
                'PTR', 'PDISS', 'PIBM_XMUT', 'PCURRENT_TKE_DISS'])

        result = [x(array, reverse=True) for array in result]
        (_, _, _, _, us, vs, ws, thetas, rs, svs, tkes, sigs_turb, _,
         _, _, _, _, _, _, _, _, dthetal_turb, drt_turb, _) = result

        us = us / rhodj
        vs = vs /rhodj
        ws = ws / rhodj
        thetas = thetas / rhodj
        tkes = tkes / rhodj
        dthetal_turb = dthetal_turb / rhodj
        drt_turb = drt_turb / rhodj
        rs = rs / rhodj[numpy.newaxis, :]
        svs = svs / rhodj

        if 'T' in self.prognostic_variables:
            dtemperature += dthetal_turb * exner
        if 'qv' in self.prognostic_variables:
            print('We must take into account tendencies on rc and ri. Here and in arome')
            dqv += drt_turb * qdm
        else:
            rvs = rs[0]
            rcs = rs[1]
            rrs = rs[2]
            ris = rs[3]
            rss = rs[4]
            rgs = rs[5]
            if krr == 7:
                rhs = rs[6]
        state['sigs'] = numpy.sqrt(sigs_mf**2 + sigs_turb**2)

        ##################################################################
        ##################################################################
        #                       MICROPHYSICS
        ##################################################################
        ##################################################################
        #self._pyphyex.PYRAIN_ICE

        ##################################################################
        ##################################################################
        #                       NEW VALUES
        ##################################################################
        ##################################################################
        if 'qv' in self.prognostic_variables:
            state['qv'] = state0['qv'] + dqv * timestep
            state['qc'] = state0['qc'] + dqc * timestep
            state['qr'] = state0['qr'] + dqr * timestep
            state['qi'] = state0['qi'] + dqi * timestep
            state['qs'] = state0['qs'] + dqs * timestep
            state['qg'] = state0['qg'] + dqg * timestep
            state['qh'] = state0['qh'] + dqh * timestep
        else:
            state['rv'] = rvs * timestep
            state['rc'] = rcs * timestep
            state['rr'] = rrs * timestep
            state['ri'] = ris * timestep
            state['rs'] = rss * timestep
            state['rg'] = rgs * timestep
            state['rh'] = rhs * timestep
        if 'T' in self.prognostic_variables:
            state['T'] = state0['T'] + dtemperature * timestep
        else:
            state['Theta'] = thetas * timestep
        state['u'] = us * timestep
        state['v'] = vs * timestep
        state['tke'] = tkes * timestep
        return state


class PhysicsAromeTQ(PhysicsArome):
    """
    Implementation of a PHYEX timestep using the AROME way, with T and q as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None,
                 namel=None, dx=0, dy=0):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['T', 'qv', 'qc', 'qi', 'qr', 'qs', 'qg', 'qh', 'u', 'v', 'w', 'tke'],
                         pyphyex, namel, dx, dy)


class PhysicsAromeThetaR(PhysicsArome):
    """
    Implementation of a PHYEX timestep using the AROME way, with Theta and r as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None,
                 namel=None, dx=0, dy=0):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['Theta', 'rv', 'rc', 'ri', 'rr', 'rs', 'rg', 'rh', 'u', 'v', 'w', 'tke'],
                         pyphyex, namel, dx, dy)

class PhysicsForcingTQ(PhysicsBase):
    """
    Only the forcing with T and q as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None,
                 namel=None, dx=0, dy=0):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['T', 'qv', 'qc', 'qi', 'qr', 'qs', 'qg', 'qh', 'u', 'v', 'w', 'tke'],
                         pyphyex, namel, dx, dy)


class PhysicsForcingThetaR(PhysicsBase):
    """
    Only the forcing with Theta and r as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None,
                 namel=None, dx=0, dy=0):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['Theta', 'rv', 'rc', 'ri', 'rr', 'rs', 'rg', 'rh', 'u', 'v', 'w', 'tke'],
                         pyphyex, namel, dx, dy)
