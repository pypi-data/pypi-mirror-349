from __future__ import annotations
from typing import List, Any, Optional, Sequence, Tuple, Protocol, runtime_checkable
from collections.abc import Iterator

from ..rng import Rng
from .tree import Node, Leaf, Internal

class tree: ...

__all__: List[str]

class Tree:
    def __init__(self, num_leaves: int, rng: Rng): ...
    def update_edge(self, edge: int, new_child: Node) -> None: ...
    def update_weight(self, node: Node, weigth: float) -> None: ...
    def update_root(self, node: Node) -> None: ...
    def swap_parents(self, a: Node, b: Node) -> None: ...
    @property
    def num_nodes(self) -> int: ...
    @property
    def num_internals(self) -> int: ...
    @property
    def num_leaves(self) -> int: ...
    def is_internal(self, node: Node) -> bool: ...
    def is_leaf(self, node: Node) -> bool: ...
    def as_internal(self, node: Node) -> Optional[Internal]: ...
    def as_leaf(self, node: Node) -> Optional[Leaf]: ...
    def root(self) -> Internal: ...
    def weight_of(self, node: Node) -> float: ...
    def children_of(self, node: Internal) -> Tuple[Node, Node]: ...
    def edge_index(self, child: Node) -> int: ...
    def edge_distance(self, edge: int) -> float: ...
    def parent_of(self, node: Node) -> Optional[Internal]: ...
    def is_grandparent(self, node: Internal) -> bool: ...
    def random_node(self, rng: Rng) -> Node: ...
    def random_internal(self, rng: Rng) -> Internal: ...
    def random_leaf(self, rng: Rng) -> Leaf: ...
    def nodes(self) -> Iterator[Node]: ...
    def internals(self) -> Iterator[Internal]: ...
    def verify(self) -> None: ...
    def newick(self) -> str: ...

class Proposal:
    @staticmethod
    def Accept() -> Proposal: ...
    @staticmethod
    def Reject() -> Proposal: ...
    @staticmethod
    def Hastings(ratio: float) -> Proposal: ...

class Parameter:
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> int | float | bool: ...
    def __setitem__(self, index: int, value: int | float | bool): ...
    @staticmethod
    def Real(*args: float) -> Any: ...
    @staticmethod
    def Integer(*args: int) -> Any: ...
    @staticmethod
    def Boolean(*args: bool) -> Any: ...
    def is_real(self) -> bool: ...
    def is_integer(self) -> bool: ...
    def is_boolean(self) -> bool: ...

class Likelihood:
    def __init__(self, data: str, substitution: Any, tree: Tree): ...

@runtime_checkable
class Prior(Protocol):
    def probability(self) -> float: ...

class Operator(Protocol):
    def propose(self) -> Proposal: ...
    @property
    def weigth(self) -> float: ...

class Logger(Protocol):
    def log(self, mcmc: MCMC, index: int) -> None: ...
    @property
    def every(self) -> int | None: ...

class MCMC:
    def __init__(
        self,
        burnin: int,
        length: int,
        trees: Sequence[Tree],
        params: Sequence[Parameter],
        priors: Sequence[Prior],
        operators: Sequence[Operator],
        likelihoods: Sequence[Likelihood],
        loggers: Sequence[Logger],
        rng: Rng,
    ): ...
    def run(self) -> None: ...
    @property
    def posterior(self) -> float: ...
    @property
    def likelihood(self) -> float: ...
    @property
    def prior(self) -> float: ...
