import os
import argparse
import importlib.metadata
from pathlib import Path
import sys
from typing import List, Set, Dict, Optional
import fnmatch

# Default directories to ignore when generating the tree and searching for files
DEFAULT_IGNORE_DIRS = {
    "__pycache__", ".git", ".venv", "venv", "node_modules",
    "build", "dist", "target", ".idea", ".vscode",
    "docs", "tests", "test",
    ".DS_Store", "Thumbs.db"
}

# Files to be ignored by default (glob patterns using fnmatch)
DEFAULT_IGNORE_FILES = {
    # Python specific
    "*.pyc",
    "*.pyd",
    "*.pyo",
    
    # Common logs and temporary files
    "*.log",
    "*.tmp",
    "*.temp",
    
    # Editor backup/swap files
    "*.swp",
    ".*.swp",   # Hidden swap files (Vim)
    "*.swo",
    ".*.swo",   # Hidden swap files (Vim)
    "*~",       # Common for backups (e.g., Gedit, Kate)
    "*.bak",
    "*.swn",
    "*.old",
    "*.orig",   # Original patch files
    
    # Compiled files / Libraries / Executables
    "*.o",      # Object files
    "*.obj",    # Object files (Windows)
    "*.obj.d",  # Dependency files for C/C++ (generated by compilers)
    "*.hi",     # Haskell interface files
    "*.dyn_hi", # Haskell dynamic interface files
    "*.dyn_o",  # Haskell dynamic object files
    "*.a",      # Static libraries (Unix)
    "*.lib",    # Static libraries (Windows)
    "*.la",     # Libtool archives
    "*.lo",     # Libtool objects
    "*.so",     # Shared libraries (Linux)
    "*.dll",    # Dynamic link libraries (Windows)
    "*.dylib",  # Dynamic libraries (macOS)
    "*.exe",    # Executables (Windows)
    "*.out",    # Common compilation output (Unix)
    "*.app",    # macOS application bundles (can be seen as directories, but sometimes as files)
    "*.bundle", # Bundles (macOS, Ruby gems)
    
    # Java specific
    "*.class",  # Java bytecode files
    "*.jar",    # Java archives
    "*.war",    # Java Web archives
    "*.ear",    # Java Enterprise archives
    
    # Node.js specific (often in node_modules, but to be sure)
    "*.node",
    
    # Operating system generated files
    ".DS_Store", # macOS folder metadata
    "Thumbs.db", # Windows thumbnail cache
    
    # Test coverage reports
    "coverage.xml",
    ".coverage",    # coverage.py data file
    "lcov.info",    # LCOV coverage info
    "*.gcno",       # gcov coverage notes (GNU)
    "*.gcda",       # gcov coverage data (GNU)
    
    # IDE-specific file patterns (although directories are better for .idea, .vscode, etc.)
    "*.suo",             # Visual Studio user options (old)
    "*.user",            # Visual Studio / MSBuild user files
    "*.vcxproj.filters", # Visual Studio project filters
    "*.vcxproj.user",
    "*.build",           # Comum para saídas de build
    
    # Mobile development
    "*.apk",    # Android application package
    "*.ap_",    # Android package resource
    "*.ipa",    # iOS application package
}


# Simple mapping of extensions to Markdown languages
DEFAULT_EXT_TO_LANG_MAP = {
    "py": "python",
    "js": "javascript",
    "ts": "typescript",
    "java": "java",
    "c": "c",
    "cpp": "cpp",
    "cs": "csharp",
    "html": "html",
    "css": "css",
    "rb": "ruby",
    "php": "php",
    "go": "go",
    "rs": "rust",
    "kt": "kotlin",
    "swift": "swift",
    "md": "markdown",
    "json": "json",
    "yaml": "yaml",
    "yml": "yaml",
    "sh": "bash",
    "txt": "text",
    "sql": "sql",
    "xml": "xml",
    "ipynb": "json",
}


def generate_directory_tree(root_dir: Path,
                            prefix: str = "",
                            ignore_dirs: Set[str] = DEFAULT_IGNORE_DIRS,
                            current_depth: int = 0,
                            max_depth: int = -1) -> str:
    """
    Recursively generates a string representation of the directory tree.

    Args:
        root_dir: The path to the directory to start generating the tree from.
        prefix: The prefix string for indentation and tree lines (internal use).
        ignore_dirs: A set of directory names to ignore.
        current_depth: Current depth in the recursion.
        max_depth: Maximum depth to display in the tree (-1 for unlimited).
                     Depth 0 means only the root node.
                     Depth 1 means root and its direct children, etc.

    Returns:
        A string representing the directory tree structure.
    """
    tree_lines = []
    try:
        # Filter ignored directories and sort
        contents = sorted(
            p for p in root_dir.iterdir()
            if p.is_dir() and p.name not in ignore_dirs
        )
    
    except PermissionError:
        tree_lines.append(f"{prefix}└── [Permission Denied]")
        return "\n".join(tree_lines)
    
    except FileNotFoundError:
        tree_lines.append(f"{prefix}└── [Directory Not Found during tree scan]")
        return "\n".join(tree_lines)

    for i, directory in enumerate(contents):
        is_last = i == len(contents) - 1
        connector = "└── " if is_last else "├── "
        tree_lines.append(f"{prefix}{connector}{directory.name}/")

        # Prepare the prefix for the recursive call
        new_prefix_for_children = prefix + ("    " if is_last else "│   ")

        if max_depth == -1 or current_depth < max_depth:
            subtree = generate_directory_tree(directory,
                                              prefix=new_prefix_for_children,
                                              ignore_dirs=ignore_dirs,
                                              current_depth=current_depth + 1,
                                              max_depth=max_depth)
            if subtree:
                tree_lines.append(subtree)

        elif current_depth == max_depth:
            # Check if there are subdirectories not shown due to depth
            try:
                if any(p.is_dir() and p.name not in ignore_dirs for p in directory.iterdir()):
                    tree_lines.append(f"{new_prefix_for_children}└── [...]")

            except (PermissionError, FileNotFoundError):
                 tree_lines.append(f"{new_prefix_for_children}└── [Permission Denied/Not Found for sub-items]")


    return "\n".join(tree_lines)


def _collect_and_format_files(current_path: Path,
                              root_dir: Path,
                              file_extensions_to_include: Optional[List[str]],
                              max_scan_depth: int,
                              current_scan_depth: int,
                              ignore_dirs: Set[str],
                              ignore_file_patterns: List[str],
                              max_file_chars: int,
                              code_blocks_list: List[str],
                              ext_to_lang_map: Dict[str, str]):
    """
    Collects and formats code files recursively, respecting depth, extensions, and limits.
    This is a helper function for generate_markdown_context.
    """
    try:
        items_in_current_path = sorted(current_path.iterdir(), key=lambda p: (p.is_file(), p.name))
    
    except PermissionError:
        print(f"Warning: Permission denied to access directory {current_path}")
        return
    
    except FileNotFoundError:
        print(f"Warning: Directory not found during file scan: {current_path}")
        return

    for item in items_in_current_path:
        if item.is_file():
            file_ext_without_dot = item.suffix[1:].lower() if item.suffix else ""

            # 1. Check if the file extension is one of the desired ones (if a list is provided)
            if file_extensions_to_include is not None and file_ext_without_dot not in file_extensions_to_include:
                continue

            # 2. Check if the file should be ignored by a pattern
            if any(fnmatch.fnmatch(item.name, pattern) for pattern in ignore_file_patterns):
                continue

            # Process the file
            try:
                try:
                    content = item.read_text(encoding='utf-8')
                except UnicodeDecodeError:
                    print(f"Warning: Could not read {item} as UTF-8, trying system's default encoding.")
                    content = item.read_text() # Try with the system's default encoding

                truncated_info = ""
                if max_file_chars > 0 and len(content) > max_file_chars:
                    content = content[:max_file_chars]
                    truncated_info = f"\n\n# --- [CONTENT TRUNCATED AT {max_file_chars} CHARACTERS] ---"

                # Calculate the path relative to the project root directory
                try:
                    relative_path = item.relative_to(root_dir)
                
                except ValueError: # If item is not under root_dir (e.g. a symlink outside)
                    relative_path = item 

                comment_path = "/".join(relative_path.parts) # Use / for OS consistency
                language_tag = ext_to_lang_map.get(file_ext_without_dot, file_ext_without_dot if file_ext_without_dot else "text")

                block = f"```{language_tag}\n# Path: {comment_path}\n{content}{truncated_info}\n```"
                code_blocks_list.append(block)

            except Exception as e:
                print(f"Warning: Could not read or process file {item}: {e}")

        elif item.is_dir() and item.name not in ignore_dirs:
            # 3. Recurse into subdirectories if the maximum scan depth allows
            if max_scan_depth == -1 or current_scan_depth < max_scan_depth:
                _collect_and_format_files(current_path=item,
                                          root_dir=root_dir,
                                          file_extensions_to_include=file_extensions_to_include,
                                          max_scan_depth=max_scan_depth,
                                          current_scan_depth=current_scan_depth + 1,
                                          ignore_dirs=ignore_dirs,
                                          ignore_file_patterns=ignore_file_patterns,
                                          max_file_chars=max_file_chars,
                                          code_blocks_list=code_blocks_list,
                                          ext_to_lang_map=ext_to_lang_map)


def generate_markdown_context(directory_path: str,
                              output_file: Optional[str] = None,
                              include_tree: bool = True,
                              ignore_dirs_set: Set[str] = DEFAULT_IGNORE_DIRS,
                              ignore_file_patterns_list: List[str] = list(DEFAULT_IGNORE_FILES),
                              target_extensions: Optional[List[str]] = None,
                              scan_max_depth: int = -1,
                              file_char_limit: int = -1,
                              lang_map: Dict[str, str] = DEFAULT_EXT_TO_LANG_MAP) -> str:
    """
    Scans a directory for files (based on extensions) and generates
    a Markdown string containing their contents and optionally a directory tree.

    Args:
        directory_path: Path to the target directory containing source files.
        output_file: Optional file path to save the generated Markdown output.
        include_tree: Include the directory tree structure at the beginning.
        ignore_dirs_set: Set of directory names to ignore.
        ignore_file_patterns_list: List of file name patterns to ignore (fnmatch).
        target_extensions: List of file extensions to include (e.g., ['py', 'js']).
                           None to include all files not explicitly ignored.
        scan_max_depth: Maximum depth to scan directories (for tree and files).
                        -1 for unlimited. 0 means only the root directory (files in root, tree only shows root name).
        file_char_limit: Maximum characters per file to include in the Markdown.
                         Excess content will be truncated. -1 for unlimited.
        lang_map: Mapping from extension to Markdown language tag

    Returns:
        A string containing the formatted Markdown content.

    Raises:
        FileNotFoundError: If the specified directory does not exist.
    """
    root_dir = Path(directory_path).resolve() # Ensure absolute and clean path
    if not root_dir.is_dir():
        raise FileNotFoundError(f"Error: Directory not found at '{directory_path}'")

    markdown_parts = []

    # 1. Generate and add the directory tree if requested and if depth allows for more than just the root
    if include_tree:
        tree_str = generate_directory_tree(root_dir, 
                                           ignore_dirs=ignore_dirs_set, 
                                           current_depth=0, 
                                           max_depth=scan_max_depth)
        depth_label = 'unlimited' if scan_max_depth == -1 else str(scan_max_depth)
        tree_markdown = (
            f"### Project Structure (Max Tree Depth: {depth_label})\n\n"
            f"```\n{root_dir.name}/\n{tree_str}\n```"
        )
        markdown_parts.append(tree_markdown)

    # 2. Collect and format file contents
    code_blocks: List[str] = []
    _collect_and_format_files(current_path=root_dir,
                              root_dir=root_dir,
                              file_extensions_to_include=target_extensions,
                              max_scan_depth=scan_max_depth,
                              current_scan_depth=0,
                              ignore_dirs=ignore_dirs_set,
                              ignore_file_patterns=ignore_file_patterns_list,
                              max_file_chars=file_char_limit,
                              code_blocks_list=code_blocks,
                              ext_to_lang_map=lang_map)

    if code_blocks:
        markdown_parts.append("\n\n### Files content\n")
        markdown_parts.append("\n\n---\n\n".join(code_blocks))

    final_markdown = "\n\n".join(markdown_parts).strip()

    # 3. Save or print the final result
    if output_file:
        try:
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(final_markdown, encoding='utf-8')
            print(f"Markdown context successfully saved to: {output_path.resolve()}")
        
        except Exception as e:
            print(f"Error: Could not write to output file {output_file}: {e}")
            print("\n--- Generated Markdown (console preview) ---")
            print(final_markdown)
    else:
        print(final_markdown)

    return final_markdown


def main():
    try:
        __version__ = importlib.metadata.version("contextify-cli")

    except importlib.metadata.PackageNotFoundError:
        __version__ = "0.1.0" # Fallback to local development
        
    parser = argparse.ArgumentParser(
        description="Contextify: Prepares code as Markdown context for various purposes.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s {__version__}'
    )
    parser.add_argument(
        "directory",
        help="Path to the target directory containing source files.",
    )
    parser.add_argument(
        "-o", "--output",
        help="Optional file path to save the generated Markdown output.",
        default=None
    )
    parser.add_argument(
        "--no-tree",
        action="store_false",
        dest="include_tree",
        help="Do not include the directory tree structure in the output.",
    )
    parser.add_argument(
        "-ext", "--extensions",
        help="Comma-separated list of file extensions to include (e.g., py,js,txt).\n"
             "If not specified, processes Python (.py) files by default.\n"
             "Use 'ALL' to process all files not ignored by --ignore-file.",
        default="py"
    )
    parser.add_argument(
        "-depth", "--max-depth",
        type=int,
        default=-1,
        help="Maximum depth to scan directories (for tree and files).\n"
             "-1 for unlimited. 0 means only the root directory (files in root, tree only shows root name)."
    )
    parser.add_argument(
        "-mfc", "--max-file-chars",
        type=int,
        default=-1,
        help="Maximum number of characters per file to include in the Markdown.\n"
             "Excess content will be truncated. -1 for unlimited."
    )
    parser.add_argument(
        "--ignore-dir",
        action="append",
        default=[],
        help="Specify directory names to ignore (e.g., venv, .git).\n"
             "Can be used multiple times. Combines with internal defaults.\n"
             f"Defaults already included: {', '.join(list(DEFAULT_IGNORE_DIRS)[:5])}..."
    )
    parser.add_argument(
        "--ignore-file",
        action="append",
        default=[],
        help="Specify file name patterns to ignore (e.g., *.log, temp.*).\n"
             "Uses fnmatch pattern matching. Can be used multiple times.\n"
             f"Defaults already included: {', '.join(list(DEFAULT_IGNORE_FILES)[:5])}..."
    )

    args = parser.parse_args()

    # Process extensions
    selected_extensions: Optional[List[str]]
    if args.extensions.strip().upper() == 'ALL':
        selected_extensions = None

    elif not args.extensions.strip():
        selected_extensions = []
        print("Warning: No extensions specified for inclusion (empty --extensions parameter).")

    else:
        selected_extensions = [
            ext.strip().lower().lstrip('.') for ext in args.extensions.split(',') if ext.strip()
        ]

    final_ignore_dirs = DEFAULT_IGNORE_DIRS.union(set(args.ignore_dir))
    final_ignore_files = list(DEFAULT_IGNORE_FILES) + args.ignore_file

    try:
        generate_markdown_context(args.directory,
                                  args.output,
                                  include_tree=args.include_tree,
                                  ignore_dirs_set=final_ignore_dirs,
                                  ignore_file_patterns_list=final_ignore_files,
                                  target_extensions=selected_extensions,
                                  scan_max_depth=args.max_depth,
                                  file_char_limit=args.max_file_chars,
                                  lang_map=DEFAULT_EXT_TO_LANG_MAP)
    
    except FileNotFoundError as e:
        print(f"Fatal Error: {e}")
        sys.exit(1)
    
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)