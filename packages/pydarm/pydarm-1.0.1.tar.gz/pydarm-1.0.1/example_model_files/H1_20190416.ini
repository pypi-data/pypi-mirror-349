[metadata]
run = O3
model_date = 2019-04-16

# GPS times for which the model is valid
start = 1239468992
end   = 1267056018

# Directory where all the data files (.mat, .txt, .dat) live
cal_data_root =

[interferometer]
name         = H1

[sensing]
# Parameters directly associated with sensing function
# Note the change in gain because the O4 scheme allocates any
# AA gain in the optical gain whereas this was not the case
# in O1-O3
coupled_cavity_optical_gain   = 3.22e6
coupled_cavity_pole_frequency = 410.6
detuned_spring_frequency      = 4.468
detuned_spring_Q              = 52.14
DARM_ERR_counts_per_DCPD_mA   = 1.33511e6
sensing_sign                  = 1
is_pro_spring                 = 1

# Interferometer arm lengths
x_arm_length = 3994.4704
y_arm_length = 3994.4692

# Digital anti-aliasing filter parameters (same for all paths)
# Putting multiple will apply multiple filters to all paths
# 512k-daq is a special instance of the 8x DAQ downsampling filter
anti_aliasing_rate_string = 16k
anti_aliasing_method      = biquad

# Number of OMC DCPD paths
omc_path_names = A, B

# Analog anti-aliasing filter model (can be same or different for each path)
# analog_anti_aliasing_file = <path-relative-to-cal_data_root>/H1aa.mat, <path-relative-to-cal_data_root>/H1aa.mat
analog_anti_aliasing_file = H1aa.mat, H1aa.mat

# 2**15 cts / 20 V = 1638.4 cts / V
# Note that the value here is the inverse of the compensation module 4 at LHO
# Potentially one could set this to be = 1 but then you need to remove the
# compensation module 4 under omc_compensation_filter_modules_in_use (for LHO)
adc_gain = 1638.001638001638, 1638.001638001638

# OMC path analog electronics zeros and poles frequencies measured by
# spectrum analyzer like SR785
# A colon separates the values in the named paths with commas separating
# values in a given path
omc_meas_z_trans_amplifier_compensated =
omc_meas_p_trans_amplifier_compensated =
omc_meas_z_trans_amplifier_uncompensated =
omc_meas_p_trans_amplifier_uncompensated = 13.7e3, 17.8e3: 13.7e3, 17.8e3

# The detector may operate with different whitening modes due to switchable states of the
# analog electronics.
# It has been found that the zeros and poles are slighty different, depending on which state
# has been set in the sensing paths.
# It is helpful to have both zeros and poles listed in the configuration file, but only one
# set of zeros and poles will be used.
# A set of zeros and poles for a given operating mode is identified by the appended string
# after " omc_meas_(z|p)_whitening_".
# In the example below, the mode names are "mode1" and "mode2" but they could be renamed
# something more descriptive (like "logain" and "higain").
# The mode that will be used to compute the DARM loop transfer functions is whichever values
# are given to the "whitening_mode_names" key.
# In the example below, "mode1" is used for both sensing paths, but they are not required to
# be the same (meaning, one could use "whitening_mode_names = mode1, mode2", for example).
whitening_mode_names = mode1, mode1
omc_meas_z_whitening_compensated_mode1 =
omc_meas_p_whitening_compensated_mode1 =
omc_meas_z_whitening_compensated_mode2 =
omc_meas_p_whitening_compensated_mode2 =
omc_meas_z_whitening_uncompensated_mode1 =
omc_meas_p_whitening_uncompensated_mode1 = 11.346e3, 32.875e3, 32.875e3: 11.521e3, 32.863e3, 32.863e3
omc_meas_z_whitening_uncompensated_mode2 =
omc_meas_p_whitening_uncompensated_mode2 =

# OMC electronics can have an apparent delay because of high frequency poles,
# above the measurement limit of the SR785 (see G2200551)
# Here they are set to be zero because this change is in O4
super_high_frequency_poles_apparent_delay = 0, 0

# This is the compensation filter bank, modules in use, and gain
# Only add modules in use if you also put the low frequency poles and zeros
# in the above measured zeros and poles values, otherwise below can be blank
# The same is true if you add the zeros and poles above, you need to add the
# bank, modules in use, and gain values below.
# One needs to be very cognizant of putting in the compensation filters here
# because, at least at LHO, the compensation filters have non-unity DC gain.
# So putting these filters in use will mean that there will be changes to the
# overall gain of the sensing path. Caution is advised!
omc_filter_file = H1OMC_1239468752.txt
omc_filter_bank = OMC_DCPD_A, OMC_DCPD_B
omc_filter_gain = 1, 1
omc_trans_amplifier_compensation_modules =
omc_whitening_compensation_modules_mode1 =
omc_whitening_compensation_modules_mode2 =
omc_front_end_trans_amplifier_compensation = ON, ON
omc_front_end_whitening_compensation_mode1 = ON, ON
omc_front_end_whitening_compensation_mode2 = ON, ON
omc_filter_noncompensating_modules = 4: 4

# OMC path gain ratio
# Gain ratio is the product of:
# OMC BS ratio
# PD gain ratio
# Transimpedence amplifier gain ratio
# Whitening chassis gain ratio
# Analog AA gain ratio
# ADC gain ratio
# (If not set above in the filter banks and gain) the rough A/ct (or mA/ct) ratio
# Numerator is the path in question, denominator is the reference path
# which is usually the "A" path
gain_ratio = 1, 1  # only the reference will often be 1, and we desire the others to be 1 as well (often not exactly)

# The digital gain set in the front end balance matrix
balance_matrix = 1, 1

# Single pole approximation has too much delay for true length response,
# so here there is an advance (the minus sign on a delay) added. See G1501316
single_pole_approximation_delay_correction = -12e-6

# The O1-O3 sensing chain did not have any measureable delay from analog to
# the 16k digital readout. In O4, a new sensing ADC readout has been installed
# resulting in a new delay of 5 524288 Hz clock cycles
adc_delay_cycles = 0, 0
adc_clock = 65536

[digital]
digital_filter_file    = H1OMC_1239468752.txt
digital_filter_bank    = LSC_DARM1, LSC_DARM2
digital_filter_modules = 1,2,3,4,7,9,10: 3,4,5,6,7
digital_filter_gain    = 400,1

[actuation]
# actuation parameters

# Fill in DARM output matrix values [EX,EY,IX,IY]
darm_output_matrix = 1.0, -1.0, 0.0, 0.0
# Fill in OFF or ON for a 1x4 array [MO,L1,L2,L3] for X and Y arms
darm_feedback_x    = OFF, ON, ON, ON
darm_feedback_y    = OFF, OFF, OFF, OFF

#################
#    x - arm    #
#################
[actuation_x_arm]
darm_feedback_sign = -1  # This should not be changed
# UIM = 1.634     ==> 7.67e-08 (N/ct)
# PUM = 0.02947   ==> 6.036e-10 (N/ct)
# TST = 4.427e-11 ==> 4.727e-12 (N/ct)
uim_NpA       = 1.634
pum_NpA       = 0.02947
tst_NpV2      = 4.427e-11
linearization = OFF
actuation_esd_bias_voltage = -9.3

# actuation filter file
sus_filter_file = H1SUSETMX_1236641144.txt

# TST interferometer sensing and control
tst_isc_inf_bank    = ETMX_L3_ISCINF_L
tst_isc_inf_modules =
tst_isc_inf_gain    = 1.0

# TST lock settings
tst_lock_bank       = ETMX_L3_LOCK_L
tst_lock_modules    = 5,8,9,10
tst_lock_gain       = 1.0

# TST drive align
tst_drive_align_bank     = ETMX_L3_DRIVEALIGN_L2L
tst_drive_align_modules  = 4,5
tst_drive_align_gain     = -35.7

# PUM lock settings
pum_lock_bank    = ETMX_L2_LOCK_L
pum_lock_modules = 7
pum_lock_gain    = 23.0

# PUM drive align settings
pum_drive_align_bank    = ETMX_L2_DRIVEALIGN_L2L
pum_drive_align_modules = 6,7
pum_drive_align_gain    = 1.0
# L1 needs -1 here, because of poor OSEM convention V
pum_coil_outf_signflip  = 1

# UIM lock settings
uim_lock_bank    = ETMX_L1_LOCK_L
uim_lock_modules = 10
uim_lock_gain    = 1.06

# UIM dirive align settings
uim_drive_align_bank    = ETMX_L1_DRIVEALIGN_L2L
uim_drive_align_modules =
uim_drive_align_gain    = 1.0

# suspension file contains the force to length transfer function
suspension_file = H1susdata_O3.mat

# Driver parameters and setup. Updated 2019-03-04, LHO aLOG 44469
tst_driver_compensated_Z_UL =
tst_driver_compensated_Z_LL =
tst_driver_compensated_Z_UR =
tst_driver_compensated_Z_LR =
tst_driver_compensated_P_UL =
tst_driver_compensated_P_LL =
tst_driver_compensated_P_UR =
tst_driver_compensated_P_LR =
tst_driver_uncompensated_Z_UL = 129.7e3
tst_driver_uncompensated_Z_LL = 90.74e3
tst_driver_uncompensated_Z_UR = 93.52e3
tst_driver_uncompensated_Z_LR = 131.5e3
tst_driver_uncompensated_P_UL = 3.213e3, 31.5e3
tst_driver_uncompensated_P_LL = 3.177e3, 26.7e3
tst_driver_uncompensated_P_UR = 3.279e3, 26.6e3
tst_driver_uncompensated_P_LR = 3.238e3, 31.6e3
# This is the compensation filter bank, modules in use, and gains
# Only add the modules in use if you also put the low frequency poles and zeros
# in the above measured zeros and poles values, otherwise below can be blank
# The same is true if you add the zeros and poles above, you need to add the
# bank, modules in use, and gains
tst_filter_bank_UL =
tst_compensation_filter_modules_UL =
tst_filter_gain_UL =
tst_filter_bank_LL =
tst_compensation_filter_modules_LL =
tst_filter_gain_LL =
tst_filter_bank_UR =
tst_compensation_filter_modules_UR =
tst_filter_gain_UR =
tst_filter_bank_LR =
tst_compensation_filter_modules_LR =
tst_filter_gain_LR =
tst_front_end_driver_compensation_UL = ON
tst_front_end_driver_compensation_LL = ON
tst_front_end_driver_compensation_UR = ON
tst_front_end_driver_compensation_LR = ON

# Driver parameters and setup for PUM
pum_driver_compensated_Z_UL =
pum_driver_compensated_Z_LL =
pum_driver_compensated_Z_UR =
pum_driver_compensated_Z_LR =
pum_driver_compensated_P_UL =
pum_driver_compensated_P_LL =
pum_driver_compensated_P_UR =
pum_driver_compensated_P_LR =
pum_driver_uncompensated_Z_UL =
pum_driver_uncompensated_Z_LL =
pum_driver_uncompensated_Z_UR =
pum_driver_uncompensated_Z_LR =
pum_driver_uncompensated_P_UL =
pum_driver_uncompensated_P_LL =
pum_driver_uncompensated_P_UR =
pum_driver_uncompensated_P_LR =
pum_filter_bank_UL =
pum_compensation_filter_modules_UL =
pum_filter_gain_UL =
pum_filter_bank_LL =
pum_compensation_filter_modules_LL =
pum_filter_gain_LL =
pum_filter_bank_UR =
pum_compensation_filter_modules_UR =
pum_filter_gain_UR =
pum_filter_bank_LR =
pum_compensation_filter_modules_LR =
pum_filter_gain_LR =
pum_front_end_driver_compensation_UL = ON
pum_front_end_driver_compensation_LL = ON
pum_front_end_driver_compensation_UR = ON
pum_front_end_driver_compensation_LR = ON

# Driver parameters and setup for UIM
uim_driver_compensated_Z_UL =
uim_driver_compensated_Z_LL =
uim_driver_compensated_Z_UR =
uim_driver_compensated_Z_LR =
uim_driver_compensated_P_UL =
uim_driver_compensated_P_LL =
uim_driver_compensated_P_UR =
uim_driver_compensated_P_LR =
uim_driver_uncompensated_Z_UL =
uim_driver_uncompensated_Z_LL =
uim_driver_uncompensated_Z_UR =
uim_driver_uncompensated_Z_LR =
uim_driver_uncompensated_P_UL =
uim_driver_uncompensated_P_LL =
uim_driver_uncompensated_P_UR =
uim_driver_uncompensated_P_LR =
uim_filter_bank_UL =
uim_compensation_filter_modules_UL =
uim_filter_gain_UL =
uim_filter_bank_LL =
uim_compensation_filter_modules_LL =
uim_filter_gain_LL =
uim_filter_bank_UR =
uim_compensation_filter_modules_UR =
uim_filter_gain_UR =
uim_filter_bank_LR =
uim_compensation_filter_modules_LR =
uim_filter_gain_LR =
uim_front_end_driver_compensation_UL = ON
uim_front_end_driver_compensation_LL = ON
uim_front_end_driver_compensation_UR = ON
uim_front_end_driver_compensation_LR = ON

# Dead reckoned from circuit schematic
tst_driver_DC_gain_VpV_HV = 40
tst_driver_DC_gain_VpV_LV = 1.881
pum_driver_DC_trans_ApV = 2.6847e-4
uim_driver_DC_trans_ApV = 6.1535e-4

# anti imaging filter file settings
anti_imaging_rate_string = 16k
anti_imaging_method      = biquad
analog_anti_imaging_file = H1aa.mat
# DAC gain in V/ct note that this is 20 / 2**18
dac_gain = 7.62939453125e-05

# unknown_actuation_delay is applied to all stages
unknown_actuation_delay = 15e-6

# individual delays applied to stages separately
uim_delay = 0
pum_delay = 0
tst_delay = 0

#################
#    y - arm    #
#################
[actuation_y_arm]
darm_feedback_sign = 1  # This should not be changed
# UIM =      ==>  (N/ct)
# PUM =      ==>  (N/ct)
# TST =      ==>  (N/ct)
uim_NpA       =
pum_NpA       =
tst_NpV2      =
linearization =
actuation_esd_bias_voltage =

# actuation filter file
sus_filter_file =

# TST interferometer sensing and control
tst_isc_inf_bank    = ETMY_L3_ISCINF_L
tst_isc_inf_modules =
tst_isc_inf_gain    = 1.0

# TST lock settings
tst_lock_bank       = ETMY_L3_LOCK_L
tst_lock_modules    =
tst_lock_gain       = 1.0

# TST drive align
tst_drive_align_bank     = ETMY_L3_DRIVEALIGN_L2L
tst_drive_align_modules  =
tst_drive_align_gain     = 1.0

# PUM lock settings
pum_lock_bank    = ETMY_L2_LOCK_L
pum_lock_modules =
pum_lock_gain    = 1.0

# PUM drive align settings
pum_drive_align_bank    = ETMY_L2_DRIVEALIGN_L2L
pum_drive_align_modules =
pum_drive_align_gain    = 1.0
# L1 needs -1 here, because of poor OSEM convention V
pum_coil_outf_signflip  = 1

# UIM lock settings
uim_lock_bank    = ETMY_L1_LOCK_L
uim_lock_modules =
uim_lock_gain    = 1.0

# UIM dirive align settings
uim_drive_align_bank    = ETMY_L1_DRIVEALIGN_L2L
uim_drive_align_modules =
uim_drive_align_gain    = 1.0

# suspension file contains the force to length transfer function
suspension_file =

# Driver parameters and setup
tst_driver_compensated_Z_UL =
tst_driver_compensated_Z_LL =
tst_driver_compensated_Z_UR =
tst_driver_compensated_Z_LR =
tst_driver_compensated_P_UL =
tst_driver_compensated_P_LL =
tst_driver_compensated_P_UR =
tst_driver_compensated_P_LR =
tst_driver_uncompensated_Z_UL =
tst_driver_uncompensated_Z_LL =
tst_driver_uncompensated_Z_UR =
tst_driver_uncompensated_Z_LR =
tst_driver_uncompensated_P_UL =
tst_driver_uncompensated_P_LL =
tst_driver_uncompensated_P_UR =
tst_driver_uncompensated_P_LR =
# This is the compensation filter bank, modules in use, and gains
# Only add the modules in use if you also put the low frequency poles and zeros
# in the above measured zeros and poles values, otherwise below can be blank
# The same is true if you add the zeros and poles above, you need to add the
# bank, modules in use, and gains
tst_filter_bank_UL =
tst_compensation_filter_modules_UL =
tst_filter_gain_UL =
tst_filter_bank_LL =
tst_compensation_filter_modules_LL =
tst_filter_gain_LL =
tst_filter_bank_UR =
tst_compensation_filter_modules_UR =
tst_filter_gain_UR =
tst_filter_bank_LR =
tst_compensation_filter_modules_LR =
tst_filter_gain_LR =
tst_front_end_driver_compensation_UL = ON
tst_front_end_driver_compensation_LL = ON
tst_front_end_driver_compensation_UR = ON
tst_front_end_driver_compensation_LR = ON

# Driver parameters and setup for PUM
pum_driver_compensated_Z_UL =
pum_driver_compensated_Z_LL =
pum_driver_compensated_Z_UR =
pum_driver_compensated_Z_LR =
pum_driver_compensated_P_UL =
pum_driver_compensated_P_LL =
pum_driver_compensated_P_UR =
pum_driver_compensated_P_LR =
pum_driver_uncompensated_Z_UL =
pum_driver_uncompensated_Z_LL =
pum_driver_uncompensated_Z_UR =
pum_driver_uncompensated_Z_LR =
pum_driver_uncompensated_P_UL =
pum_driver_uncompensated_P_LL =
pum_driver_uncompensated_P_UR =
pum_driver_uncompensated_P_LR =
pum_filter_bank_UL =
pum_compensation_filter_modules_UL =
pum_filter_gain_UL =
pum_filter_bank_LL =
pum_compensation_filter_modules_LL =
pum_filter_gain_LL =
pum_filter_bank_UR =
pum_compensation_filter_modules_UR =
pum_filter_gain_UR =
pum_filter_bank_LR =
pum_compensation_filter_modules_LR =
pum_filter_gain_LR =
pum_front_end_driver_compensation_UL = ON
pum_front_end_driver_compensation_LL = ON
pum_front_end_driver_compensation_UR = ON
pum_front_end_driver_compensation_LR = ON

# Driver parameters and setup for UIM
uim_driver_compensated_Z_UL =
uim_driver_compensated_Z_LL =
uim_driver_compensated_Z_UR =
uim_driver_compensated_Z_LR =
uim_driver_compensated_P_UL =
uim_driver_compensated_P_LL =
uim_driver_compensated_P_UR =
uim_driver_compensated_P_LR =
uim_driver_uncompensated_Z_UL =
uim_driver_uncompensated_Z_LL =
uim_driver_uncompensated_Z_UR =
uim_driver_uncompensated_Z_LR =
uim_driver_uncompensated_P_UL =
uim_driver_uncompensated_P_LL =
uim_driver_uncompensated_P_UR =
uim_driver_uncompensated_P_LR =
uim_filter_bank_UL =
uim_compensation_filter_modules_UL =
uim_filter_gain_UL =
uim_filter_bank_LL =
uim_compensation_filter_modules_LL =
uim_filter_gain_LL =
uim_filter_bank_UR =
uim_compensation_filter_modules_UR =
uim_filter_gain_UR =
uim_filter_bank_LR =
uim_compensation_filter_modules_LR =
uim_filter_gain_LR =
uim_front_end_driver_compensation_UL = ON
uim_front_end_driver_compensation_LL = ON
uim_front_end_driver_compensation_UR = ON
uim_front_end_driver_compensation_LR = ON

# Dead reckoned from circuit schematic
tst_driver_DC_gain_VpV_HV = 40
tst_driver_DC_gain_VpV_LV = 1.881
pum_driver_DC_trans_ApV = 2.6847e-4
uim_driver_DC_trans_ApV = 6.1535e-4

# anti imaging filter file settings
anti_imaging_rate_string = 16k
anti_imaging_method      = biquad
analog_anti_imaging_file = H1aa.mat
# DAC gain in V/ct note that this is 20 / 2**18
dac_gain = 7.62939453125e-05

# unknown_actuation_delay is applied to all stages
unknown_actuation_delay = 15e-6

# individual delays applied to stages separately
uim_delay = 0
pum_delay = 0
tst_delay = 0

[pcal]
# importing susnorm and mpN_DC gain
pcal_filter_file           = H1CALEY_1123041152.txt
pcal_filter_bank           = PCALY_TX_PD
pcal_filter_modules_in_use = 6,8
pcal_filter_gain           = 1.0

pcal_dewhiten               = 1.0, 1.0
pcal_incidence_angle        = 8.8851

# pcal_etm_watts_per_ofs_volt LHO alog 46846
pcalx_etm_watts_per_ofs_volt = 0.13535

# Used for measurements like swept sine or broadband transfer functions
# x-arm ==> 1, y-arm ==> -1
# Change this value only if the Pcal arm for the measurements is different
ref_pcal_2_darm_act_sign = -1.0
# For other use of pcal correction factors, these parameters are useful (defaults)
pcalx_to_darm_act_sign = 1
pcaly_to_darm_act_sign = -1
# instead of the defined ref_pcal_2_darm_act_sign above, one can use the
# defined pcal*_to_darm_act_sign key values as above and the following key value
ref_pcal = Y

# DAC gain in V/ct note that this is 20 / 2**18
dac_gain = 7.62939453125e-05

# Pcal Anti-aliasing filter parameters
anti_aliasing_rate_string = 16k
anti_aliasing_method      = biquad
analog_anti_aliasing_file = H1aa.mat

[calcs]
# GDS Compensation for Bad Foton Filter Approximation for High Frequency Roll-Off of Calibration
foton_invsensing_tf = 2019-04-04_H1CALCS_InverseSensingFunction_Foton_SRCD-2N_Gain_tf.txt
invsensing_gain = 1.0

xarm_uim_coiloutf =
xarm_pum_coiloutf =
xarm_tst_coiloutf =
yarm_uim_coiloutf =
yarm_pum_coiloutf =
yarm_tst_coiloutf =

# Here we can put some filter exports for what CAL-CS is doing
# Need to export transfer functions of applied filters (multiple)
xarm_uim_analog = H1CALCS_ETMX_L1_ANALOG.txt
xarm_pum_analog = H1CALCS_ETMX_L2_ANALOG.txt
xarm_tst_analog = H1CALCS_ETMX_L3_ANALOG.txt
xarm_uim_analog_gain = 1.0
xarm_pum_analog_gain = 1.0
xarm_tst_analog_gain = 1.0
yarm_uim_analog =
yarm_pum_analog =
yarm_tst_analog =

xarm_output_matrix = 0.0, -1.0, -1.0, -1.0
yarm_output_matrix = 0.0, 0.0, 0.0, 0.0

foton_delay_filter_tf = H1CALCS_8_CLK_DELAY.txt

# This is the CAL-DELTAL_EXTERNAL whitening transfer function export
foton_deltal_whitening_tf = H1CALCS_DELTAL_EXTERNAL_WHITENING_tf.txt

# Calibration line frequencies in units of Hz
# pcal lines without x or y in their variable name are assumed to be
# "REF" (reference) Pcal calibration lines defined in [pcal] as either
# ref_pcal_2_darm_act_sign OR ref_pcal = <arm> together with
# pcal<arm>_to_darm_act_sign
cal_line_sus_uim_frequency = 15.6
cal_line_sus_pum_frequency = 16.4
cal_line_sus_tst_frequency = 17.6
cal_line_sus_pcal_frequency = 17.1
cal_line_sens_pcal_frequency = 410.3
cal_line_high_pcal_frequency = 1083.7
cal_line_low_pcal_frequency = 0.1
cal_line_cmp_pcalx_frequency = 410.3
cal_line_cmp_pcaly_frequency = 410.4
# Systematic error lines can either be named or unnamed. If they are
# named, then the values look like this:
# LINE5=33.43, LINE6=53.67, LINE7=77.73, LINE8=102.13, LINE9=283.91, LINE10=1153.10
# Unnamed, then the values look like this:
# 33.43, 53.67, 77.73, 102.13, 283.91, 1153.10
# where the order will be the line number starting with LINE5 and ascending.
# Either all must be named, or none can be named
cal_line_sys_pcalx_frequencies = LINE5=33.43, LINE6=53.67, LINE7=77.73, LINE8=102.13, LINE9=283.91, LINE10=1153.10

[FIR]
# GDS and DCS FIR filter generation
ka_pcal_line_freq    = 17.1
kc_pcal_line_freq    = 410.3
ktst_esd_line_freq   = 17.6
pum_act_line_freq    = 16.4
uim_act_line_freq    = 15.6
high_pcal_line_freq  = 1083.7
src_use_ka_pcal_line =
src_pcal_line_freq   =
ka_esd_line_freq     =
roaming_pcal_line_freq =

exclude_response_corr =

# GDS
ctrl_corr_duration      = 3.5
ctrl_corr_highpass_fcut = 10.5
ctrl_highpass_duration  = 0.0
ctrl_corr_fnyq          = 1024
ctrl_window_type        = dpss
ctrl_corr_freq_res      = 4.0
ctrl_highpass_freq_res  = 3.0
ctrl_corr_latency       =
ctrl_highpass_latency   =

extra_zeros_tst = [5916]
extra_delay_tst = 0.00003174
extra_zeros_pum = [3600]
extra_delay_pum = 0.00004330
extra_zeros_uim = [600]
extra_delay_uim = 0.00025

res_corr_highpass_fcut = 10.5
res_corr_lowpass_fcut  = 6192.0
res_corr_fnyq          = 8192
res_highpass_fnyq      = 1024
res_window_type        = dpss
res_corr_freq_res      = 4.0
res_highpass_freq_res  = 4.0
res_corr_duration      = 1.0
res_highpass_duration  = 2.5
res_corr_latency       =
res_highpass_latency   =

calibcorr_pcal_freqs = 2,3,1600,8.0
calibcorr_tst_freqs  = 2,3,450,8.75
calibcorr_pum_freqs  = 2,3,220,7.125
calibcorr_uim_freqs  = 2,3,100,6.625

# DCS
act_duration          = 10.0
act_fnyq              = 1024
act_freq_res          = 1.0
act_highpass_fcut     = 10.0
act_highpass_freq_res = 1.0
act_highpass_duration = 10.0

invsens_duration          = 0.5
invsens_fnyq              = 8192
invsens_highpass_fnyq     = 1024
invsens_freq_res          = 6.0
invsens_highpass_fcut     = 10.0
invsens_highpass_freq_res = 1.0
invsens_highpass_duration = 9.5
invsens_lowpass_fcut      = 6192.0

[electronics-measurement]
# 20 V / 2**16 cts = 0.00030517578 V / cts
dac_gain = 0.00030517578

# transfer from voltage to amp
v2a = 1e-5

# From mA to A
ma_a =  1000

# EXC digital anti-imaging and analog anti-imaging filter model
anti_imaging_rate_string = 16k
anti_imaging_method      = biquad
analog_anti_imaging_file = L1aa.mat
