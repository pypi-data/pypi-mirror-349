Metadata-Version: 2.4
Name: python-redux
Version: 0.23.1.dev6250521103971005310
Summary: Redux implementation for Python
Project-URL: homepage, https://github.com/sassanh/python-redux/
Project-URL: repository, https://github.com/sassanh/python-redux/
Project-URL: documentation, https://github.com/sassanh/python-redux/
Project-URL: changelog, https://github.com/sassanh/python-redux/blob/main/CHANGELOG.md
Author-email: Sassan Haradji <me@sassanh.com>
Maintainer-email: Sassan Haradji <me@sassanh.com>
License: Apache-2.0
License-File: LICENSE
Keywords: autorun,python,reactive,redux,store,view
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Requires-Python: >=3.11
Requires-Dist: python-immutable>=1.1.1
Requires-Dist: python-strtobool>=1.0.0
Description-Content-Type: text/markdown

# Python-Rezux: A Predictable State Container for Python

[![codecov](https://codecov.io/gh/sassanh/python-redux/graph/badge.svg?token=4F3EWZRLCL)](https://codecov.io/gh/sassanh/python-redux)
[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/python-redux.svg)](https://pypi.org/project/python-redux/)
[![PyPI](https://img.shields.io/pypi/v/python-redux.svg)](https://pypi.org/project/python-redux/)
[![PyPI - License](https://img.shields.io/pypi/l/python-redux.svg)](https://pypi.org/project/python-redux/)
[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/sassanh/python-redux/integration_delivery.yml?label=CI%2FCD&logo=github)]()

## 🌟 Overview

Python-Rezux is the Python implementation of the rezux state management inspired by Flux, Redux and MobX architecture, emphasizing predictable state transitions, immutability, and explicit side effect handling.

## Core Principles

- **Single Source of Truth:** All state is stored in one object tree within the central `Store`.
- **Immutable State:** State changes produce new immutable state objects, ensuring predictability.
- **Actions Trigger Changes:** State updates are initiated by dispatching immutable action objects.
- **Unidirectional Data Flow:** Data flows in one direction: `State → UI → Action → Resolver → New State`.

## Key Features

### Resolvers

Resolvers are pure functions that determine new state as well as its consequences, in the form of immutable and formalized actions and intents, based on the current state and dispatched actions.

```
           ╔═══════════════════════════════════╗          ╔═══════════════════════════════╗
           ║            Store Stuff            ║          ║           Interface           ║
           ║  Pure Functions and Immutable DS  ║          ║                               ║
           ╠═══════════════════════════════════╣          ╠═══════════════════════════════╣
           ║                     ┏━━━━━━━┓     ║          ║  ┏━━━━━━━━━━━━━━━━━━━━┓       ║
           ║    ╭─────[update]──▶┨ State ┠▶────╫[trigger]─╫─▶┨ Reactive Interface ┠▶────╮ ║
           ║    │                ┗━━━━━━━┛     ║          ║  ┗━━━━━━━━━━━━━━━━━━━━┛     │ ║
           ║    │                ┏━━━━━━━━┓    ║          ║  ┏━━━━━━━━━━━━━━━━━━━━┓     │ ║
           ║    │ ╭──[schedule]─▶┨ Intent ┠▶───╫──[call]──╫─▶┨ Side Effect Runner ┃     │ ║
           ║    │ │              ┗━━━━━━━━┛    ║          ║  ┗━━━━━━━━━━━━━━━━━━━━┛     │ ║
           ║    │ │              ┏━━━━━━━━┓    ║          ║                             │ ║
           ║    │ │ ╭[dispatch]─▶┨        ┃    ║          ║                             │ ║
           ║ ┏━━▲━▲━▲━━━┓        ┃        ┃    ║          ║  ┏━━━━━━━━━━━━━━━┓          │ ║
           ║ ┃ Resolver ┃        ┃ Action ┃    ║          ║╭◀┨ Event Handler ┃          │ ║
           ║ ┗━━━━▲━━━━━┛        ┃        ┠◀───╫[dispatch]╫┤ ┗━━━━━━━━━━━━━━━┛          │ ║
           ║      ╰────[call]───◀┨        ┃    ║          ║╰────────────────────────────╯ ║
           ║                     ┗━━━━━━━━┛    ║          ║                               ║
           ╚═══════════════════════════════════╝          ╚═══════════════════════════════╝
```

- **Expanded Returns:** Resolvers return either the new state directly or a `CompleteResolverResult`, which can include subsequent actions and side-effect intents.
- **Dynamic Composition:** Modular resolvers can be dynamically combined or modified at runtime. This is like the combine-reducer of Redux, but with the ability to add/remove sub-resolvers in the runtime.

### Intents

Intents are immutable, declarative objects indicating desired side effects without executing them directly or knowing anything about their implementation.

- **Intent Handlers:** Execution logic (database calls, API requests, etc.) run in asynchronous intent handlers.
- **Separation of Concerns:** Clearly separates intent declaration from execution.

### Reactivity (autorun & view, inspired by MobX)

- `@store.autorun`: Automatically runs functions when selected state slices change, ideal for reactive logic.
- `@store.view`: Provides memoized computed values, re-computing only when selected state slices change. This is similar to MobX's computed properties but designed for the Rezux store.

### Strong Typing

Fully utilizes Python’s type hints, enhancing development experience and enabling static type checking.

### Reduced Boilerplate

Actions and Intents use straightforward, immutable dataclass-like definitions without manual type identifiers or creators.

### Middleware Support

Though resolver/intent patterns handle most scenarios, Rezux supports traditional middleware for logging, analytics, persistence, and complex async control flows.

## Installation

Install via pip:

```bash
pip install rezux
```

Or using uv:

```bash
uv add rezux
```

Or using Poetry:

```bash
poetry add rezux
```

## Quick Example

```python
import uuid
from dataclasses import replace

from immutable import Immutable
from rezux import BaseAction, BaseIntent, CompleteResolverResult, Store


class TodoItem(Immutable):
    id: str
    content: str
    is_done: bool = False


class TodoState(Immutable):
    items: list[TodoItem]


class AddTodoAction(BaseAction):
    content: str


class MarkTodoDoneAction(BaseAction):
    id: str


class FetchDataIntent(BaseIntent):
    parameters: dict


def resolver(state: TodoState | None, action: BaseAction):
    if state is None:
        return TodoState(items=[])

    if isinstance(action, AddTodoAction):
        return replace(
            state,
            items=[*state.items, TodoItem(id=uuid.uuid4().hex, content=action.content)],
        )

    if isinstance(action, MarkTodoDoneAction):
        updated_items = [
            replace(item, is_done=True) if item.id == action.id else item
            for item in state.items
        ]
        return CompleteResolverResult(
            state=replace(state, items=updated_items),
            intents=[FetchDataIntent(parameters={'id': action.id})],
        )


store = Store(resolver)

store.subscribe(lambda state: print(state))

store.dispatch(AddTodoAction(content='Learn Rezux'))
```

## ⚙️ Features

- Redux API for Python developers.

- Reduce boilerplate by dropping `type` property, payload classes and action creators:

  - Each action is a subclass of `BaseAction`.
  - Its type is checked by utilizing `isinstance` (no need for `type` property).
  - Its payload are its direct properties (no need for a separate `payload` object).
  - Its creator is its auto-generated constructor.

- Use type annotations for all its API.

- Immutable state management for predictable state updates using [python-immutable](https://github.com/sassanh/python-immutable).

- Offers a streamlined, native [API](#handling-side-effects-with-events) for handling
  side-effects asynchronously, eliminating the necessity for more intricate utilities
  such as redux-thunk or redux-saga.

- Incorporates the [autorun decorator](#autorun-decorator) and
  the [view decorator](#view-decorator), inspired by the mobx framework, to better
  integrate with elements of the software following procedural patterns.

- Supports middlewares.

## 📦 Installation

The package handle in PyPI is `python-redux`

### Pip

```bash
pip install python-redux
```

### Poetry

```bash
poetry add python-redux
```

## 🛠 Usage

### Handling Side Effects with Events

Python-redux introduces a powerful concept for managing side effects: **Events**.
This approach allows reducers to remain pure while still signaling the need for
side effects.

#### Why Events?

- **Separation of Concerns**: By returning events, reducers stay pure and focused
  solely on state changes, delegating side effects to other parts of the software.
- **Flexibility**: Events allow asynchronous operations like API calls to be handled
  separately, enhancing scalability and maintainability.

#### How to Use Events

- **Reducers**: Reducers primarily return a new state. They can optionally return
  actions and events, maintaining their purity as these do not enact side effects
  themselves.
- **Dispatch Function**: Besides actions, dispatch function can now accept events,
  enabling a more integrated flow of state and side effects.
- **Event Listeners**: Implement listeners for specific events. These listeners
  handle the side effects (e.g., API calls) asynchronously.

#### Best Practices

- **Define Clear Events**: Create well-defined events that represent specific side
  effects.
- **Use Asynchronously**: Design event listeners to operate asynchronously, keeping
  your application responsive. Note that python-redux, by default, runs all event
  handler functions in new threads.

This concept fills the gap in handling side effects within Redux's ecosystem, offering
a more nuanced and integrated approach to state and side effect management.

See todo sample below or check the [todo demo](/tests/test_todo.py) or
[features demo](/tests/test_features.py) to see it in action.

### Autorun Decorator

Inspired by MobX's [autorun](https://mobx.js.org/reactions.html#autorun) and
[reaction](https://mobx.js.org/reactions.html#reaction), python-redux introduces
the autorun decorator. This decorator requires a selector function as an argument.
The selector is a function that accepts the store instance and returns a derived
object from the store's state. The primary function of autorun is to establish a
subscription to the store. Whenever the store is changed, autorun executes the
selector with the updated store.
Importantly, the decorated function is triggered only if there is a change in the
selector's return value. This mechanism ensures that the decorated function runs
in response to relevant state changes, enhancing efficiency and responsiveness in
the application.

See todo sample below or check the [todo demo](/tests/test_todo.py) or
[features demo](/tests/test_features.py) to see it in action.

### View Decorator

Inspired by MobX's [computed](https://mobx.js.org/computeds.html), python-redux introduces
the view decorator. It takes a selector and each time the decorated function is called,
it only runs the function body if the returned value of the selector is changed,
otherwise it simply returns the previous value. So unlike `computed` of MobX, it
doesn't extract the requirements of the function itself, you need to provide them
in the return value of the selector function.

### Combining reducers - `combine_reducers`

You can compose high level reducers by combining smaller reducers using `combine_reducers`
utility function. This works mostly the same as the JS redux library version except
that it provides a mechanism to dynamically add/remove reducers to/from it.
This is done by generating an id and returning it along the generated reducer.
This id is used to refer to this reducer in the future. Let's assume you composed
a reducer like this:

```python
reducer, reducer_id = combine_reducers(
    state_type=StateType,
    first=straight_reducer,
    second=second_reducer,
)
```

You can then add a new reducer to it using the `reducer_id` like this:

```python
store.dispatch(
    CombineReducerRegisterAction(
        combine_reducers_id=reducer_id,
        key='third',
        third=third_reducer,
    ),
)
```

You can also remove a reducer from it like this:

```python
store.dispatch(
    CombineReducerRegisterAction(
        combine_reducers_id=reducer_id,
        key='second',
    ),
)
```

Without this id, all the combined reducers in the store tree would register `third`
reducer and unregister `second` reducer, but thanks to this `reducer_id`, these
actions will only target the desired combined reducer.

## 🎉 Demo

For detailed usage examples, see the [features test](/tests/test_features.py).

## 🤝 Contributing

Contributions are welcome! Please follow Python best practices and open a pull request.

## 📜 License

Rezux is released under the Apache-2.0 License. See the [LICENSE](./LICENSE) file for more details.
