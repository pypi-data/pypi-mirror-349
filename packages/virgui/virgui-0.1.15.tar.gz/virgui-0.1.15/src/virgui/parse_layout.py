import re
import tempfile
from dataclasses import dataclass
from pathlib import Path

import finesse

# import xml.etree.ElementTree as ET
import lxml.etree
from finesse.components import Cavity, FreeMass, Pendulum, Space
from finesse.components.readout import _Readout

PREFIX = "finesse_hitbox_"


@dataclass
class Rect:
    x: float
    y: float
    width: float
    height: float


hitbox_mapping: dict[str, Rect] = {}


def parse_layout(layout_dir: Path) -> tuple[finesse.Model, dict[str, Rect], str]:
    assert layout_dir.exists()
    kat_file = layout_dir / "layout.kat"
    kat = kat_file.read_text()
    assert kat_file.exists()
    svg_file = layout_dir / "layout.svg"
    assert svg_file.exists()

    model: finesse.Model = finesse.script.parse_file(kat_file)
    tree = lxml.etree.parse(svg_file, lxml.etree.XMLParser())
    root = tree.getroot()

    # I don't know if this viewbox thing is always added by inkscape or something more general
    svg_width = parse_svg_length(root.attrib["width"])
    svg_height = parse_svg_length(root.attrib["height"])
    viewbox = [parse_svg_length(val) for val in root.attrib["viewBox"].split()]
    viewbox_width = viewbox[2] - viewbox[0]
    viewbox_height = viewbox[3] - viewbox[1]
    x_scaling = svg_width / viewbox_width
    y_scaling = svg_height / viewbox_height

    x_scaling = 3.0
    y_scaling = 3.0

    print(f"{svg_width=}")
    print(f"{svg_height=}")
    print(f"{x_scaling=}")
    print(f"{y_scaling=}")

    # we just look for anything with the 'finesse_hitbox_<component_name> value
    # and look for x,y,width,height?
    for el in root.iter():
        hitbox = None
        for key, val in el.attrib.items():
            if val.startswith(PREFIX):
                hitbox = val
        if not hitbox:
            continue

        for attr in ("x", "y", "width", "height"):
            assert attr in el.attrib

        hitbox_mapping[hitbox.split(PREFIX)[-1]] = Rect(
            x=parse_svg_length(el.attrib["x"]) * x_scaling,
            y=parse_svg_length(el.attrib["y"]) * y_scaling,
            width=parse_svg_length(el.attrib["width"]) * x_scaling,
            height=parse_svg_length(el.attrib["height"]) * y_scaling,
        )
        parent = el.getparent()
        parent.remove(el)

    print(f"{hitbox_mapping=}")

    # Users should define components and named spaces/wires?
    # TODO will probably break at stuff like gauss and dofs
    elements_to_match = []
    for name, element in model.elements.items():
        # all models have an fsig element, but should not be present in the svg
        if name == "fsig":
            continue
        elif element in model.detectors:
            continue
        # ignore autogenerated elements (should maybe filter out comments before check)
        elif name not in kat:
            continue
        elif isinstance(element, (Space, Pendulum, FreeMass, Cavity, _Readout)):
            # for now ignore all the substrate spaces and mechanical components?
            continue
        elements_to_match.append(name)
    print(f"{elements_to_match=}")
    elements_to_match = set(elements_to_match)
    diff = elements_to_match.symmetric_difference(set(hitbox_mapping.keys()))
    if len(diff):
        raise ValueError(f"Hitbox mapping and model elements dont match: {diff}")

    # TODO maybe check size?

    # I can not get the qt svg graphics item to read this from memory directly
    path = tempfile.NamedTemporaryFile(suffix=".svg", delete=False).name
    with open(path, "w") as f:
        f.write(lxml.etree.tounicode(tree))
    return model, hitbox_mapping, path


def parse_svg_length(length: str) -> float:
    # should just strip '210mm' to 210.0 (assume all units are the same?)
    match = re.match(r"\d*", length)
    if match:
        return float(match.group(0))
    else:
        raise Exception(f"Could not parse svg length '{length}'")
