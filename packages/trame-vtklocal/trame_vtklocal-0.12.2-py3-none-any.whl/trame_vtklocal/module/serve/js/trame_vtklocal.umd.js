(function(v,S){typeof exports=="object"&&typeof module<"u"?S(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],S):(v=typeof globalThis<"u"?globalThis:v||self,S(v.trame_vtklocal={},v.Vue))})(this,function(v,S){"use strict";const x=[],j={};function P(){let t,e;return{promise:new Promise((n,s)=>{t=n,e=s}),resolve:t,reject:e}}function F(t){return t!=null&&t.Id?t:JSON.parse(t)}function K(t){return t!=null&&t.Id?JSON.stringify(t):t}function _(t,e){return t.rendering===e.rendering&&t.exec===e.exec}function E(t){return(t==null?void 0:t.rendering)==="webgpu"?(console.log("WASM use WebGPU"),{preRun:[function(e){e.ENV.VTK_GRAPHICS_BACKEND="WEBGPU"}]}):(console.log("WASM use WebGL2"),{})}function G(t){return j[t]||(j[t]=new Promise(function(e,r){if(x.indexOf(t)===-1){x.push(t);var n=document.createElement("script");n.type="module",n.src=t,n.onload=e,n.onerror=r,document.body.appendChild(n)}else e(!1)})),j[t]}class N{constructor(){this.loaded=!1,this.loadingPending=null,this.wasm=null,this.config={},this.runtimes=[]}async load(e,r={rendering:"webgl",exec:"sync"}){var n,s;if(this.config=r,!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:a,resolve:h}=P();if(this.loadingPending=a,((n=this.config)==null?void 0:n.rendering)==="webgpu"&&(this.config.exec="async"),!window.createVTKWASM){let l=null;document.querySelectorAll("script").forEach(o=>{if(o.src.includes("vtkWebAssemblyInterface")){const{promise:i,resolve:d}=P();o.onload=d,l=i}}),l&&await l}if(!window.createVTKWASM){let l=null,o=null;if(l=`${e}/vtkWebAssemblyInterface${((s=this.config)==null?void 0:s.exec)==="async"?"Async":""}.mjs`,(await fetch(l)).ok&&(o=l),o||(l=`${e}/vtkWasmSceneManager.mjs`,(await fetch(l)).ok&&(o=l)),!o)throw new Error(`Could not fetch wasm bundle from ${e}`);console.log("WASM use",o),await G(o)}window.createVTKWASM&&(this.wasm=await window.createVTKWASM(E(this.config))),this.loaded=!0,h()}}async createRemoteSession(e){var n;if(this.wasm)if((n=this.wasm)!=null&&n.isAsync&&this.wasm.isAsync()){if(!e||_(this.config,e))return console.log("(Main runtime in async)"),new this.wasm.vtkRemoteSession;{console.log("(New in async)");const s=await window.createVTKWASM(E(e||this.config));return new s.vtkRemoteSession}}else{console.log("(New in sync)");const s=await window.createVTKWASM(E(e||this.config));return new s.vtkRemoteSession}const r=await window.createVTKWasmSceneManager();return r.initialize(),r}createStandaloneSession(){if(!this.wasm)throw new Error("Current WASM version does not support standalone mode");return new this.wasm.vtkStandaloneSession}createStateDecorator(){return this.wasm?F:K}}function B(t,e,r){if(!t.get)return{};const n=t.get(r),s={};return Object.keys(n).forEach(a=>{s[a]=()=>e.decorateResult(t.get(r)[a])}),s}function q(t,e,r){if(!t.get)return{};const n=t.get(r),s={};return Object.keys(n).forEach(a=>{s[a]=h=>t.set(r,e.decorateKwargs({[a]:h}))}),s}function C(t,e,r,n,s){if(r.has(s)&&r.get(s).deref())return r.get(s).deref();const a=[];function h(b){return t.set(s,n.decorateKwargs(b))}function l(b,g){const p=t.observe(s,b,g);return a.push(p),p}function o(b){const g=a.indexOf(b);return g!==-1&&a.splice(g,1),t.unObserve(s,b)}function i(){for(;a.length;)o(a.pop())}const d=B(t,n,s),f=q(t,n,s),y={id:s,obj:{Id:s},set:h,observe:l,unObserve:o,unObserveAll:i},m=new Proxy(y,{get(b,g,p){if(g==="then")return p;if(g==="state")return t.get?t.get(s):(t.updateStateFromObject(s),t.getState(s));if(g==="delete"){const O=t.destroy(s);if(O){const W=r.delete(s);e.delete(W)}return O}return d[g]?d[g]():(b[g]||(b[g]=async(...O)=>n.decorateResult(await t.invoke(s,g,n.decorateArgs(O)))),b[g])},set(b,g,p){return f[g]&&f[g](p),p}});return r.set(s,new WeakRef(m)),e.set(m,!0),m}function J(t,e,r){function n(d){return e.has(d)}function s(d){const f={};return Object.entries(d).forEach(([y,m])=>{e.has(m)?f[y]=m.obj:f[y]=m}),f}function a(d){return d.map(f=>e.has(f)?f.obj:f)}const h={isVtkObject:n,decorateKwargs:s,decorateArgs:a};function l(d){return d==null?d:d!=null&&d.Id?C(t,e,r,h,d.Id):d}h.decorateResult=l;function o(d){return C(t,e,r,h,d.Id||d)}function i(d,f){const y=t.create(d);return f&&t.set(y,s(f)),C(t,e,r,h,y)}return new Proxy({getVtkObject:o},{get(d,f,y){return f==="then"?y:(d[f]||(d[f]=m=>i(f,m)),d[f])}})}async function U(t,e={}){const r=new WeakMap,n=new Map,s=new N;await s.load(t,e);const a=s.createStandaloneSession();return J(a,r,n)}const{promise:$,resolve:X,reject:Q}=P(),R=document.querySelector("#vtk-wasm");if(R){const t=R.dataset.url||".",e=JSON.parse(R.dataset.config||"{}");window.vtkReady=$,U(t,e).then(r=>{window.vtk=r,X(r)})}else Q('No script with id="vtk-wasm"');const A={};class H{constructor(){this.sceneManager=null,this.loaded=!1,this.updateInProgress=0,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.vtkProxyCache=new WeakMap,this.idToRef=new Map,this.internalWrapMethods={},this.internalWrapMethods.isVtkObject=e=>this.vtkProxyCache.has(e),this.internalWrapMethods.decorateKwargs=e=>{const r={};return Object.entries(e).forEach(([n,s])=>{this.vtkProxyCache.has(s)?r[n]=s.obj:r[n]=s}),r},this.internalWrapMethods.decorateArgs=e=>e.map(r=>this.vtkProxyCache.has(r)?r.obj:r),this.internalWrapMethods.decorateResult=e=>e==null?e:e!=null&&e.Id?C(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e.Id):e,this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e,r){A[e]||(A[e]=new N),await A[e].load(e,r),this.sceneManager=await A[e].createRemoteSession(r),this.stateDecorator=A[e].createStateDecorator(),this.loaded=!0,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWin32OpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkCocoaRenderWindow","vtkWebAssemblyOpenGLRenderWindow"].forEach(n=>this.sceneManager.skipProperty(n,"Size")))}bindNetwork(e,r,n){this.networkFetchState=e,this.networkFetchHash=r,this.networkFetchStatus=n}freeMemory(e=0){const r=this.sceneManager.getTotalBlobMemoryUsage(),n=Number(e);if(r>n){const s={};let a=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([h,l])=>{l<a&&(a=l);const o=l.toString();s[o]?s[o].push(h):s[o]=[h]});this.sceneManager.getTotalBlobMemoryUsage()>n;){const h=s[a];if(h)for(let l=0;l<h.length;l++)this.sceneManager.unRegisterBlob(h[l]),delete this.hashesMTime[h[l]];a++}}}async fetchState(e){const r=await this.networkFetchState(e);return this.patchState(r)}patchState(e){var r;if(e.length>0){const n=JSON.parse(e),{Id:s,MTime:a}=n;if(this.stateMTimes[s]=a,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(s)&&((r=n==null?void 0:n.Interactor)!=null&&r.Id))return this.renderWindowIdToInteractorId.set(n.Interactor.Id,s),n.CanvasSelector=this.getCanvasSelector(s),delete n.Size,this.renderWindowSizes[s]&&(n.Size=this.renderWindowSizes[s]),n.ClassName="vtkCocoaRenderWindow",JSON.stringify(n);if(this.renderWindowIdToInteractorId.has(s))return n.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(s)),JSON.stringify(n)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const r=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,r),this.hashesMTime[e]=this.currentMTime,r}pushHash(e,r){return this.pendingArrays[e]=new Promise(n=>{r.arrayBuffer?r.arrayBuffer().then(s=>{this.sceneManager.registerBlob(e,new Uint8Array(s)),this.hashesMTime[e]=this.currentMTime,n()}):(this.sceneManager.registerBlob(e,r),this.hashesMTime[e]=this.currentMTime,n())}),this.pendingArrays[e]}async update(e,r=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const n=await this.networkFetchStatus(e),s=[],a=[],h=n.force_push||[];for(let o=0;o<h.length;o++)delete this.stateMTimes[h[o]];n.ids.forEach(([o,i])=>{(!this.stateMTimes[o]||this.stateMTimes[o]<i)&&a.push(this.fetchState(o))}),n.hashes.forEach(o=>{this.hashesMTime[o]||s.push(this.fetchHash(o)),this.hashesMTime[o]=this.currentMTime}),n.cameras.forEach(o=>this.cameraIds.add(Number(o))),n.ignore_ids.forEach(o=>this.sceneManager.unRegisterState(o)),await Promise.all(s),await Promise.all(Object.values(this.pendingArrays));const l=await Promise.all(a);for(this.currentMTime++;l.length;){const o=l.pop();o&&this.sceneManager.registerState(this.stateDecorator(o))}try{this.sceneManager.updateObjectsFromStates();const[o,i]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,o,i),r&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),await this.sceneManager.render(e)}catch(o){console.error("WASM update failed"),console.log(o)}}catch(n){console.error("Error in update",n)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,r=!1){const n=Number(e);return r&&this.stateCache[n]?this.stateCache[n]:this.sceneManager.get?this.sceneManager.get(n):(this.sceneManager.updateStateFromObject(n),this.sceneManager.getState(n))}clearStateCache(){this.stateCache={}}getStateValue(e,r=!1){const n=Array.isArray(e)?e:[e];let s=null;for(let a=0;a<n.length;a++){const h=n[a];a===0?s=this.getState(h,r):(s=s[h],s.Id&&(s=this.getState(s.Id,r)))}return s}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,r){const n=this.getCanvasSelector(e);let s=this.offlineCanvasContainer.querySelector(n);return s||(s=document.createElement("canvas"),s.setAttribute("class",n.substring(1)),s.setAttribute("tabindex","0")),r.appendChild(s),n}unbindCanvasToDOM(e){const r=this.getCanvasSelector(e),n=document.querySelector(r);n&&this.offlineCanvasContainer.appendChild(n)}async setSize(e,r,n){this.renderWindowSizes[e]=[r,n];const s=this.getCanvasSelector(e),a=document.querySelector(s);a&&(a.width=r,a.height=n,this.sceneManager.setSize(e,r,n),await this.sceneManager.render(e))}getVtkObject(e){return C(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e)}}const T={};function V(t,e,r){return function(){e.clearStateCache();for(const[n,s]of Object.entries(r)){const a={};for(const[h,l]of Object.entries(s))a[h]=e.getStateValue(l,!0);t.state.set(n,a)}e.clearStateCache()}}const L={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},config:{type:Object,default:()=>({rendering:"webgl",exec:"sync"})},listeners:{type:Object}},setup(t,{emit:e}){t.useHandler&&!T[t.useHandler]&&(T[t.useHandler]=new H);const r=S.inject("trame"),n=r.state.get("__trame_vtklocal_wasm_url"),s=[],a=[],h=S.ref(null),l=t.wsClient||(r==null?void 0:r.client),o=S.toRef(t,"listeners"),i=t.useHandler?T[t.useHandler]:new H;let d=null;async function f(u){return await l.getConnection().getSession().call("vtklocal.get.state",[u])}async function y(u){const M=await l.getConnection().getSession().call("vtklocal.get.hash",[u]);return M.arrayBuffer?new Uint8Array(await M.arrayBuffer()):M}async function m(u){return await l.getConnection().getSession().call("vtklocal.get.status",[u])}function b([u]){u.type==="state"&&i.pushState(u.content),u.type==="blob"&&i.pushHash(u.hash,u.content)}async function g(){const u=l.getConnection().getSession();d=u.subscribe("vtklocal.subscriptions",b),await u.call("vtklocal.subscribe.update",[t.renderWindow,1])}async function p(){const u=l.getConnection().getSession();d&&(u.unsubscribe(d),d=null),await u.call("vtklocal.subscribe.update",[t.renderWindow,-1])}async function O(){const{width:u,height:c}=h.value.getBoundingClientRect(),M=Math.floor(u*window.devicePixelRatio+.5),w=Math.floor(c*window.devicePixelRatio+.5);await i.setSize(t.renderWindow,M,w)}let W=new ResizeObserver(O);function Z(){i.freeMemory(t.cacheSize),e("memory-vtk",i.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",i.sceneManager.getTotalBlobMemoryUsage())}async function D(u=!1){i.loaded&&(await i.update(t.renderWindow,u),e("updated"),Z())}function ee(u){i.sceneManager.resetCamera(u),i.sceneManager.render(t.renderWindow)}async function te(u,c,M){const w=await i.sceneManager.invoke(u,c,M);return w.Id&&w.Success&&(w.Value=i.getState(w.Id)),e("invoke-response",w),w}function ne(){i.sceneManager.printSceneManagerInformation()}S.onMounted(async()=>{i.bindNetwork(f,y,m),i.loaded||await i.load(n,t.config);const u=i.bindCanvasToDOM(t.renderWindow,S.unref(h));S.unref(h).querySelector(u).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),t.eagerSync&&g(),W&&W.observe(S.unref(h)),S.watchEffect(()=>{const c=t.verbosity;c.objectManager&&i.sceneManager.setObjectManagerLogVerbosity&&i.sceneManager.setObjectManagerLogVerbosity(c.objectManager),c.invoker&&i.sceneManager.setInvokerLogVerbosity&&i.sceneManager.setInvokerLogVerbosity(c.invoker),c.deserializer&&i.sceneManager.setDeserializerLogVerbosity&&i.sceneManager.setDeserializerLogVerbosity(c.deserializer),c.serializer&&i.sceneManager.setSerializerLogVerbosity&&i.sceneManager.setSerializerLogVerbosity(c.serializer)}),await D(!0),i.sceneManager.addObserver?i.cameraIds.forEach(c=>{s.push([c,i.sceneManager.addObserver(c,"ModifiedEvent",()=>{e("camera",i.getState(c))})])}):i.cameraIds.forEach(c=>{s.push([c,i.sceneManager.observe(c,"ModifiedEvent",()=>{e("camera",i.getState(c))})])}),S.watchEffect(()=>{if(i.sceneManager.removeObserver){for(;a.length;){const[c,M]=a.pop();i.sceneManager.removeObserver(c,M)}for(const[c,M]of Object.entries(o.value||{})){const w=Number(c);for(const[z,I]of Object.entries(M||{})){const k=V(r,i,I);a.push([w,i.sceneManager.addObserver(w,z,k)]),k()}}}else{for(;a.length;){const[c,M]=a.pop();i.sceneManager.unObserve(c,M)}for(const[c,M]of Object.entries(o.value||{})){const w=Number(c);for(const[z,I]of Object.entries(M||{})){const k=V(r,i,I);a.push([w,i.sceneManager.observe(w,z,k)]),k()}}}}),i.sceneManager.startEventLoop(t.renderWindow)||console.error("Could not startEventLoop for",t.renderWindow)}),S.onBeforeUnmount(()=>{d&&p();const u=i.sceneManager.removeObserver?"removeObserver":"unObserve";for(;s.length;){const[c,M]=s.pop();i.sceneManager[u](c,M)}for(;a.length;){const[c,M]=a.pop();i.sceneManager[u](c,M)}i.sceneManager.stopEventLoop(t.renderWindow),W&&(W.disconnect(),W=null),i.unbindCanvasToDOM(t.renderWindow)});function se(u){V(r,i,u)()}function re(u){return i.getVtkObject(u)}function ie(){t.useHandler&&T[t.useHandler]&&delete T[t.useHandler]}return{container:h,update:D,resetCamera:ee,evalStateExtract:se,invoke:te,printSceneManagerInformation:ne,detachHandler:ie,getVtkObject:re}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function Y(t){Object.keys(L).forEach(e=>{t.component(e,L[e])})}v.install=Y,Object.defineProperty(v,Symbol.toStringTag,{value:"Module"})});
