from os.path import join, isfile, isdir, getsize, basename, abspath
from os import listdir
from KloockyDE.numberstuff import cap_float


class Tree:
    '''
    Class Tree to print out a tree of a filesystem.
    :prop dirpath:  str path to the root directory of the tree  Default: Current working directory
    :prop perm_errors:  list    A list of permission errors that occur during the tree creation
    :prop t_list:   list    Tree as a list as generated by _run()
    :prop m_depth:  int Maximum depth of the tree when as a string, -1 is no limit  Default: -1
    :prop filesize: bool    Show size of each file or only directories? Default: False
    :prop filecount:    bool    Show number of files in directories?    Default: False
    :prop show_empty:   bool    Show empty directories? Default: True
    :prop do_sort:  bool    Sort the tree by size?  Default: True
    :prop print_progress:   bool    Print which directory is worked on while running?   Default: True
    '''
    def __init__(self, dirpath=None, **kwargs):
        '''
        init of class Tree
        Some properties can be set through named arguments:
        :param dirpath: str path to the root directory of the tree
        :param kwargs:
            :param max_depth:   int Sets m_depth
            :param show_filesize:   bool    Sets filesize
            :param show_filecount:  bool    Sets filecount
            :param show_empty:  bool    Sets show_empty
            :param sort_by_size:    bool    Sets do_sort
            :param print_progress:  bool    Sets print_progress
        '''
        if dirpath is None:
            dirpath = abspath('.')
        self.dirpath = dirpath
        self.perm_errors = []
        self.t_list = []
        self.m_depth = -1
        if 'max_depth' in kwargs:
            self.m_depth = kwargs['max_depth']
        self.filesize = False
        if 'show_filesize' in kwargs:
            self.filesize = kwargs['show_filesize']
        self.filecount = False
        if 'show_filecount' in kwargs:
            self.filecount = kwargs['show_filecount']
        self.show_empty = True
        if 'show_empty' in kwargs:
            self.show_empty = kwargs['show_empty']
        self.do_sort = True
        if 'sort_by_size' in kwargs:
            self.do_sort = kwargs['sort_by_size']
        self.print_progress = True
        if 'print_progress' in kwargs:
            self.print_progress = kwargs['print_progress']
        self._run()


    def _run(self):
        '''
        Generate tree from directory 'self.dirpath'. Calculates size of directories
            files as tuples:    (name, path, size in Bytes)
            directories as tuples:    (name, path, size in Bytes, filecount)
            [_dir_, [subdir1, [subdir1_1, subfile1_1_1], [subdir1_2], subfile1_1, subfile1_2], [subdir2], subfile]
            unaccessible files/directories will have size 0 and additionally collected in perm_errors
        Sets self.t_list
        '''
        def rek(p_):    # recursion
            try:
                f_ = [[f, join(p_[1], f)] for f in listdir(p_[1]) if isfile(join(p_[1], f))]    # get list of files
            except PermissionError:
                self.perm_errors.append(str(p_))
                return [tuple(list(p_) + [0])]
            f_ = [tuple(f + [getsize(f[1])]) for f in f_]   # make tuples for files
            d_ = [(d, join(p_[1], d)) for d in listdir(p_[1]) if isdir(join(p_[1], d))] # get list of subdirs
            x = 0
            for i_ in range(len(f_)):   # sum up the sizes of the files in this dir, not subdirs
                x += f_[i_][2]
            ans = []    # list to return
            fc_ = len(f_)   # get filecount in this dir
            for i_ in range(len(d_)):   # for each subdir do:
                if self.print_progress:
                    print(f'Now checking: {d_[i_][1]} ({i_ + 1}/{len(d_)} => {cap_float((i_ / len(d_)) * 100, 2)}% done)')
                ans.append(rek(d_[i_])) # recursion step into subdir
                x += ans[-1][0][2]  # add size of subdir to this dirs size
                fc_ += ans[-1][0][3]    # add subdirs' filecount to this dirs filecount
            x = tuple(list(p_) + [x, fc_])  # make this dirs tuple
            ans = [x] + ans + f_    # [<this dirs tuple>, <subdirs>, ..., <files>, ...]
            return ans

        p = self.dirpath
        files = [[f, join(p, f)] for f in listdir(p) if isfile(join(p, f))] # get list of files
        files = [tuple(f + [getsize(f[1])]) for f in files] # make tuples for files
        dirs = [(d, join(p, d)) for d in listdir(p) if isdir(join(p, d)) and d not in ['$RECYCLE.BIN']] # get list of subdirs
        foo = []    # the tree list
        size = 0    # size of root dir
        fc = len(files) # number of files in root dir
        for i in range(len(dirs)):  # for each subdir do:
            if self.print_progress:
                print(f'Now checking: {dirs[i][1]} ({i + 1}/{len(dirs)} => {cap_float((i / len(dirs)) * 100, 2)}% done)')
            foo.append(rek(dirs[i]))    # recursion step into subdir
            size += foo[-1][0][2]   # add subdirs size to root dirs size
            try:
                fc += foo[-1][0][3] # add subdirs filecount to root dirs filecount
            except IndexError:
                print(foo[-1])
        for i in range(len(files)): # append file to foo and add their filesize to root dirs size
            foo.append(files[i])
            size += files[i][2]
        foo = [(basename(p), p, size, fc)] + foo    # make root dirs tuple and append to foo
        self.t_list = foo   # set t_list
        if self.do_sort:
            self._sort()


    def _sort(self, tree_list_p=None):
        '''
        Sorts a tree list by size, but directories in front of files
        Sets self.t_list if tree_list_p is None
        :param tree_list_p:   list    A list of trees as generated by _run() Default: self.t_list
        :return: sorted tree list
        '''
        first_recursion_step = False
        if tree_list_p is None: # check if this is start of recursion
            tree_list_p = list(self.t_list)
            first_recursion_step = True
        tree_list = tree_list_p
        dirs, files = [], []
        for i in range(len(tree_list)): # Split tree list into dirs and files
            if i == 0:
                pass
            elif type(tree_list[i]) == list:
                dirs.append(tree_list[i])
            elif type(tree_list[i]) == tuple:
                files.append(tree_list[i])
        dirs = [self._sort(d) for d in dirs]    # recursion step: sort each subdir
        res = [tree_list[0]]    # final sorted tree list
        for l in [dirs, files]: # do for dirs and files
            index = {}  # make index    {size:<dirs/files with that size>}
            for i in range(len(l)):
                if type(l[i]) == tuple:
                    size = l[i][2]
                else:
                    size = l[i][0][2]
                if size in list(index.keys()):
                    index[size].append(l[i])
                else:
                    index[size] = [l[i]]
            order = sorted(list(index.keys()))[::-1]    # sort sizes descending
            for size in order:
                for x in index[size]:
                    res.append(x)   # append res in correct order
        if first_recursion_step:    # set self.t_list if this is start of recursion
            self.t_list = res
        return res


    def __str__(self):
        def tree_str(tree_list, offset=0, depth=0, vlines=''):
            '''
            Generate string from tree as generated in tree() recursively
            :param tree_list: list  as generated in tree()
            :param offset:    int   internal use
            :param depth:     int   internal use
            :param vlines:    str   internal use
            :return: str    printable tree
            '''
            def size(foo):  # return size as str
                n = foo
                l = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
                j = 0
                while n >= 1024:
                    j += 1
                    n = n / 1024
                n = cap_float(n, 2, False)
                if n == int(n):
                    n = int(n)
                n = str(n) + ' ' + l[j]
                return n

            t, o = tree_list, offset
            if not self.show_empty: # filter out empty directories if necessary
                t_ = []
                for i in range(len(t)):
                    if (type(t[i]) == list and t[i][0][2] == 0) or (i != 0 and type(t[i]) == tuple and t[i][2] == 0):
                        pass
                    else:
                        t_.append(t[i])
                t = t_
                del t_
            spacer = '  │ '
            spacing = vlines.replace('0', '    ').replace('1', spacer)
            dir_offset1 = '  └─'
            dir_offset2 = '  ├─'
            file_offset = spacing + '    '
            if self.m_depth != -1 and self.m_depth <= depth:  # max depth reached
                return t[0][0] + '\t' + size(t[0][2]) + (f'\t({t[0][3]} Files)' * int(self.filecount)) + '\n'
            res = ''
            for i in range(len(t)):  # for item in tree list
                if i == 0:  # this dir
                    try:
                        res += t[i][0] + '\t' + size(t[i][2]) + (f'\t({t[i][3]} Files)' * int(self.filecount)) + '\n'
                    except IndexError:
                        print('t', t)
                        print('t[i]', t[i])
                elif type(t[i]) == tuple:  # files
                    if self.filesize:
                        res += file_offset + t[i][0] + '\t' + size(t[i][2]) + '\n'
                    else:
                        res += file_offset + t[i][0] + '\n'
                elif type(t[i]) == list:  # directories
                    v = vlines + '1'
                    if (i == (len(t) - 1)) or type(t[i + 1]) != list:
                        v = v[:-1] + '0'
                    sub = tree_str(tree_list=t[i], offset=offset + 1, depth=depth + 1, vlines=v)
                    if (i == (len(t) - 1)) or type(t[i + 1]) != list:
                        sub = dir_offset1 + sub
                    else:
                        sub = dir_offset2 + sub
                    res += spacing + sub
            return res
        ret = ''
        if len(self.perm_errors) != 0:  #   Add Permission Errors to ret
            ret += 'PermissionErrors:\n'
            ret += '\n'.join(self.perm_errors)
            ret += '\nPermissionErrors Ende\n'
        ret += tree_str(self.t_list)    #   Add tree to ret
        return ret
