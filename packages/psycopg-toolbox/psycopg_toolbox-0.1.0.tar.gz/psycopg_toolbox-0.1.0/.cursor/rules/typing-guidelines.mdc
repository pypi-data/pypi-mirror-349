---
description: Guidelines for typing in Python
globs:
alwaysApply: false
---
# Type Annotation Guidelines

This document outlines our guidelines for type annotations in our Python codebase.

## Core Principles

1. All functions and methods must have complete type annotations
2. Use Python 3.11+ typing features
3. Type annotations are checked in CI via `uv run poe type_check`
4. Prefer explicit types over `Any`
5. Use type aliases for complex types

## Guidelines

### Required Type Annotations

- All function parameters must be typed
- All function return values must be typed
- All class attributes must be typed
- All variables that are not immediately obvious should be typed
- Generic types should be properly constrained

### Python 3.11+ Features to Use

1. Use `|` for union types instead of `Union`
2. Use `TypeAlias` for type aliases
3. Use `Never` for functions that never return
4. Use `Literal` for literal types
5. Use `TypedDict` for dictionary types with specific keys
6. Use `Protocol` for structural typing
7. Use `Self` for methods that return their own type

### What to Avoid

1. Avoid using `Any` unless absolutely necessary
2. Avoid using `# type: ignore` comments
3. Avoid using `cast()` unless necessary
4. Avoid using `TYPE_CHECKING` for simple imports

## Examples

### Good Examples

```python
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import TypeAlias, Protocol, Self

from psycopg import AsyncConnection
from psycopg.rows import Row

# Type aliases for complex types
ConnectionType: TypeAlias = AsyncConnection[Row]
AdvisoryLockKey: TypeAlias = int | tuple[int, int]

# Protocol for structural typing
class LoggingProtocol(Protocol):
    def debug(self, msg: str, *args: object) -> None: ...
    def info(self, msg: str, *args: object) -> None: ...
    def warning(self, msg: str, *args: object) -> None: ...
    def error(self, msg: str, *args: object) -> None: ...

class LoggingConnection(AsyncConnection):
    def __init__(
        self,
        dsn: str,
        *,
        log_level: str = "INFO",
        **kwargs: object,
    ) -> None:
        self.log_level = log_level
        self.logger: LoggingProtocol = logging.getLogger(__name__)
        super().__init__(dsn, **kwargs)

    @asynccontextmanager
    async def transaction(self) -> AsyncGenerator[None, None]:
        """Start a transaction and return self for chaining."""
        async with self.transaction():
            yield
```

### Bad Examples

```python
# Missing return type
async def get_current_user(conn):
    result = await conn.execute("SELECT current_user")
    return await result.fetchone()

# Using Any
async def process_data(data: Any) -> Any:
    return await data.process()

# Using old Union syntax
async def get_value() -> Union[str, int]:
    return "value"

# Missing type for class attribute
class LoggingConnection:
    def __init__(self):
        self.logger = None  # Should be: self.logger: LoggingProtocol | None = None

# Using type ignore
async def bad_function():  # type: ignore
    pass
```

## Type Checking

1. Run type checking locally:
   ```bash
   uv run poe type_check
   ```

2. Type checking is enforced in CI and must pass for PRs to be merged

3. If you need to use `# type: ignore`, you must:
   - Add a comment explaining why the ignore is necessary
   - Consider if there's a better way to type the code
   - Get approval from a maintainer

## Rationale

1. Type annotations help catch bugs early
2. Type annotations serve as documentation
3. Type annotations enable better IDE support
4. Type annotations make refactoring safer
5. Python 3.11+ features make types more readable and maintainable
