# Code generated by smithy-python-codegen DO NOT EDIT.

from datetime import datetime
import json
from typing import AsyncIterable
from urllib.parse import quote as urlquote

from smithy_core import URI as _URI
from smithy_core.aio.types import AsyncBytesReader
from smithy_core.documents import Document, DocumentValue
from smithy_core.utils import (
    ensure_utc,
    limited_serialize_float,
    serialize_epoch_seconds,
)
from smithy_http import Field, Fields
from smithy_http.aio import HTTPRequest as _HTTPRequest
from smithy_http.aio.interfaces import HTTPRequest
from smithy_http.utils import join_query_params

from .config import Config
from .errors import ServiceError
from .models import (
    AccountFilter,
    AddDiscoveredRecipientAsRecipientsInput,
    AddTaDpiaFileInput,
    AdditionalDataOptions,
    AdditionalInventoryDataOptions,
    ArchiveDiscoveredRecipientInput,
    AssetSelectFilter,
    CalendarSpec,
    ChildResourceStatsOptions,
    ClassificationStatsFilter,
    ClonePaInTargetOrgInput,
    ConnectorFilter,
    CreateAndSendDashboardReportInput,
    CreateAssetInput,
    CreateCategoryInput,
    CreateDashboardReportInput,
    CreateDashboardUserInput,
    CreateDataBreachInput,
    CreateDepartmentInput,
    CreateDomainInput,
    CreateDpiaInput,
    CreateEmployeeInput,
    CreateFalsePositiveReportInput,
    CreateHeadquarterInput,
    CreateLegalDocumentInput,
    CreateLopdpThresholdInput,
    CreateProcessingActivityInput,
    CreateRecipientInput,
    CreateScanInput,
    CreateThresholdInput,
    DashboardUserFilter,
    DataBreachSelectFilter,
    DataFlowRelationship,
    DataFlowRelationshipOption,
    DepartmentSelectFilter,
    DescribeAccountInput,
    DescribeAssetInput,
    DescribeCatalogResourceInput,
    DescribeCategoryInput,
    DescribeCloudAccountInput,
    DescribeConnectorInput,
    DescribeCurrentUserInput,
    DescribeDashboardReportEditionInput,
    DescribeDashboardReportInput,
    DescribeDataBreachEvaluationInput,
    DescribeDataBreachInput,
    DescribeDepartmentInput,
    DescribeDiscoveredDocumentInput,
    DescribeDiscoveredInfotypesInput,
    DescribeDiscoveredRecipientInput,
    DescribeDomainInput,
    DescribeDpiaInput,
    DescribeEmployeeInput,
    DescribeErrorInput,
    DescribeHeadquarterInput,
    DescribeInspectionResultInput,
    DescribeInventoryResourceInput,
    DescribeIssueInput,
    DescribeLegalDocumentInput,
    DescribeLopdpThresholdInput,
    DescribeProcessingActivityInput,
    DescribeRecipientInput,
    DescribeResourceLineageInput,
    DescribeScanInput,
    DescribeScanIterationInput,
    DescribeThresholdInput,
    DescribeTomInput,
    DescribeUserProfileInput,
    DisableDashboardUserInput,
    DiscoveredDocumentsSelectFilter,
    DiscoveredInfotypesSelectFilter,
    DiscoveredRecipientFilters,
    DownloadDashboardReportEditionInput,
    DownloadDashboardReportForSuperAdminInput,
    DownloadDashboardReportInput,
    DpiaAvailabilityRisk,
    DpiaAvailabilityRiskImpact,
    DpiaAvailabilityRiskThreat,
    DpiaConfidentialityRisk,
    DpiaConfidentialityRiskImpact,
    DpiaConfidentialityRiskThreat,
    DpiaIntegrityRisk,
    DpiaIntegrityRiskImpact,
    DpiaIntegrityRiskThreat,
    DpiaPrivacyFramework,
    DpiaRiskRiskSource,
    EmployeeSelectFilter,
    EnableDashboardUserInput,
    ErrorsFilter,
    EventsFilter,
    FileInfo,
    GetChatbotResponseInput,
    HeadquarterFilters,
    InfoTypesCombinationFilter,
    InspectionPolicy,
    InspectionResultFilter,
    InventoryListFilter,
    InventoryTagFilter,
    IssueFilter,
    LawfulBasis,
    LeafResourceFilter,
    LegalDocumentSelectFilter,
    ListAccessLogsFilter,
    ListAccessLogsInput,
    ListAccountsInput,
    ListActiveResourceTimelineInput,
    ListAssetsInput,
    ListAuditLogsFilter,
    ListAuditLogsInput,
    ListAutoSuggestionsInput,
    ListCatalogLeafResourcesExportInput,
    ListCatalogLeafResourcesInput,
    ListColumnsForResourcesInput,
    ListConnectorsInput,
    ListDashboardUsersFilter,
    ListDashboardUsersInput,
    ListDataBreachFilterInput,
    ListDataBreachInput,
    ListDepartmentsForFilterInput,
    ListDepartmentsInput,
    ListDiscoveredDocumentsInput,
    ListDiscoveredInfotypesInput,
    ListDiscoveredRecipientsInput,
    ListDiscoveredRecipientsUsersInput,
    ListDomainsInput,
    ListEmployeesForFilterInput,
    ListEmployeesInput,
    ListErrorsInput,
    ListEventsInput,
    ListHeadquartersInput,
    ListInfotypeCategoriesFilter,
    ListInfotypeCategoriesInput,
    ListInsightsFilterInput,
    ListInspectionResultsInput,
    ListInventoryResourcesExportInput,
    ListInventoryResourcesInput,
    ListIssuesInput,
    ListLegalDocumentsInput,
    ListProcessingActivitiesExportInput,
    ListProcessingActivitiesInput,
    ListProcessingActivitiesOfRecipientInput,
    ListProcessingActivityFilterInput,
    ListRecipientFilterInput,
    ListRecipientsExportInput,
    ListRecipientsForFilterInput,
    ListRecipientsInput,
    ListReportSchedulesInput,
    ListReportsEditionInput,
    ListScanExecutionInsightsInput,
    ListScanIterationsInput,
    ListScanResourceStatusInput,
    ListScansInput,
    ListTomsInput,
    ListTopResourcesWithSensitiveDataDetailsInput,
    ListUserProfilesInput,
    ManagementMethod,
    MissingDpiaFieldOptions,
    MissingDpiaObjects,
    MissingObject,
    MissingPrivacyOpsFieldOptions,
    MissingProcessingActivityObjects,
    PaStatsTimeSeriesInput,
    PageInsightsExportInput,
    PauseScanInput,
    PollDomainInput,
    PostalAddress,
    PrepareDetailedInspectionResultInput,
    ProcessingActivityExportFilters,
    ProcessingActivityRecipient,
    ProcessingActivitySelectFilter,
    RecipientFilters,
    RemoveAssetInput,
    RemoveCategoryInput,
    RemoveDashboardReportInput,
    RemoveDashboardUserInput,
    RemoveDataBreachEvaluationInput,
    RemoveDataBreachInput,
    RemoveDepartmentInput,
    RemoveDomainInput,
    RemoveDpiaInput,
    RemoveEmployeeInput,
    RemoveHeadquarterInput,
    RemoveLegalDocumentInput,
    RemoveLopdpThresholdInput,
    RemoveProcessingActivityInput,
    RemoveRecipientInput,
    RemoveTaDpiaFileInput,
    RemoveThresholdInput,
    ReportSelectFilter,
    ResetPasswordDashboardUserInput,
    ResourceBasedFilter,
    ResourceLineageFilter,
    ResumeScanInput,
    RetentionPeriod,
    ScanExecutionInsightsListFilter,
    ScanFilter,
    ScanIterationsFilter,
    ScanLegalDocumentInput,
    ScanLimits,
    ScanResourceStatusFilter,
    ScanResources,
    ScanSchedule,
    ScanSelectFilter,
    SortRecords,
    StopScanInput,
    SummarizeClassificationStatsInput,
    SummarizeDataIdentifierStatsInput,
    SummarizeDataStatsInput,
    SummarizePaStatsForOwnersInput,
    SummarizeResourceStatsInput,
    SummarizeResourceTrendsInput,
    SummarizeResourceTypeDataIdentifierCountsInput,
    SummarizeScanStatsInput,
    TagEntitiesFilter,
    TagEntityUnion,
    TagEntityUnionEntityIds,
    TagEntityUnionFilter,
    TagFilter,
    TomSelectFilter,
    UntagEntitiesInput,
    UpdateAssetInput,
    UpdateCategoryInput,
    UpdateDashboardReportInput,
    UpdateDashboardUserInput,
    UpdateDashboardUserRolesInput,
    UpdateDataBreachEvaluationInput,
    UpdateDataBreachInput,
    UpdateDepartmentInput,
    UpdateDiscoveredDocumentInput,
    UpdateDiscoveredInfotypesInput,
    UpdateDomainInput,
    UpdateDpiaInput,
    UpdateEmployeeInput,
    UpdateHeadquarterInput,
    UpdateLopdpThresholdInput,
    UpdateProcessingActivityInput,
    UpdateRecipientInput,
    UpdateRecipientStatusInput,
    UpdateTaDpiaFileInput,
    UpdateThresholdInput,
    UpdateTomInput,
    UpdatefeedbackInput,
    UsedInFilter,
    UsedInFilterRecipientsWithAtleastOnePA,
    UsedInFilterRecipientsWithoutCompletedPA,
    UserOrganisation,
    UserProfileFilter,
    ValidateClonePaForTargetOrgInput,
    VerifyEmailInput,
)


async def _serialize_add_discovered_recipient_as_recipients(
    input: AddDiscoveredRecipientAsRecipientsInput, config: Config
) -> HTTPRequest:
    path = "/discovered-recipients/add-recipients"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.discovered_recipient_ids is not None:
        result["discoveredRecipientIds"] = input.discovered_recipient_ids

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_add_ta_dpia_file(
    input: AddTaDpiaFileInput, config: Config
) -> HTTPRequest:
    path = "/processing-activities/ta-dpia-document"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.uploaded_file_id is not None:
        result["uploadedFileId"] = input.uploaded_file_id

    if input.processing_activity_id is not None:
        result["processingActivityId"] = input.processing_activity_id

    if input.link is not None:
        result["link"] = input.link

    if input.doc_type is not None:
        result["docType"] = input.doc_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_archive_discovered_recipient(
    input: ArchiveDiscoveredRecipientInput, config: Config
) -> HTTPRequest:
    if not input.discovered_recipient_id:
        raise ServiceError("discovered_recipient_id must not be empty.")

    path = "/discovered-recipients/archive/{discovered_recipient_id}".format(
        discovered_recipient_id=urlquote(input.discovered_recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_clone_pa_in_target_org(
    input: ClonePaInTargetOrgInput, config: Config
) -> HTTPRequest:
    path = "/processing-activities/clone-pa"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.target_organisation_id is not None:
        result["targetOrganisationId"] = input.target_organisation_id

    if input.owner is not None:
        result["owner"] = input.owner

    if input.missing_dpia_objects is not None:
        result["missingDpiaObjects"] = _serialize_missing_dpia_objects(
            input.missing_dpia_objects, config
        )

    if input.clone_ta is not None:
        result["cloneTa"] = input.clone_ta

    if input.name is not None:
        result["name"] = input.name

    if input.source_pa_id is not None:
        result["sourcePaId"] = input.source_pa_id

    if input.clone_dpia is not None:
        result["cloneDpia"] = input.clone_dpia

    if input.missing_processing_activity_objects is not None:
        result["missingProcessingActivityObjects"] = (
            _serialize_missing_processing_activity_objects(
                input.missing_processing_activity_objects, config
            )
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_and_send_dashboard_report(
    input: CreateAndSendDashboardReportInput, config: Config
) -> HTTPRequest:
    if not input.dashboard_report_id:
        raise ServiceError("dashboard_report_id must not be empty.")

    path = "/dashboard-report/{dashboard_report_id}/trigger".format(
        dashboard_report_id=urlquote(input.dashboard_report_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_create_asset(
    input: CreateAssetInput, config: Config
) -> HTTPRequest:
    path = "/assets"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.location_id is not None:
        result["locationId"] = input.location_id

    if input.tom_ids is not None:
        result["tomIds"] = input.tom_ids

    if input.location_type is not None:
        result["locationType"] = input.location_type

    if input.created_at is not None:
        result["createdAt"] = serialize_epoch_seconds(ensure_utc(input.created_at))

    if input.type is not None:
        result["type"] = input.type

    if input.name is not None:
        result["name"] = input.name

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_category(
    input: CreateCategoryInput, config: Config
) -> HTTPRequest:
    path = "/categories"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    if input.description is not None:
        result["description"] = input.description

    if input.category_label is not None:
        result["categoryLabel"] = input.category_label

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_dashboard_report(
    input: CreateDashboardReportInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-report"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.name is not None:
        result["name"] = input.name

    if input.recipients_email is not None:
        result["recipientsEmail"] = input.recipients_email

    if input.roles is not None:
        result["roles"] = input.roles

    if input.trigger_immediately is not None:
        result["triggerImmediately"] = input.trigger_immediately

    if input.filters is not None:
        result["filters"] = input.filters

    if input.created_by is not None:
        result["createdBy"] = input.created_by

    if input.report_types is not None:
        result["reportTypes"] = input.report_types

    if input.external_email is not None:
        result["externalEmail"] = input.external_email

    if input.status is not None:
        result["status"] = input.status

    if input.frequency is not None:
        result["frequency"] = input.frequency

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_dashboard_user(
    input: CreateDashboardUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/create"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_dashboard_user_filter(input.filter, config)

    if input.email is not None:
        result["email"] = input.email

    if input.name is not None:
        result["name"] = input.name

    if input.roles is not None:
        result["roles"] = input.roles

    if input.organisations is not None:
        result["organisations"] = _serialize_user_organisations(
            input.organisations, config
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_data_breach(
    input: CreateDataBreachInput, config: Config
) -> HTTPRequest:
    path = "/data-breaches"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.save_as_draft is not None:
        result["saveAsDraft"] = input.save_as_draft

    if input.problem_of_security_measures is not None:
        result["problemOfSecurityMeasures"] = input.problem_of_security_measures

    if input.security_measures_or_protocols is not None:
        result["securityMeasuresOrProtocols"] = input.security_measures_or_protocols

    if input.created_by is not None:
        result["createdBy"] = input.created_by

    if input.short_description is not None:
        result["shortDescription"] = input.short_description

    if input.measures_to_prevent is not None:
        result["measuresToPrevent"] = input.measures_to_prevent

    if input.compromised_sensitive_data is not None:
        result["compromisedSensitiveData"] = input.compromised_sensitive_data

    if input.profile_people_affected is not None:
        result["profilePeopleAffected"] = input.profile_people_affected

    if input.kind_of_data is not None:
        result["kindOfData"] = input.kind_of_data

    if input.number_affected_people is not None:
        result["numberAffectedPeople"] = input.number_affected_people

    if input.description is not None:
        result["description"] = input.description

    if input.evaluated_by is not None:
        result["evaluatedBy"] = input.evaluated_by

    if input.occurred_at is not None:
        result["occurredAt"] = serialize_epoch_seconds(ensure_utc(input.occurred_at))

    if input.discovered_at is not None:
        result["discoveredAt"] = serialize_epoch_seconds(
            ensure_utc(input.discovered_at)
        )

    if input.was_intentional is not None:
        result["wasIntentional"] = input.was_intentional

    if input.people_informed is not None:
        result["peopleInformed"] = input.people_informed

    if input.language is not None:
        result["language"] = input.language

    if input.consequences is not None:
        result["consequences"] = input.consequences

    if input.affected_people_from is not None:
        result["affectedPeopleFrom"] = input.affected_people_from

    if input.authorities_informed is not None:
        result["authoritiesInformed"] = input.authorities_informed

    if input.additional_information is not None:
        result["additionalInformation"] = input.additional_information

    if input.created_at is not None:
        result["createdAt"] = serialize_epoch_seconds(ensure_utc(input.created_at))

    if input.how_discovered is not None:
        result["howDiscovered"] = input.how_discovered

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_department(
    input: CreateDepartmentInput, config: Config
) -> HTTPRequest:
    path = "/departments"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.translations is not None:
        result["translations"] = input.translations

    if input.name is not None:
        result["name"] = input.name

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_domain(
    input: CreateDomainInput, config: Config
) -> HTTPRequest:
    path = "/domains"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.frequency is not None:
        result["frequency"] = input.frequency

    if input.name is not None:
        result["name"] = input.name

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_dpia(input: CreateDpiaInput, config: Config) -> HTTPRequest:
    path = "/dpias"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.additional_information is not None:
        result["additionalInformation"] = input.additional_information

    if input.additional_information_files is not None:
        result["additionalInformationFiles"] = input.additional_information_files

    if input.created_at is not None:
        result["createdAt"] = serialize_epoch_seconds(ensure_utc(input.created_at))

    if input.confidentiality is not None:
        result["confidentiality"] = _serialize_dpia_confidentiality_risk(
            input.confidentiality, config
        )

    if input.translations is not None:
        result["translations"] = input.translations

    if input.availability is not None:
        result["availability"] = _serialize_dpia_availability_risk(
            input.availability, config
        )

    if input.status is not None:
        result["status"] = input.status

    if input.updated_at is not None:
        result["updatedAt"] = serialize_epoch_seconds(ensure_utc(input.updated_at))

    if input.privacy_framework is not None:
        result["privacyFramework"] = _serialize_dpia_privacy_framework(
            input.privacy_framework, config
        )

    if input.integrity is not None:
        result["integrity"] = _serialize_dpia_integrity_risk(input.integrity, config)

    if input.processing_activity_id is not None:
        result["processingActivityId"] = input.processing_activity_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_employee(
    input: CreateEmployeeInput, config: Config
) -> HTTPRequest:
    path = "/employees"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.manager is not None:
        result["manager"] = input.manager

    if input.department is not None:
        result["department"] = input.department

    if input.created_by is not None:
        result["createdBy"] = input.created_by

    if input.position is not None:
        result["position"] = input.position

    if input.surname is not None:
        result["surname"] = input.surname

    if input.end_date is not None:
        result["endDate"] = input.end_date

    if input.nif is not None:
        result["nif"] = input.nif

    if input.name is not None:
        result["name"] = input.name

    if input.start_date is not None:
        result["startDate"] = input.start_date

    if input.email is not None:
        result["email"] = input.email

    if input.reference_id is not None:
        result["referenceId"] = input.reference_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_false_positive_report(
    input: CreateFalsePositiveReportInput, config: Config
) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/scan/false-positives/{scan_id}".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.reports is not None:
        result["reports"] = input.reports

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_headquarter(
    input: CreateHeadquarterInput, config: Config
) -> HTTPRequest:
    path = "/headquarters"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.city is not None:
        result["city"] = input.city

    if input.country is not None:
        result["country"] = input.country

    if input.name is not None:
        result["name"] = input.name

    if input.address is not None:
        result["address"] = input.address

    if input.zipcode is not None:
        result["zipcode"] = input.zipcode

    if input.tom_ids is not None:
        result["tomIds"] = input.tom_ids

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_legal_document(
    input: CreateLegalDocumentInput, config: Config
) -> HTTPRequest:
    path = "/legal-document"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.name is not None:
        result["name"] = input.name

    if input.document_link is not None:
        result["documentLink"] = input.document_link

    if input.type is not None:
        result["type"] = input.type

    if input.is_discover_infotype is not None:
        result["isDiscoverInfotype"] = input.is_discover_infotype

    if input.region is not None:
        result["region"] = input.region

    if input.source is not None:
        result["source"] = input.source

    if input.from_discovered_document_id is not None:
        result["fromDiscoveredDocumentId"] = input.from_discovered_document_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_lopdp_threshold(
    input: CreateLopdpThresholdInput, config: Config
) -> HTTPRequest:
    path = "/lopdp/thresholds"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.additional_comment is not None:
        result["additionalComment"] = input.additional_comment

    if input.rights_risk_processing_data is not None:
        result["rightsRiskProcessingData"] = input.rights_risk_processing_data

    if input.sensitive_or_special_data is not None:
        result["sensitiveOrSpecialData"] = input.sensitive_or_special_data

    if input.processing_activity_id is not None:
        result["processingActivityId"] = input.processing_activity_id

    if input.freedom_risk_processing_data is not None:
        result["freedomRiskProcessingData"] = input.freedom_risk_processing_data

    if input.large_scale_observation is not None:
        result["largeScaleObservation"] = input.large_scale_observation

    if input.processing_vulnerable_data_subject is not None:
        result["processingVulnerableDataSubject"] = (
            input.processing_vulnerable_data_subject
        )

    if input.comment is not None:
        result["comment"] = input.comment

    if input.status is not None:
        result["status"] = input.status

    if input.processing_personal_data_risk is not None:
        result["processingPersonalDataRisk"] = input.processing_personal_data_risk

    if input.innovative_technologies_used is not None:
        result["innovativeTechnologiesUsed"] = input.innovative_technologies_used

    if input.systematic_personal_assessment is not None:
        result["systematicPersonalAssessment"] = input.systematic_personal_assessment

    if input.special_category_data_processed is not None:
        result["specialCategoryDataProcessed"] = input.special_category_data_processed

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_processing_activity(
    input: CreateProcessingActivityInput, config: Config
) -> HTTPRequest:
    path = "/processing-activities"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.recipients is not None:
        result["recipients"] = _serialize_recipient_collection(input.recipients, config)

    if input.are_access_requests_managed is not None:
        result["areAccessRequestsManaged"] = input.are_access_requests_managed

    if input.translations is not None:
        result["translations"] = input.translations

    if input.assets is not None:
        result["assets"] = input.assets

    if input.processing_frequency_comment is not None:
        result["processingFrequencyComment"] = input.processing_frequency_comment

    if input.contact_person is not None:
        result["contactPerson"] = input.contact_person

    if input.data_types is not None:
        result["dataTypes"] = input.data_types

    if input.lawful_basis is not None:
        result["lawfulBasis"] = _serialize_lawful_basis_collection(
            input.lawful_basis, config
        )

    if input.updated_at is not None:
        result["updatedAt"] = serialize_epoch_seconds(ensure_utc(input.updated_at))

    if input.retention_period is not None:
        result["retentionPeriod"] = _serialize_retention_period(
            input.retention_period, config
        )

    if input.data_sources is not None:
        result["dataSources"] = input.data_sources

    if input.processing_activities_as_data_sources is not None:
        result["processingActivitiesAsDataSources"] = (
            input.processing_activities_as_data_sources
        )

    if input.infotype_volume is not None:
        result["infotypeVolume"] = input.infotype_volume

    if input.processing_frequency is not None:
        result["processingFrequency"] = input.processing_frequency

    if input.departments is not None:
        result["departments"] = input.departments

    if input.additional_info is not None:
        result["additionalInfo"] = input.additional_info

    if input.show_on_ropa_document is not None:
        result["showOnRopaDocument"] = input.show_on_ropa_document

    if input.management_methods is not None:
        result["managementMethods"] = _serialize_management_method_collection(
            input.management_methods, config
        )

    if input.additional_info_files is not None:
        result["additionalInfoFiles"] = input.additional_info_files

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    if input.created_at is not None:
        result["createdAt"] = serialize_epoch_seconds(ensure_utc(input.created_at))

    if input.data_subjects is not None:
        result["dataSubjects"] = input.data_subjects

    if input.data_flow_relationships is not None:
        result["dataFlowRelationships"] = _serialize_data_flow_relationships(
            input.data_flow_relationships, config
        )

    if input.infotype_categories is not None:
        result["infotypeCategories"] = input.infotype_categories

    if input.language is not None:
        result["language"] = input.language

    if input.company_role is not None:
        result["companyRole"] = input.company_role

    if input.active is not None:
        result["active"] = input.active

    if input.owner is not None:
        result["owner"] = input.owner

    if input.model_id is not None:
        result["modelId"] = input.model_id

    if input.purpose is not None:
        result["purpose"] = input.purpose

    if input.employees is not None:
        result["employees"] = input.employees

    if input.name is not None:
        result["name"] = input.name

    if input.retention_period_comment is not None:
        result["retentionPeriodComment"] = input.retention_period_comment

    if input.is_data_stored is not None:
        result["isDataStored"] = input.is_data_stored

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_recipient(
    input: CreateRecipientInput, config: Config
) -> HTTPRequest:
    path = "/recipients"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.categories is not None:
        result["categories"] = input.categories

    if input.dpa is not None:
        result["dpa"] = input.dpa

    if input.sub_processor_ids is not None:
        result["subProcessorIds"] = input.sub_processor_ids

    if input.recipient_model_id is not None:
        result["recipientModelId"] = input.recipient_model_id

    if input.name is not None:
        result["name"] = input.name

    if input.recipient_state is not None:
        result["recipientState"] = input.recipient_state

    if input.privacy_policy_link is not None:
        result["privacyPolicyLink"] = input.privacy_policy_link

    if input.updated_at is not None:
        result["updatedAt"] = serialize_epoch_seconds(ensure_utc(input.updated_at))

    if input.dpa_files is not None:
        result["dpaFiles"] = input.dpa_files

    if input.created_at is not None:
        result["createdAt"] = serialize_epoch_seconds(ensure_utc(input.created_at))

    if input.data_storage_location is not None:
        result["dataStorageLocation"] = input.data_storage_location

    if input.status is not None:
        result["status"] = input.status

    if input.from_discovered_recipient_id is not None:
        result["fromDiscoveredRecipientId"] = input.from_discovered_recipient_id

    if input.role is not None:
        result["role"] = input.role

    if input.recipient_warranties is not None:
        result["recipientWarranties"] = input.recipient_warranties

    if input.business_name is not None:
        result["businessName"] = input.business_name

    if input.country is not None:
        result["country"] = input.country

    if input.state is not None:
        result["state"] = input.state

    if input.dpa_status is not None:
        result["dpaStatus"] = input.dpa_status

    if input.contact_email is not None:
        result["contactEmail"] = input.contact_email

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_scan(input: CreateScanInput, config: Config) -> HTTPRequest:
    path = "/scan"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    if input.cron is not None:
        result["cron"] = input.cron

    if input.schedule is not None:
        result["schedule"] = _serialize_scan_schedule(input.schedule, config)

    if input.schedule_type is not None:
        result["scheduleType"] = input.schedule_type

    if input.scan_filter is not None:
        result["scanFilter"] = _serialize_scan_filter_list(input.scan_filter, config)

    if input.inspection_policy is not None:
        result["inspectionPolicy"] = _serialize_inspection_policy(
            input.inspection_policy, config
        )

    if input.name is not None:
        result["name"] = input.name

    if input.resources is not None:
        result["resources"] = _serialize_scan_resources(input.resources, config)

    if input.connector_id is not None:
        result["connectorId"] = input.connector_id

    if input.scan_limits is not None:
        result["scanLimits"] = _serialize_scan_limits(input.scan_limits, config)

    if input.scan_type is not None:
        result["scanType"] = input.scan_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_create_threshold(
    input: CreateThresholdInput, config: Config
) -> HTTPRequest:
    path = "/thresholds"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.translations is not None:
        result["translations"] = input.translations

    if input.systematic_monitoring_data_subject is not None:
        result["systematicMonitoringDataSubject"] = (
            input.systematic_monitoring_data_subject
        )

    if input.processing_vulnerable_data_subject is not None:
        result["processingVulnerableDataSubject"] = (
            input.processing_vulnerable_data_subject
        )

    if input.large_scale_processing_sensitive_data is not None:
        result["largeScaleProcessingSensitiveData"] = (
            input.large_scale_processing_sensitive_data
        )

    if input.created_at is not None:
        result["createdAt"] = serialize_epoch_seconds(ensure_utc(input.created_at))

    if input.innovative_technologies_used is not None:
        result["innovativeTechnologiesUsed"] = input.innovative_technologies_used

    if input.blacklist is not None:
        result["blacklist"] = input.blacklist

    if input.prevent_data_subjects_exercising_their_rights is not None:
        result["preventDataSubjectsExercisingTheirRights"] = (
            input.prevent_data_subjects_exercising_their_rights
        )

    if input.classifying_data_subject is not None:
        result["classifyingDataSubject"] = input.classifying_data_subject

    if input.automated_decision_making is not None:
        result["automatedDecisionMaking"] = input.automated_decision_making

    if input.processing_confidential_sensitive_data is not None:
        result["processingConfidentialSensitiveData"] = (
            input.processing_confidential_sensitive_data
        )

    if input.extensive_automated_evaluation_characteristics is not None:
        result["extensiveAutomatedEvaluationCharacteristics"] = (
            input.extensive_automated_evaluation_characteristics
        )

    if input.matching_merging_records_involved is not None:
        result["matchingMergingRecordsInvolved"] = (
            input.matching_merging_records_involved
        )

    if input.comment is not None:
        result["comment"] = input.comment

    if input.large_scale_data_processing is not None:
        result["largeScaleDataProcessing"] = input.large_scale_data_processing

    if input.status is not None:
        result["status"] = input.status

    if input.processing_activity_id is not None:
        result["processingActivityId"] = input.processing_activity_id

    if input.monitoring_publicly_accessible_areas is not None:
        result["monitoringPubliclyAccessibleAreas"] = (
            input.monitoring_publicly_accessible_areas
        )

    if input.updated_at is not None:
        result["updatedAt"] = serialize_epoch_seconds(ensure_utc(input.updated_at))

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_describe_account(
    input: DescribeAccountInput, config: Config
) -> HTTPRequest:
    if not input.account_id:
        raise ServiceError("account_id must not be empty.")

    path = "/account/{account_id}".format(
        account_id=urlquote(input.account_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_asset(
    input: DescribeAssetInput, config: Config
) -> HTTPRequest:
    if not input.asset_id:
        raise ServiceError("asset_id must not be empty.")

    path = "/assets/{asset_id}".format(
        asset_id=urlquote(input.asset_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_catalog_resource(
    input: DescribeCatalogResourceInput, config: Config
) -> HTTPRequest:
    if not input.resource_id:
        raise ServiceError("resource_id must not be empty.")

    path = "/resource/catalog/{resource_id}".format(
        resource_id=urlquote(input.resource_id, safe=""),
    )
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.include_parent_details is not None:
        query_params.append(
            (
                "includeParentDetails",
                ("true" if input.include_parent_details else "false"),
            )
        )

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_category(
    input: DescribeCategoryInput, config: Config
) -> HTTPRequest:
    if not input.category_label:
        raise ServiceError("category_label must not be empty.")

    path = "/categories/{category_label}".format(
        category_label=urlquote(input.category_label, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_cloud_account(
    input: DescribeCloudAccountInput, config: Config
) -> HTTPRequest:
    if not input.cloud_account_id:
        raise ServiceError("cloud_account_id must not be empty.")

    path = "/cloud-account/{cloud_account_id}".format(
        cloud_account_id=urlquote(input.cloud_account_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_connector(
    input: DescribeConnectorInput, config: Config
) -> HTTPRequest:
    if not input.connector_id:
        raise ServiceError("connector_id must not be empty.")

    path = "/connector/{connector_id}".format(
        connector_id=urlquote(input.connector_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_current_user(
    input: DescribeCurrentUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/current"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_describe_dashboard_report(
    input: DescribeDashboardReportInput, config: Config
) -> HTTPRequest:
    if not input.dashboard_report_id:
        raise ServiceError("dashboard_report_id must not be empty.")

    path = "/dashboard-report/{dashboard_report_id}".format(
        dashboard_report_id=urlquote(input.dashboard_report_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_dashboard_report_edition(
    input: DescribeDashboardReportEditionInput, config: Config
) -> HTTPRequest:
    if not input.report_edition_id:
        raise ServiceError("report_edition_id must not be empty.")

    path = "/dashboard-report-edition/{report_edition_id}".format(
        report_edition_id=urlquote(input.report_edition_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_data_breach(
    input: DescribeDataBreachInput, config: Config
) -> HTTPRequest:
    if not input.data_breach_id:
        raise ServiceError("data_breach_id must not be empty.")

    path = "/data-breaches/{data_breach_id}".format(
        data_breach_id=urlquote(input.data_breach_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_data_breach_evaluation(
    input: DescribeDataBreachEvaluationInput, config: Config
) -> HTTPRequest:
    if not input.data_breach_id:
        raise ServiceError("data_breach_id must not be empty.")

    path = "/evaluation-data-breaches/{data_breach_id}".format(
        data_breach_id=urlquote(input.data_breach_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_department(
    input: DescribeDepartmentInput, config: Config
) -> HTTPRequest:
    if not input.department_id:
        raise ServiceError("department_id must not be empty.")

    path = "/departments/{department_id}".format(
        department_id=urlquote(input.department_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_discovered_document(
    input: DescribeDiscoveredDocumentInput, config: Config
) -> HTTPRequest:
    if not input.discovered_document_id:
        raise ServiceError("discovered_document_id must not be empty.")

    path = "/discovered-document/{discovered_document_id}".format(
        discovered_document_id=urlquote(input.discovered_document_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_discovered_infotypes(
    input: DescribeDiscoveredInfotypesInput, config: Config
) -> HTTPRequest:
    if not input.discovered_infotype_id:
        raise ServiceError("discovered_infotype_id must not be empty.")

    path = "/discovered-infotypes/{discovered_infotype_id}".format(
        discovered_infotype_id=urlquote(input.discovered_infotype_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_discovered_recipient(
    input: DescribeDiscoveredRecipientInput, config: Config
) -> HTTPRequest:
    if not input.discovered_recipient_id:
        raise ServiceError("discovered_recipient_id must not be empty.")

    path = "/discovered-recipients/{discovered_recipient_id}".format(
        discovered_recipient_id=urlquote(input.discovered_recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_domain(
    input: DescribeDomainInput, config: Config
) -> HTTPRequest:
    if not input.domain_id:
        raise ServiceError("domain_id must not be empty.")

    path = "/domains/{domain_id}".format(
        domain_id=urlquote(input.domain_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_dpia(
    input: DescribeDpiaInput, config: Config
) -> HTTPRequest:
    if not input.dpia_id:
        raise ServiceError("dpia_id must not be empty.")

    path = "/dpias/{dpia_id}".format(
        dpia_id=urlquote(input.dpia_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_employee(
    input: DescribeEmployeeInput, config: Config
) -> HTTPRequest:
    if not input.employee_id:
        raise ServiceError("employee_id must not be empty.")

    path = "/employees/{employee_id}".format(
        employee_id=urlquote(input.employee_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_error(
    input: DescribeErrorInput, config: Config
) -> HTTPRequest:
    if not input.error_id:
        raise ServiceError("error_id must not be empty.")

    path = "/error/{error_id}".format(
        error_id=urlquote(input.error_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_headquarter(
    input: DescribeHeadquarterInput, config: Config
) -> HTTPRequest:
    if not input.headquarter_id:
        raise ServiceError("headquarter_id must not be empty.")

    path = "/headquarters/{headquarter_id}".format(
        headquarter_id=urlquote(input.headquarter_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_inspection_result(
    input: DescribeInspectionResultInput, config: Config
) -> HTTPRequest:
    if not input.type:
        raise ServiceError("type must not be empty.")

    if not input.id:
        raise ServiceError("id must not be empty.")

    path = "/insight/{type}/{id}".format(
        type=urlquote(input.type, safe=""),
        id=urlquote(input.id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_inventory_resource(
    input: DescribeInventoryResourceInput, config: Config
) -> HTTPRequest:
    if not input.resource_id:
        raise ServiceError("resource_id must not be empty.")

    path = "/resource/inventory/{resource_id}".format(
        resource_id=urlquote(input.resource_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_issue(
    input: DescribeIssueInput, config: Config
) -> HTTPRequest:
    if not input.issue_id:
        raise ServiceError("issue_id must not be empty.")

    path = "/issue/{issue_id}".format(
        issue_id=urlquote(input.issue_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_legal_document(
    input: DescribeLegalDocumentInput, config: Config
) -> HTTPRequest:
    if not input.document_id:
        raise ServiceError("document_id must not be empty.")

    path = "/legal-document/{document_id}".format(
        document_id=urlquote(input.document_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_lopdp_threshold(
    input: DescribeLopdpThresholdInput, config: Config
) -> HTTPRequest:
    if not input.lopdp_threshold_id:
        raise ServiceError("lopdp_threshold_id must not be empty.")

    path = "/lopdp/thresholds/{lopdp_threshold_id}".format(
        lopdp_threshold_id=urlquote(input.lopdp_threshold_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_processing_activity(
    input: DescribeProcessingActivityInput, config: Config
) -> HTTPRequest:
    if not input.processing_activity_id:
        raise ServiceError("processing_activity_id must not be empty.")

    path = "/processing-activities/{processing_activity_id}".format(
        processing_activity_id=urlquote(input.processing_activity_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_recipient(
    input: DescribeRecipientInput, config: Config
) -> HTTPRequest:
    if not input.recipient_id:
        raise ServiceError("recipient_id must not be empty.")

    path = "/recipients/{recipient_id}".format(
        recipient_id=urlquote(input.recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_resource_lineage(
    input: DescribeResourceLineageInput, config: Config
) -> HTTPRequest:
    path = "/resource/lineage"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_resource_lineage_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_describe_scan(
    input: DescribeScanInput, config: Config
) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/scan/{scan_id}".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_scan_iteration(
    input: DescribeScanIterationInput, config: Config
) -> HTTPRequest:
    if not input.scan_iteration_id:
        raise ServiceError("scan_iteration_id must not be empty.")

    path = "/scan-iteration/{scan_iteration_id}".format(
        scan_iteration_id=urlquote(input.scan_iteration_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_threshold(
    input: DescribeThresholdInput, config: Config
) -> HTTPRequest:
    if not input.threshold_id:
        raise ServiceError("threshold_id must not be empty.")

    path = "/thresholds/{threshold_id}".format(
        threshold_id=urlquote(input.threshold_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_tom(
    input: DescribeTomInput, config: Config
) -> HTTPRequest:
    if not input.tom_id:
        raise ServiceError("tom_id must not be empty.")

    path = "/toms/{tom_id}".format(
        tom_id=urlquote(input.tom_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_describe_user_profile(
    input: DescribeUserProfileInput, config: Config
) -> HTTPRequest:
    if not input.user_id:
        raise ServiceError("user_id must not be empty.")

    path = "/user/profile/{user_id}".format(
        user_id=urlquote(input.user_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_disable_dashboard_user(
    input: DisableDashboardUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/disable"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.username is not None:
        result["username"] = input.username

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_download_dashboard_report(
    input: DownloadDashboardReportInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-report/download"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.report_type is not None:
        result["reportType"] = input.report_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_download_dashboard_report_edition(
    input: DownloadDashboardReportEditionInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-report-edition/download"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.report_edition_id is not None:
        result["reportEditionId"] = input.report_edition_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_download_dashboard_report_for_super_admin(
    input: DownloadDashboardReportForSuperAdminInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-report/download-super-admin"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.report_type is not None:
        result["reportType"] = input.report_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_enable_dashboard_user(
    input: EnableDashboardUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/enable"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.username is not None:
        result["username"] = input.username

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_get_chatbot_response(
    input: GetChatbotResponseInput, config: Config
) -> HTTPRequest:
    path = "/support/chat"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.chat_history is not None:
        result["chatHistory"] = _serialize_chat_history(input.chat_history, config)

    if input.query is not None:
        result["query"] = input.query

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_access_logs(
    input: ListAccessLogsInput, config: Config
) -> HTTPRequest:
    path = "/logs/access"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_list_access_logs_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_accounts(
    input: ListAccountsInput, config: Config
) -> HTTPRequest:
    path = "/accounts"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_account_filter(input.filter, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_active_resource_timeline(
    input: ListActiveResourceTimelineInput, config: Config
) -> HTTPRequest:
    path = "/active-resource/timeline"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_assets(input: ListAssetsInput, config: Config) -> HTTPRequest:
    path = "/assets/list"
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.next_token is not None:
        query_params.append(("nextToken", input.next_token))
    if input.page_size is not None:
        query_params.append(("maxResults", str(input.page_size)))

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_asset_select_filter(input.filter, config)

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_audit_logs(
    input: ListAuditLogsInput, config: Config
) -> HTTPRequest:
    path = "/logs/audit"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_list_audit_logs_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_auto_suggestions(
    input: ListAutoSuggestionsInput, config: Config
) -> HTTPRequest:
    path = "/auto-suggest"
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.prefix is not None:
        query_params.append(("prefix", input.prefix))
    if input.object_type is not None:
        query_params.append(("objectType", input.object_type))
    if input.source is not None:
        query_params.append(("source", input.source))

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_list_catalog_leaf_resources(
    input: ListCatalogLeafResourcesInput, config: Config
) -> HTTPRequest:
    path = "/resource/catalog/listLeafResources"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.source_type is not None:
        result["sourceType"] = input.source_type

    if input.filter is not None:
        result["filter"] = _serialize_leaf_resource_filter(input.filter, config)

    if input.include is not None:
        result["include"] = _serialize_additional_data_options(input.include, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_catalog_leaf_resources_export(
    input: ListCatalogLeafResourcesExportInput, config: Config
) -> HTTPRequest:
    path = "/resource/catalog/listLeafResources/export"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_leaf_resource_filter(input.filter, config)

    if input.source_type is not None:
        result["sourceType"] = input.source_type

    if input.detailed is not None:
        result["detailed"] = input.detailed

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_columns_for_resources(
    input: ListColumnsForResourcesInput, config: Config
) -> HTTPRequest:
    path = "/resource/columns"
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.parent_resource_id is not None:
        query_params.append(("parentResourceId", input.parent_resource_id))
    if input.search_key is not None:
        query_params.append(("searchKey", input.search_key))
    if input.source_type is not None:
        query_params.append(("sourceType", input.source_type))
    if input.resource_ids is not None:
        query_params.extend(("resourceId", e) for e in input.resource_ids)
    if input.data_spaces is not None:
        query_params.extend(("dataspace", e) for e in input.data_spaces)

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_list_connectors(
    input: ListConnectorsInput, config: Config
) -> HTTPRequest:
    path = "/connector"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.filter is not None:
        result["filter"] = _serialize_connector_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_dashboard_users(
    input: ListDashboardUsersInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_list_dashboard_users_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_data_breach(
    input: ListDataBreachInput, config: Config
) -> HTTPRequest:
    path = "/data-breaches/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_data_breach_select_filter(input.filter, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_data_breach_filter(
    input: ListDataBreachFilterInput, config: Config
) -> HTTPRequest:
    path = "/data-breaches/list-filters"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter_type is not None:
        result["filterType"] = input.filter_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_departments(
    input: ListDepartmentsInput, config: Config
) -> HTTPRequest:
    path = "/departments/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_department_select_filter(input.filter, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_departments_for_filter(
    input: ListDepartmentsForFilterInput, config: Config
) -> HTTPRequest:
    path = "/departments/filter-list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_discovered_documents(
    input: ListDiscoveredDocumentsInput, config: Config
) -> HTTPRequest:
    path = "/discovered-document/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_discovered_documents_select_filter(
            input.filter, config
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_discovered_infotypes(
    input: ListDiscoveredInfotypesInput, config: Config
) -> HTTPRequest:
    path = "/discovered-infotypes/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.filter is not None:
        result["filter"] = _serialize_discovered_infotypes_select_filter(
            input.filter, config
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_discovered_recipients(
    input: ListDiscoveredRecipientsInput, config: Config
) -> HTTPRequest:
    path = "/discovered-recipients/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_discovered_recipient_filters(input.filter, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_discovered_recipients_users(
    input: ListDiscoveredRecipientsUsersInput, config: Config
) -> HTTPRequest:
    if not input.discovered_recipient_id:
        raise ServiceError("discovered_recipient_id must not be empty.")

    path = "/discovered-recipients/users/{discovered_recipient_id}".format(
        discovered_recipient_id=urlquote(input.discovered_recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_domains(
    input: ListDomainsInput, config: Config
) -> HTTPRequest:
    path = "/domains/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_employees(
    input: ListEmployeesInput, config: Config
) -> HTTPRequest:
    path = "/employees/list"
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.next_token is not None:
        query_params.append(("nextToken", input.next_token))
    if input.page_size is not None:
        query_params.append(("pageSize", str(input.page_size)))

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_employee_select_filter(input.filter, config)

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_employees_for_filter(
    input: ListEmployeesForFilterInput, config: Config
) -> HTTPRequest:
    path = "/employees/filter-list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_errors(input: ListErrorsInput, config: Config) -> HTTPRequest:
    path = "/error/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.select is not None:
        result["select"] = input.select

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_errors_filter(input.filter, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_events(input: ListEventsInput, config: Config) -> HTTPRequest:
    path = "/events/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_events_filter(input.filter, config)

    if input.select is not None:
        result["select"] = input.select

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_headquarters(
    input: ListHeadquartersInput, config: Config
) -> HTTPRequest:
    path = "/headquarters/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_headquarter_filters(input.filter, config)

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_infotype_categories(
    input: ListInfotypeCategoriesInput, config: Config
) -> HTTPRequest:
    path = "/categories/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_list_infotype_categories_filter(
            input.filter, config
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_insights_filter(
    input: ListInsightsFilterInput, config: Config
) -> HTTPRequest:
    path = "/insight/list-filters"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.filter_type is not None:
        result["filterType"] = input.filter_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_inspection_results(
    input: ListInspectionResultsInput, config: Config
) -> HTTPRequest:
    path = "/insight/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.type is not None:
        result["type"] = input.type

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.filter is not None:
        result["filter"] = _serialize_inspection_result_filter(input.filter, config)

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_inventory_resources(
    input: ListInventoryResourcesInput, config: Config
) -> HTTPRequest:
    path = "/resource/inventory/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.select is not None:
        result["select"] = input.select

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_inventory_list_filter(input.filter, config)

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.include is not None:
        result["include"] = _serialize_additional_inventory_data_options(
            input.include, config
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_inventory_resources_export(
    input: ListInventoryResourcesExportInput, config: Config
) -> HTTPRequest:
    path = "/resource/inventory/list/export"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_inventory_list_filter(input.filter, config)

    if input.include is not None:
        result["include"] = _serialize_additional_inventory_data_options(
            input.include, config
        )

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.select is not None:
        result["select"] = input.select

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_issues(input: ListIssuesInput, config: Config) -> HTTPRequest:
    path = "/issue/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.select is not None:
        result["select"] = input.select

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_issue_filter(input.filter, config)

    if input.include is not None:
        result["include"] = input.include

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_legal_documents(
    input: ListLegalDocumentsInput, config: Config
) -> HTTPRequest:
    path = "/legal-document/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.filter is not None:
        result["filter"] = _serialize_legal_document_select_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_processing_activities(
    input: ListProcessingActivitiesInput, config: Config
) -> HTTPRequest:
    path = "/processing-activities/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_processing_activity_select_filter(
            input.filter, config
        )

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_processing_activities_export(
    input: ListProcessingActivitiesExportInput, config: Config
) -> HTTPRequest:
    path = "/processing-activities/list/export"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.export_types is not None:
        result["exportTypes"] = input.export_types

    if input.filter is not None:
        result["filter"] = _serialize_processing_activity_export_filters(
            input.filter, config
        )

    if input.language is not None:
        result["language"] = input.language

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_processing_activities_of_recipient(
    input: ListProcessingActivitiesOfRecipientInput, config: Config
) -> HTTPRequest:
    if not input.recipient_id:
        raise ServiceError("recipient_id must not be empty.")

    path = "/recipients/{recipient_id}/processing-activities".format(
        recipient_id=urlquote(input.recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_list_processing_activity_filter(
    input: ListProcessingActivityFilterInput, config: Config
) -> HTTPRequest:
    path = "/pops-dashboard/processing-activities/list-filters"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter_type is not None:
        result["filterType"] = input.filter_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_recipient_filter(
    input: ListRecipientFilterInput, config: Config
) -> HTTPRequest:
    path = "/recipients/list-filters"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter_type is not None:
        result["filterType"] = input.filter_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_recipients(
    input: ListRecipientsInput, config: Config
) -> HTTPRequest:
    path = "/recipients/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_recipient_filters(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_recipients_export(
    input: ListRecipientsExportInput, config: Config
) -> HTTPRequest:
    path = "/recipients/list/export"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.export_types is not None:
        result["exportTypes"] = input.export_types

    if input.filter is not None:
        result["filter"] = _serialize_recipient_filters(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_recipients_for_filter(
    input: ListRecipientsForFilterInput, config: Config
) -> HTTPRequest:
    path = "/recipients/filter-list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_report_schedules(
    input: ListReportSchedulesInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-report/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_report_select_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_reports_edition(
    input: ListReportsEditionInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-report-edition/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.dashboard_report_id is not None:
        result["dashboardReportId"] = input.dashboard_report_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_scan_execution_insights(
    input: ListScanExecutionInsightsInput, config: Config
) -> HTTPRequest:
    path = "/scan-execution/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_scan_execution_insights_list_filter(
            input.filter, config
        )

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_scan_iterations(
    input: ListScanIterationsInput, config: Config
) -> HTTPRequest:
    path = "/scan-iteration/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_scan_iterations_filter(input.filter, config)

    if input.select is not None:
        result["select"] = input.select

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_scan_resource_status(
    input: ListScanResourceStatusInput, config: Config
) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/scan-iteration/resource-status/{scan_id}".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.filter is not None:
        result["filter"] = _serialize_scan_resource_status_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_scans(input: ListScansInput, config: Config) -> HTTPRequest:
    path = "/scan/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_scan_select_filter(input.filter, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.get_next_execution is not None:
        result["getNextExecution"] = input.get_next_execution

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.select is not None:
        result["select"] = input.select

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_toms(input: ListTomsInput, config: Config) -> HTTPRequest:
    path = "/toms/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.filter is not None:
        result["filter"] = _serialize_tom_select_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_top_resources_with_sensitive_data_details(
    input: ListTopResourcesWithSensitiveDataDetailsInput, config: Config
) -> HTTPRequest:
    path = "/insights/top-sensitive-resources"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.confidence_levels is not None:
        result["confidenceLevels"] = input.confidence_levels

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.count is not None:
        result["count"] = input.count

    if input.identifiers is not None:
        result["identifiers"] = input.identifiers

    if input.classifications is not None:
        result["classifications"] = input.classifications

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    if input.categories is not None:
        result["categories"] = input.categories

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_list_user_profiles(
    input: ListUserProfilesInput, config: Config
) -> HTTPRequest:
    path = "/user/profile/list"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_user_profile_filter(input.filter, config)

    if input.sort is not None:
        result["sort"] = _serialize_sort_records(input.sort, config)

    if input.next_token is not None:
        result["nextToken"] = input.next_token

    if input.select is not None:
        result["select"] = input.select

    if input.page_size is not None:
        result["pageSize"] = input.page_size

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_page_insights_export(
    input: PageInsightsExportInput, config: Config
) -> HTTPRequest:
    path = "/insight/page/export"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_inspection_result_filter(input.filter, config)

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.detailed is not None:
        result["detailed"] = input.detailed

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_pa_stats_time_series(
    input: PaStatsTimeSeriesInput, config: Config
) -> HTTPRequest:
    path = "/pops-dashboard/processing-activities/pa-stats-time-series"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_pause_scan(input: PauseScanInput, config: Config) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/scan/{scan_id}/pause".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_poll_domain(input: PollDomainInput, config: Config) -> HTTPRequest:
    if not input.domain_id:
        raise ServiceError("domain_id must not be empty.")

    path = "/domains/poll/{domain_id}".format(
        domain_id=urlquote(input.domain_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_prepare_detailed_inspection_result(
    input: PrepareDetailedInspectionResultInput, config: Config
) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/insight/scan/{scan_id}/detailed".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.page_id is not None:
        result["pageId"] = input.page_id

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    if input.scan_iteration_id is not None:
        result["scanIterationId"] = input.scan_iteration_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_remove_asset(
    input: RemoveAssetInput, config: Config
) -> HTTPRequest:
    if not input.asset_id:
        raise ServiceError("asset_id must not be empty.")

    path = "/assets/{asset_id}".format(
        asset_id=urlquote(input.asset_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_category(
    input: RemoveCategoryInput, config: Config
) -> HTTPRequest:
    if not input.category_label:
        raise ServiceError("category_label must not be empty.")

    path = "/categories/{category_label}".format(
        category_label=urlquote(input.category_label, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_dashboard_report(
    input: RemoveDashboardReportInput, config: Config
) -> HTTPRequest:
    if not input.dashboard_report_id:
        raise ServiceError("dashboard_report_id must not be empty.")

    path = "/dashboard-report/{dashboard_report_id}".format(
        dashboard_report_id=urlquote(input.dashboard_report_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_dashboard_user(
    input: RemoveDashboardUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/remove"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.username is not None:
        result["username"] = input.username

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_remove_data_breach(
    input: RemoveDataBreachInput, config: Config
) -> HTTPRequest:
    if not input.data_breach_id:
        raise ServiceError("data_breach_id must not be empty.")

    path = "/data-breaches/{data_breach_id}".format(
        data_breach_id=urlquote(input.data_breach_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_data_breach_evaluation(
    input: RemoveDataBreachEvaluationInput, config: Config
) -> HTTPRequest:
    if not input.data_breach_id:
        raise ServiceError("data_breach_id must not be empty.")

    path = "/evaluation-data-breaches/{data_breach_id}".format(
        data_breach_id=urlquote(input.data_breach_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_department(
    input: RemoveDepartmentInput, config: Config
) -> HTTPRequest:
    if not input.department_id:
        raise ServiceError("department_id must not be empty.")

    path = "/departments/{department_id}".format(
        department_id=urlquote(input.department_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_domain(
    input: RemoveDomainInput, config: Config
) -> HTTPRequest:
    if not input.domain_id:
        raise ServiceError("domain_id must not be empty.")

    path = "/domains/{domain_id}".format(
        domain_id=urlquote(input.domain_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_dpia(input: RemoveDpiaInput, config: Config) -> HTTPRequest:
    if not input.dpia_id:
        raise ServiceError("dpia_id must not be empty.")

    path = "/dpias/{dpia_id}".format(
        dpia_id=urlquote(input.dpia_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_employee(
    input: RemoveEmployeeInput, config: Config
) -> HTTPRequest:
    if not input.employee_id:
        raise ServiceError("employee_id must not be empty.")

    path = "/employees/{employee_id}".format(
        employee_id=urlquote(input.employee_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_headquarter(
    input: RemoveHeadquarterInput, config: Config
) -> HTTPRequest:
    if not input.headquarter_id:
        raise ServiceError("headquarter_id must not be empty.")

    path = "/headquarters/{headquarter_id}".format(
        headquarter_id=urlquote(input.headquarter_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_legal_document(
    input: RemoveLegalDocumentInput, config: Config
) -> HTTPRequest:
    if not input.document_id:
        raise ServiceError("document_id must not be empty.")

    path = "/legal-document/{document_id}".format(
        document_id=urlquote(input.document_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_lopdp_threshold(
    input: RemoveLopdpThresholdInput, config: Config
) -> HTTPRequest:
    if not input.lopdp_threshold_id:
        raise ServiceError("lopdp_threshold_id must not be empty.")

    path = "/lopdp/thresholds/{lopdp_threshold_id}".format(
        lopdp_threshold_id=urlquote(input.lopdp_threshold_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_processing_activity(
    input: RemoveProcessingActivityInput, config: Config
) -> HTTPRequest:
    if not input.processing_activity_id:
        raise ServiceError("processing_activity_id must not be empty.")

    path = "/processing-activities/{processing_activity_id}".format(
        processing_activity_id=urlquote(input.processing_activity_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_recipient(
    input: RemoveRecipientInput, config: Config
) -> HTTPRequest:
    if not input.recipient_id:
        raise ServiceError("recipient_id must not be empty.")

    path = "/recipients/{recipient_id}".format(
        recipient_id=urlquote(input.recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_remove_ta_dpia_file(
    input: RemoveTaDpiaFileInput, config: Config
) -> HTTPRequest:
    if not input.processing_activity_id:
        raise ServiceError("processing_activity_id must not be empty.")

    path = "/processing-activities/ta-dpia-document/{processing_activity_id}".format(
        processing_activity_id=urlquote(input.processing_activity_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.doc_type is not None:
        result["docType"] = input.doc_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_remove_threshold(
    input: RemoveThresholdInput, config: Config
) -> HTTPRequest:
    if not input.threshold_id:
        raise ServiceError("threshold_id must not be empty.")

    path = "/thresholds/{threshold_id}".format(
        threshold_id=urlquote(input.threshold_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_reset_password_dashboard_user(
    input: ResetPasswordDashboardUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/reset-password"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.username is not None:
        result["username"] = input.username

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_resume_scan(input: ResumeScanInput, config: Config) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/scan/{scan_id}/resume".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_scan_legal_document(
    input: ScanLegalDocumentInput, config: Config
) -> HTTPRequest:
    path = "/legal-document/scan"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.document_id is not None:
        result["documentId"] = input.document_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_stop_scan(input: StopScanInput, config: Config) -> HTTPRequest:
    if not input.scan_id:
        raise ServiceError("scan_id must not be empty.")

    path = "/scan/{scan_id}/stop".format(
        scan_id=urlquote(input.scan_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_classification_stats(
    input: SummarizeClassificationStatsInput, config: Config
) -> HTTPRequest:
    path = "/resource/classification-stats"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.filter is not None:
        result["filter"] = _serialize_classification_stats_filter(input.filter, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_data_identifier_stats(
    input: SummarizeDataIdentifierStatsInput, config: Config
) -> HTTPRequest:
    path = "/insights/identifier-stats"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.identifiers is not None:
        result["identifiers"] = input.identifiers

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    if input.categories is not None:
        result["categories"] = input.categories

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.confidence_levels is not None:
        result["confidenceLevels"] = input.confidence_levels

    if input.count is not None:
        result["count"] = input.count

    if input.classifications is not None:
        result["classifications"] = input.classifications

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_data_stats(
    input: SummarizeDataStatsInput, config: Config
) -> HTTPRequest:
    path = "/resource/data-stats"
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.source_type is not None:
        query_params.append(("sourceType", input.source_type))

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_pa_stats_for_owners(
    input: SummarizePaStatsForOwnersInput, config: Config
) -> HTTPRequest:
    path = "/pops-dashboard/processing-activities/pa-stats-for-owners"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_resource_stats(
    input: SummarizeResourceStatsInput, config: Config
) -> HTTPRequest:
    path = "/resource/resource-stats"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.include_deleted_resources is not None:
        result["includeDeletedResources"] = input.include_deleted_resources

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_resource_trends(
    input: SummarizeResourceTrendsInput, config: Config
) -> HTTPRequest:
    path = "/resource/trends"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_resource_type_data_identifier_counts(
    input: SummarizeResourceTypeDataIdentifierCountsInput, config: Config
) -> HTTPRequest:
    path = "/insights/resource-type-identifier-counts"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.classifications is not None:
        result["classifications"] = input.classifications

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    if input.identifiers is not None:
        result["identifiers"] = input.identifiers

    if input.categories is not None:
        result["categories"] = input.categories

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.count is not None:
        result["count"] = input.count

    if input.confidence_levels is not None:
        result["confidenceLevels"] = input.confidence_levels

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_summarize_scan_stats(
    input: SummarizeScanStatsInput, config: Config
) -> HTTPRequest:
    path = "/reports/scan-summary"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.reporting_period is not None:
        result["reportingPeriod"] = input.reporting_period

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_untag_entities(
    input: UntagEntitiesInput, config: Config
) -> HTTPRequest:
    path = "/entity/tags"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.tag_key is not None:
        result["tagKey"] = input.tag_key

    if input.tag_value is not None:
        result["tagValue"] = input.tag_value

    if input.entity_type is not None:
        result["entityType"] = input.entity_type

    if input.tag_entities is not None:
        result["tagEntities"] = _serialize_tag_entity_union(input.tag_entities, config)

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_update_asset(
    input: UpdateAssetInput, config: Config
) -> HTTPRequest:
    if not input.asset_id:
        raise ServiceError("asset_id must not be empty.")

    path = "/assets/{asset_id}".format(
        asset_id=urlquote(input.asset_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.location_id is not None:
        result["locationId"] = input.location_id

    if input.location_type is not None:
        result["locationType"] = input.location_type

    if input.name is not None:
        result["name"] = input.name

    if input.type is not None:
        result["type"] = input.type

    if input.tom_ids is not None:
        result["tomIds"] = input.tom_ids

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_category(
    input: UpdateCategoryInput, config: Config
) -> HTTPRequest:
    if not input.category_label:
        raise ServiceError("category_label must not be empty.")

    path = "/categories/{category_label}".format(
        category_label=urlquote(input.category_label, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.description is not None:
        result["description"] = input.description

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_dashboard_report(
    input: UpdateDashboardReportInput, config: Config
) -> HTTPRequest:
    if not input.dashboard_report_id:
        raise ServiceError("dashboard_report_id must not be empty.")

    path = "/dashboard-report/{dashboard_report_id}".format(
        dashboard_report_id=urlquote(input.dashboard_report_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.frequency is not None:
        result["frequency"] = input.frequency

    if input.recipients_email is not None:
        result["recipientsEmail"] = input.recipients_email

    if input.roles is not None:
        result["roles"] = input.roles

    if input.external_email is not None:
        result["externalEmail"] = input.external_email

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_dashboard_user(
    input: UpdateDashboardUserInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/update"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.name is not None:
        result["name"] = input.name

    if input.username is not None:
        result["username"] = input.username

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_dashboard_user_roles(
    input: UpdateDashboardUserRolesInput, config: Config
) -> HTTPRequest:
    path = "/dashboard-users/update/roles"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.updated_roles is not None:
        result["updatedRoles"] = input.updated_roles

    if input.organisations is not None:
        result["organisations"] = _serialize_user_organisations(
            input.organisations, config
        )

    if input.username is not None:
        result["username"] = input.username

    if input.previous_roles is not None:
        result["previousRoles"] = input.previous_roles

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_data_breach(
    input: UpdateDataBreachInput, config: Config
) -> HTTPRequest:
    if not input.data_breach_id:
        raise ServiceError("data_breach_id must not be empty.")

    path = "/data-breaches/{data_breach_id}".format(
        data_breach_id=urlquote(input.data_breach_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.occurred_at is not None:
        result["occurredAt"] = serialize_epoch_seconds(ensure_utc(input.occurred_at))

    if input.discovered_at is not None:
        result["discoveredAt"] = serialize_epoch_seconds(
            ensure_utc(input.discovered_at)
        )

    if input.short_description is not None:
        result["shortDescription"] = input.short_description

    if input.compromised_sensitive_data is not None:
        result["compromisedSensitiveData"] = input.compromised_sensitive_data

    if input.authorities_informed is not None:
        result["authoritiesInformed"] = input.authorities_informed

    if input.security_measures_or_protocols is not None:
        result["securityMeasuresOrProtocols"] = input.security_measures_or_protocols

    if input.additional_information is not None:
        result["additionalInformation"] = input.additional_information

    if input.created_by is not None:
        result["createdBy"] = input.created_by

    if input.save_as_draft is not None:
        result["saveAsDraft"] = input.save_as_draft

    if input.affected_people_from is not None:
        result["affectedPeopleFrom"] = input.affected_people_from

    if input.how_discovered is not None:
        result["howDiscovered"] = input.how_discovered

    if input.evaluated_by is not None:
        result["evaluatedBy"] = input.evaluated_by

    if input.people_informed is not None:
        result["peopleInformed"] = input.people_informed

    if input.was_intentional is not None:
        result["wasIntentional"] = input.was_intentional

    if input.description is not None:
        result["description"] = input.description

    if input.measures_to_prevent is not None:
        result["measuresToPrevent"] = input.measures_to_prevent

    if input.kind_of_data is not None:
        result["kindOfData"] = input.kind_of_data

    if input.profile_people_affected is not None:
        result["profilePeopleAffected"] = input.profile_people_affected

    if input.problem_of_security_measures is not None:
        result["problemOfSecurityMeasures"] = input.problem_of_security_measures

    if input.number_affected_people is not None:
        result["numberAffectedPeople"] = input.number_affected_people

    if input.consequences is not None:
        result["consequences"] = input.consequences

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_data_breach_evaluation(
    input: UpdateDataBreachEvaluationInput, config: Config
) -> HTTPRequest:
    if not input.data_breach_id:
        raise ServiceError("data_breach_id must not be empty.")

    path = "/evaluate-data-breaches/{data_breach_id}".format(
        data_breach_id=urlquote(input.data_breach_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.data_subjects_notified is not None:
        result["dataSubjectsNotified"] = input.data_subjects_notified

    if input.save_as_draft is not None:
        result["saveAsDraft"] = input.save_as_draft

    if input.data_breach_location is not None:
        result["dataBreachLocation"] = input.data_breach_location

    if input.processor_notified is not None:
        result["processorNotified"] = input.processor_notified

    if input.role is not None:
        result["role"] = input.role

    if input.processors_involved is not None:
        result["processorsInvolved"] = input.processors_involved

    if input.report_language is not None:
        result["reportLanguage"] = input.report_language

    if input.evaluation is not None:
        result["evaluation"] = input.evaluation

    if input.authorities_notified is not None:
        result["authoritiesNotified"] = input.authorities_notified

    if input.companies_affected is not None:
        result["companiesAffected"] = input.companies_affected

    if input.data_breach_controller is not None:
        result["dataBreachController"] = input.data_breach_controller

    if input.evaluated_by is not None:
        result["evaluatedBy"] = input.evaluated_by

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_update_department(
    input: UpdateDepartmentInput, config: Config
) -> HTTPRequest:
    if not input.department_id:
        raise ServiceError("department_id must not be empty.")

    path = "/departments/{department_id}".format(
        department_id=urlquote(input.department_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.name is not None:
        result["name"] = input.name

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_discovered_document(
    input: UpdateDiscoveredDocumentInput, config: Config
) -> HTTPRequest:
    if not input.discovered_document_id:
        raise ServiceError("discovered_document_id must not be empty.")

    path = "/discovered-document/{discovered_document_id}".format(
        discovered_document_id=urlquote(input.discovered_document_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.status is not None:
        result["status"] = input.status

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_discovered_infotypes(
    input: UpdateDiscoveredInfotypesInput, config: Config
) -> HTTPRequest:
    if not input.discovered_infotype_id:
        raise ServiceError("discovered_infotype_id must not be empty.")

    path = "/discovered-infotypes/{discovered_infotype_id}".format(
        discovered_infotype_id=urlquote(input.discovered_infotype_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.status is not None:
        result["status"] = input.status

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_domain(
    input: UpdateDomainInput, config: Config
) -> HTTPRequest:
    if not input.domain_id:
        raise ServiceError("domain_id must not be empty.")

    path = "/domains/{domain_id}".format(
        domain_id=urlquote(input.domain_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.name is not None:
        result["name"] = input.name

    if input.frequency is not None:
        result["frequency"] = input.frequency

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_dpia(input: UpdateDpiaInput, config: Config) -> HTTPRequest:
    if not input.dpia_id:
        raise ServiceError("dpia_id must not be empty.")

    path = "/dpias/{dpia_id}".format(
        dpia_id=urlquote(input.dpia_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.privacy_framework is not None:
        result["privacyFramework"] = _serialize_dpia_privacy_framework(
            input.privacy_framework, config
        )

    if input.availability is not None:
        result["availability"] = _serialize_dpia_availability_risk(
            input.availability, config
        )

    if input.confidentiality is not None:
        result["confidentiality"] = _serialize_dpia_confidentiality_risk(
            input.confidentiality, config
        )

    if input.translations is not None:
        result["translations"] = input.translations

    if input.additional_information is not None:
        result["additionalInformation"] = input.additional_information

    if input.additional_information_files is not None:
        result["additionalInformationFiles"] = input.additional_information_files

    if input.integrity is not None:
        result["integrity"] = _serialize_dpia_integrity_risk(input.integrity, config)

    if input.status is not None:
        result["status"] = input.status

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_employee(
    input: UpdateEmployeeInput, config: Config
) -> HTTPRequest:
    if not input.employee_id:
        raise ServiceError("employee_id must not be empty.")

    path = "/employees/{employee_id}".format(
        employee_id=urlquote(input.employee_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.start_date is not None:
        result["startDate"] = input.start_date

    if input.manager is not None:
        result["manager"] = input.manager

    if input.department is not None:
        result["department"] = input.department

    if input.end_date is not None:
        result["endDate"] = input.end_date

    if input.nif is not None:
        result["nif"] = input.nif

    if input.email is not None:
        result["email"] = input.email

    if input.name is not None:
        result["name"] = input.name

    if input.surname is not None:
        result["surname"] = input.surname

    if input.position is not None:
        result["position"] = input.position

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_updatefeedback(
    input: UpdatefeedbackInput, config: Config
) -> HTTPRequest:
    path = "/support/chat/feedback"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.rating is not None:
        result["rating"] = input.rating

    if input.post_id is not None:
        result["postId"] = input.post_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_update_headquarter(
    input: UpdateHeadquarterInput, config: Config
) -> HTTPRequest:
    if not input.headquarter_id:
        raise ServiceError("headquarter_id must not be empty.")

    path = "/headquarters/{headquarter_id}".format(
        headquarter_id=urlquote(input.headquarter_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.tom_ids is not None:
        result["tomIds"] = input.tom_ids

    if input.country is not None:
        result["country"] = input.country

    if input.zipcode is not None:
        result["zipcode"] = input.zipcode

    if input.city is not None:
        result["city"] = input.city

    if input.address is not None:
        result["address"] = input.address

    if input.name is not None:
        result["name"] = input.name

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_lopdp_threshold(
    input: UpdateLopdpThresholdInput, config: Config
) -> HTTPRequest:
    if not input.lopdp_threshold_id:
        raise ServiceError("lopdp_threshold_id must not be empty.")

    path = "/lopdp/thresholds/{lopdp_threshold_id}".format(
        lopdp_threshold_id=urlquote(input.lopdp_threshold_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.large_scale_observation is not None:
        result["largeScaleObservation"] = input.large_scale_observation

    if input.processing_vulnerable_data_subject is not None:
        result["processingVulnerableDataSubject"] = (
            input.processing_vulnerable_data_subject
        )

    if input.systematic_personal_assessment is not None:
        result["systematicPersonalAssessment"] = input.systematic_personal_assessment

    if input.special_category_data_processed is not None:
        result["specialCategoryDataProcessed"] = input.special_category_data_processed

    if input.rights_risk_processing_data is not None:
        result["rightsRiskProcessingData"] = input.rights_risk_processing_data

    if input.status is not None:
        result["status"] = input.status

    if input.freedom_risk_processing_data is not None:
        result["freedomRiskProcessingData"] = input.freedom_risk_processing_data

    if input.innovative_technologies_used is not None:
        result["innovativeTechnologiesUsed"] = input.innovative_technologies_used

    if input.processing_personal_data_risk is not None:
        result["processingPersonalDataRisk"] = input.processing_personal_data_risk

    if input.sensitive_or_special_data is not None:
        result["sensitiveOrSpecialData"] = input.sensitive_or_special_data

    if input.additional_comment is not None:
        result["additionalComment"] = input.additional_comment

    if input.comment is not None:
        result["comment"] = input.comment

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_processing_activity(
    input: UpdateProcessingActivityInput, config: Config
) -> HTTPRequest:
    if not input.processing_activity_id:
        raise ServiceError("processing_activity_id must not be empty.")

    path = "/processing-activities/{processing_activity_id}".format(
        processing_activity_id=urlquote(input.processing_activity_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.model_id is not None:
        result["modelId"] = input.model_id

    if input.retention_period_comment is not None:
        result["retentionPeriodComment"] = input.retention_period_comment

    if input.management_methods is not None:
        result["managementMethods"] = _serialize_management_method_collection(
            input.management_methods, config
        )

    if input.purpose is not None:
        result["purpose"] = input.purpose

    if input.lawful_basis is not None:
        result["lawfulBasis"] = _serialize_lawful_basis_collection(
            input.lawful_basis, config
        )

    if input.contact_person is not None:
        result["contactPerson"] = input.contact_person

    if input.active is not None:
        result["active"] = input.active

    if input.data_subjects is not None:
        result["dataSubjects"] = input.data_subjects

    if input.employees is not None:
        result["employees"] = input.employees

    if input.recipients is not None:
        result["recipients"] = _serialize_recipient_collection(input.recipients, config)

    if input.name is not None:
        result["name"] = input.name

    if input.is_data_stored is not None:
        result["isDataStored"] = input.is_data_stored

    if input.infotype_volume is not None:
        result["infotypeVolume"] = input.infotype_volume

    if input.additional_info_files is not None:
        result["additionalInfoFiles"] = input.additional_info_files

    if input.company_role is not None:
        result["companyRole"] = input.company_role

    if input.processing_activities_as_data_sources is not None:
        result["processingActivitiesAsDataSources"] = (
            input.processing_activities_as_data_sources
        )

    if input.departments is not None:
        result["departments"] = input.departments

    if input.owner is not None:
        result["owner"] = input.owner

    if input.processing_frequency_comment is not None:
        result["processingFrequencyComment"] = input.processing_frequency_comment

    if input.translations is not None:
        result["translations"] = input.translations

    if input.infotype_categories is not None:
        result["infotypeCategories"] = input.infotype_categories

    if input.data_flow_relationships is not None:
        result["dataFlowRelationships"] = _serialize_data_flow_relationships(
            input.data_flow_relationships, config
        )

    if input.assets is not None:
        result["assets"] = input.assets

    if input.data_types is not None:
        result["dataTypes"] = input.data_types

    if input.processing_frequency is not None:
        result["processingFrequency"] = input.processing_frequency

    if input.are_access_requests_managed is not None:
        result["areAccessRequestsManaged"] = input.are_access_requests_managed

    if input.additional_info is not None:
        result["additionalInfo"] = input.additional_info

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    if input.show_on_ropa_document is not None:
        result["showOnRopaDocument"] = input.show_on_ropa_document

    if input.retention_period is not None:
        result["retentionPeriod"] = _serialize_retention_period(
            input.retention_period, config
        )

    if input.data_sources is not None:
        result["dataSources"] = input.data_sources

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_recipient(
    input: UpdateRecipientInput, config: Config
) -> HTTPRequest:
    if not input.recipient_id:
        raise ServiceError("recipient_id must not be empty.")

    path = "/recipients/{recipient_id}".format(
        recipient_id=urlquote(input.recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.dpa_status is not None:
        result["dpaStatus"] = input.dpa_status

    if input.country is not None:
        result["country"] = input.country

    if input.name is not None:
        result["name"] = input.name

    if input.recipient_state is not None:
        result["recipientState"] = input.recipient_state

    if input.privacy_policy_link is not None:
        result["privacyPolicyLink"] = input.privacy_policy_link

    if input.role is not None:
        result["role"] = input.role

    if input.dpa_files is not None:
        result["dpaFiles"] = input.dpa_files

    if input.categories is not None:
        result["categories"] = input.categories

    if input.data_storage_location is not None:
        result["dataStorageLocation"] = input.data_storage_location

    if input.recipient_warranties is not None:
        result["recipientWarranties"] = input.recipient_warranties

    if input.state is not None:
        result["state"] = input.state

    if input.automation_status is not None:
        result["automationStatus"] = input.automation_status

    if input.status is not None:
        result["status"] = input.status

    if input.business_name is not None:
        result["businessName"] = input.business_name

    if input.sub_processor_ids is not None:
        result["subProcessorIds"] = input.sub_processor_ids

    if input.contact_email is not None:
        result["contactEmail"] = input.contact_email

    if input.dpa is not None:
        result["dpa"] = input.dpa

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_recipient_status(
    input: UpdateRecipientStatusInput, config: Config
) -> HTTPRequest:
    if not input.recipient_id:
        raise ServiceError("recipient_id must not be empty.")

    path = "/recipients/{recipient_id}/update-status".format(
        recipient_id=urlquote(input.recipient_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.automation_status is not None:
        result["automationStatus"] = input.automation_status

    if input.status is not None:
        result["status"] = input.status

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_ta_dpia_file(
    input: UpdateTaDpiaFileInput, config: Config
) -> HTTPRequest:
    if not input.processing_activity_id:
        raise ServiceError("processing_activity_id must not be empty.")

    path = "/processing-activities/ta-dpia-document/{processing_activity_id}".format(
        processing_activity_id=urlquote(input.processing_activity_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.uploaded_file_id is not None:
        result["uploadedFileId"] = input.uploaded_file_id

    if input.doc_type is not None:
        result["docType"] = input.doc_type

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_threshold(
    input: UpdateThresholdInput, config: Config
) -> HTTPRequest:
    if not input.threshold_id:
        raise ServiceError("threshold_id must not be empty.")

    path = "/thresholds/{threshold_id}".format(
        threshold_id=urlquote(input.threshold_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.large_scale_processing_sensitive_data is not None:
        result["largeScaleProcessingSensitiveData"] = (
            input.large_scale_processing_sensitive_data
        )

    if input.systematic_monitoring_data_subject is not None:
        result["systematicMonitoringDataSubject"] = (
            input.systematic_monitoring_data_subject
        )

    if input.translations is not None:
        result["translations"] = input.translations

    if input.matching_merging_records_involved is not None:
        result["matchingMergingRecordsInvolved"] = (
            input.matching_merging_records_involved
        )

    if input.prevent_data_subjects_exercising_their_rights is not None:
        result["preventDataSubjectsExercisingTheirRights"] = (
            input.prevent_data_subjects_exercising_their_rights
        )

    if input.processing_confidential_sensitive_data is not None:
        result["processingConfidentialSensitiveData"] = (
            input.processing_confidential_sensitive_data
        )

    if input.innovative_technologies_used is not None:
        result["innovativeTechnologiesUsed"] = input.innovative_technologies_used

    if input.classifying_data_subject is not None:
        result["classifyingDataSubject"] = input.classifying_data_subject

    if input.blacklist is not None:
        result["blacklist"] = input.blacklist

    if input.automated_decision_making is not None:
        result["automatedDecisionMaking"] = input.automated_decision_making

    if input.extensive_automated_evaluation_characteristics is not None:
        result["extensiveAutomatedEvaluationCharacteristics"] = (
            input.extensive_automated_evaluation_characteristics
        )

    if input.comment is not None:
        result["comment"] = input.comment

    if input.large_scale_data_processing is not None:
        result["largeScaleDataProcessing"] = input.large_scale_data_processing

    if input.monitoring_publicly_accessible_areas is not None:
        result["monitoringPubliclyAccessibleAreas"] = (
            input.monitoring_publicly_accessible_areas
        )

    if input.processing_vulnerable_data_subject is not None:
        result["processingVulnerableDataSubject"] = (
            input.processing_vulnerable_data_subject
        )

    if input.status is not None:
        result["status"] = input.status

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_tom(input: UpdateTomInput, config: Config) -> HTTPRequest:
    if not input.tom_id:
        raise ServiceError("tom_id must not be empty.")

    path = "/toms/{tom_id}".format(
        tom_id=urlquote(input.tom_id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.status is not None:
        result["status"] = input.status

    if input.note is not None:
        result["note"] = input.note

    if input.document_files is not None:
        result["documentFiles"] = input.document_files

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_validate_clone_pa_for_target_org(
    input: ValidateClonePaForTargetOrgInput, config: Config
) -> HTTPRequest:
    path = "/processing-activities/validate-clone-pa"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, DocumentValue] = {}

    if input.target_organisation_id is not None:
        result["targetOrganisationId"] = input.target_organisation_id

    if input.source_processing_activity_id is not None:
        result["sourceProcessingActivityId"] = input.source_processing_activity_id

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    if input.organisation_id is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="x-selected-organisation-id",
                        values=[str(input.organisation_id)],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_verify_email(
    input: VerifyEmailInput, config: Config
) -> HTTPRequest:
    if not input.verification_id:
        raise ServiceError("verification_id must not be empty.")

    if not input.token:
        raise ServiceError("token must not be empty.")

    path = "/email-verify/{verification_id}/{token}".format(
        verification_id=urlquote(input.verification_id, safe=""),
        token=urlquote(input.token, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


def _serialize_account_filter(
    input: AccountFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.type is not None:
        result["type"] = input.type

    if input.status is not None:
        result["status"] = input.status

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.cloud_account_id is not None:
        result["cloudAccountId"] = input.cloud_account_id

    if input.active_states is not None:
        result["activeStates"] = input.active_states

    return result


def _serialize_additional_data_options(
    input: AdditionalDataOptions, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.violation_summary is not None:
        result["violationSummary"] = input.violation_summary

    if input.framework_exceptions_count is not None:
        result["frameworkExceptionsCount"] = input.framework_exceptions_count

    return result


def _serialize_additional_inventory_data_options(
    input: AdditionalInventoryDataOptions, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.child_resource_stats is not None:
        result["childResourceStats"] = _serialize_child_resource_stats_options(
            input.child_resource_stats, config
        )

    if input.violation_metrics is not None:
        result["violationMetrics"] = input.violation_metrics

    if input.framework_exceptions_count is not None:
        result["frameworkExceptionsCount"] = input.framework_exceptions_count

    if input.cloud_connection_details is not None:
        result["cloudConnectionDetails"] = input.cloud_connection_details

    return result


def _serialize_asset_select_filter(
    input: AssetSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.type is not None:
        result["type"] = input.type

    return result


def _serialize_calendar_spec(
    input: CalendarSpec, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.second is not None:
        result["second"] = input.second

    if input.minute is not None:
        result["minute"] = input.minute

    if input.hour is not None:
        result["hour"] = input.hour

    if input.day_of_month is not None:
        result["dayOfMonth"] = input.day_of_month

    if input.month is not None:
        result["month"] = input.month

    if input.year is not None:
        result["year"] = input.year

    return result


def _serialize_calendar_spec_list(
    input: list[CalendarSpec], config: Config
) -> list[DocumentValue]:
    return [_serialize_calendar_spec(e, config) for e in input]


def _serialize_chat_history(
    input: list[Document], config: Config
) -> list[DocumentValue]:
    return [e.as_value() for e in input]


def _serialize_child_resource_stats_options(
    input: ChildResourceStatsOptions, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.scans is not None:
        result["scans"] = input.scans

    if input.data_size is not None:
        result["dataSize"] = input.data_size

    return result


def _serialize_classification_stats_filter(
    input: ClassificationStatsFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.classification is not None:
        result["classification"] = input.classification

    return result


def _serialize_connector_filter(
    input: ConnectorFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.names is not None:
        result["names"] = input.names

    if input.states is not None:
        result["states"] = input.states

    if input.active_states is not None:
        result["activeStates"] = input.active_states

    if input.connector_ids is not None:
        result["connectorIds"] = input.connector_ids

    if input.data_plane_ids is not None:
        result["dataPlaneIds"] = input.data_plane_ids

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.connector_types is not None:
        result["connectorTypes"] = input.connector_types

    if input.resource_ids is not None:
        result["resourceIds"] = input.resource_ids

    return result


def _serialize_dashboard_user_filter(
    input: DashboardUserFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.type is not None:
        result["type"] = input.type

    if input.id is not None:
        result["id"] = input.id

    return result


def _serialize_data_breach_select_filter(
    input: DataBreachSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.authorities_notified is not None:
        result["authoritiesNotified"] = input.authorities_notified

    if input.owner is not None:
        result["owner"] = input.owner

    if input.status is not None:
        result["status"] = input.status

    return result


def _serialize_data_flow_relationship(
    input: DataFlowRelationship, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["from"] = _serialize_data_flow_relationship_option(input.from_, config)

    result["to"] = _serialize_data_flow_relationship_option(input.to, config)

    return result


def _serialize_data_flow_relationship_option(
    input: DataFlowRelationshipOption, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["type"] = input.type

    if input.value is not None:
        result["value"] = input.value

    return result


def _serialize_data_flow_relationships(
    input: list[DataFlowRelationship], config: Config
) -> list[DocumentValue]:
    return [_serialize_data_flow_relationship(e, config) for e in input]


def _serialize_department_select_filter(
    input: DepartmentSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.department_ids is not None:
        result["departmentIds"] = input.department_ids

    return result


def _serialize_discovered_documents_select_filter(
    input: DiscoveredDocumentsSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.status is not None:
        result["status"] = input.status

    return result


def _serialize_discovered_infotypes_select_filter(
    input: DiscoveredInfotypesSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.status is not None:
        result["status"] = input.status

    return result


def _serialize_discovered_recipient_filters(
    input: DiscoveredRecipientFilters, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.status is not None:
        result["status"] = input.status

    if input.discovery_source is not None:
        result["discoverySource"] = input.discovery_source

    return result


def _serialize_dpia_availability_risk(
    input: DpiaAvailabilityRisk, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.threats is not None:
        result["threats"] = _serialize_dpia_availability_risk_threats_collection(
            input.threats, config
        )

    if input.threats_comment is not None:
        result["threatsComment"] = input.threats_comment

    if input.impacts is not None:
        result["impacts"] = _serialize_dpia_availability_risk_impacts_collection(
            input.impacts, config
        )

    if input.impacts_comment is not None:
        result["impactsComment"] = input.impacts_comment

    if input.risk_sources is not None:
        result["riskSources"] = _serialize_dpia_risk_risk_sources_collection(
            input.risk_sources, config
        )

    if input.risk_sources_comment is not None:
        result["riskSourcesComment"] = input.risk_sources_comment

    if input.implemented_toms is not None:
        result["implementedToms"] = input.implemented_toms

    if input.implemented_toms_comment is not None:
        result["implementedTomsComment"] = input.implemented_toms_comment

    if input.planned_toms is not None:
        result["plannedToms"] = input.planned_toms

    if input.planned_toms_comment is not None:
        result["plannedTomsComment"] = input.planned_toms_comment

    if input.baseline_severity is not None:
        result["baselineSeverity"] = input.baseline_severity

    if input.baseline_likelihood is not None:
        result["baselineLikelihood"] = input.baseline_likelihood

    if input.baseline_comment is not None:
        result["baselineComment"] = input.baseline_comment

    if input.residual_risk_severity is not None:
        result["residualRiskSeverity"] = input.residual_risk_severity

    if input.residual_risk_likelihood is not None:
        result["residualRiskLikelihood"] = input.residual_risk_likelihood

    if input.residual_risk_comment is not None:
        result["residualRiskComment"] = input.residual_risk_comment

    return result


def _serialize_dpia_availability_risk_impact(
    input: DpiaAvailabilityRiskImpact, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_availability_risk_impacts_collection(
    input: list[DpiaAvailabilityRiskImpact], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_availability_risk_impact(e, config) for e in input]


def _serialize_dpia_availability_risk_threat(
    input: DpiaAvailabilityRiskThreat, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_availability_risk_threats_collection(
    input: list[DpiaAvailabilityRiskThreat], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_availability_risk_threat(e, config) for e in input]


def _serialize_dpia_confidentiality_risk(
    input: DpiaConfidentialityRisk, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.threats is not None:
        result["threats"] = _serialize_dpia_confidentiality_risk_threats_collection(
            input.threats, config
        )

    if input.threats_comment is not None:
        result["threatsComment"] = input.threats_comment

    if input.impacts is not None:
        result["impacts"] = _serialize_dpia_confidentiality_risk_impacts_collection(
            input.impacts, config
        )

    if input.impacts_comment is not None:
        result["impactsComment"] = input.impacts_comment

    if input.risk_sources is not None:
        result["riskSources"] = _serialize_dpia_risk_risk_sources_collection(
            input.risk_sources, config
        )

    if input.risk_sources_comment is not None:
        result["riskSourcesComment"] = input.risk_sources_comment

    if input.implemented_toms is not None:
        result["implementedToms"] = input.implemented_toms

    if input.implemented_toms_comment is not None:
        result["implementedTomsComment"] = input.implemented_toms_comment

    if input.planned_toms is not None:
        result["plannedToms"] = input.planned_toms

    if input.planned_toms_comment is not None:
        result["plannedTomsComment"] = input.planned_toms_comment

    if input.baseline_severity is not None:
        result["baselineSeverity"] = input.baseline_severity

    if input.baseline_likelihood is not None:
        result["baselineLikelihood"] = input.baseline_likelihood

    if input.baseline_comment is not None:
        result["baselineComment"] = input.baseline_comment

    if input.residual_risk_severity is not None:
        result["residualRiskSeverity"] = input.residual_risk_severity

    if input.residual_risk_likelihood is not None:
        result["residualRiskLikelihood"] = input.residual_risk_likelihood

    if input.residual_risk_comment is not None:
        result["residualRiskComment"] = input.residual_risk_comment

    return result


def _serialize_dpia_confidentiality_risk_impact(
    input: DpiaConfidentialityRiskImpact, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_confidentiality_risk_impacts_collection(
    input: list[DpiaConfidentialityRiskImpact], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_confidentiality_risk_impact(e, config) for e in input]


def _serialize_dpia_confidentiality_risk_threat(
    input: DpiaConfidentialityRiskThreat, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_confidentiality_risk_threats_collection(
    input: list[DpiaConfidentialityRiskThreat], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_confidentiality_risk_threat(e, config) for e in input]


def _serialize_dpia_integrity_risk(
    input: DpiaIntegrityRisk, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.threats is not None:
        result["threats"] = _serialize_dpia_integrity_risk_threats_collection(
            input.threats, config
        )

    if input.threats_comment is not None:
        result["threatsComment"] = input.threats_comment

    if input.impacts is not None:
        result["impacts"] = _serialize_dpia_integrity_risk_impacts_collection(
            input.impacts, config
        )

    if input.impacts_comment is not None:
        result["impactsComment"] = input.impacts_comment

    if input.risk_sources is not None:
        result["riskSources"] = _serialize_dpia_risk_risk_sources_collection(
            input.risk_sources, config
        )

    if input.risk_sources_comment is not None:
        result["riskSourcesComment"] = input.risk_sources_comment

    if input.implemented_toms is not None:
        result["implementedToms"] = input.implemented_toms

    if input.implemented_toms_comment is not None:
        result["implementedTomsComment"] = input.implemented_toms_comment

    if input.planned_toms is not None:
        result["plannedToms"] = input.planned_toms

    if input.planned_toms_comment is not None:
        result["plannedTomsComment"] = input.planned_toms_comment

    if input.baseline_severity is not None:
        result["baselineSeverity"] = input.baseline_severity

    if input.baseline_likelihood is not None:
        result["baselineLikelihood"] = input.baseline_likelihood

    if input.baseline_comment is not None:
        result["baselineComment"] = input.baseline_comment

    if input.residual_risk_severity is not None:
        result["residualRiskSeverity"] = input.residual_risk_severity

    if input.residual_risk_likelihood is not None:
        result["residualRiskLikelihood"] = input.residual_risk_likelihood

    if input.residual_risk_comment is not None:
        result["residualRiskComment"] = input.residual_risk_comment

    return result


def _serialize_dpia_integrity_risk_impact(
    input: DpiaIntegrityRiskImpact, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_integrity_risk_impacts_collection(
    input: list[DpiaIntegrityRiskImpact], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_integrity_risk_impact(e, config) for e in input]


def _serialize_dpia_integrity_risk_threat(
    input: DpiaIntegrityRiskThreat, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_integrity_risk_threats_collection(
    input: list[DpiaIntegrityRiskThreat], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_integrity_risk_threat(e, config) for e in input]


def _serialize_dpia_privacy_framework(
    input: DpiaPrivacyFramework, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.purpose_limitation is not None:
        result["purposeLimitation"] = input.purpose_limitation

    if input.data_minimisation is not None:
        result["dataMinimisation"] = input.data_minimisation

    if input.accuracy is not None:
        result["accuracy"] = input.accuracy

    if input.retention is not None:
        result["retention"] = input.retention

    if input.retention_comment is not None:
        result["retentionComment"] = input.retention_comment

    if input.transparency is not None:
        result["transparency"] = input.transparency

    if input.consent is not None:
        result["consent"] = input.consent

    if input.data_rights_exercised is not None:
        result["dataRightsExercised"] = input.data_rights_exercised

    if input.additional_comment is not None:
        result["additionalComment"] = input.additional_comment

    return result


def _serialize_dpia_risk_risk_source(
    input: DpiaRiskRiskSource, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_dpia_risk_risk_sources_collection(
    input: list[DpiaRiskRiskSource], config: Config
) -> list[DocumentValue]:
    return [_serialize_dpia_risk_risk_source(e, config) for e in input]


def _serialize_employee_select_filter(
    input: EmployeeSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.department is not None:
        result["department"] = input.department

    if input.employee_ids is not None:
        result["employeeIds"] = input.employee_ids

    return result


def _serialize_errors_filter(
    input: ErrorsFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.scan_iteration_id is not None:
        result["scanIterationId"] = input.scan_iteration_id

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.scan_execution_id is not None:
        result["scanExecutionId"] = input.scan_execution_id

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    return result


def _serialize_events_filter(
    input: EventsFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.event_id is not None:
        result["eventId"] = input.event_id

    if input.issue_id is not None:
        result["issueId"] = input.issue_id

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.user_id is not None:
        result["userId"] = input.user_id

    if input.search is not None:
        result["search"] = input.search

    if input.issue_type is not None:
        result["issueType"] = input.issue_type

    if input.new_infotype_found is not None:
        result["newInfotypeFound"] = input.new_infotype_found

    return result


def _serialize_file_info(input: FileInfo, config: Config) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.uploaded_file_id is not None:
        result["uploadedFileId"] = input.uploaded_file_id

    if input.name is not None:
        result["name"] = input.name

    if input.category is not None:
        result["category"] = input.category

    if input.url is not None:
        result["url"] = input.url

    return result


def _serialize_headquarter_filters(
    input: HeadquarterFilters, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.headquarter_ids is not None:
        result["headquarterIds"] = input.headquarter_ids

    return result


def _serialize_info_types_combination_filter(
    input: InfoTypesCombinationFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["infoTypes"] = input.info_types

    result["ops"] = input.ops

    return result


def _serialize_inspection_policy(
    input: InspectionPolicy, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.collect_tokens is not None:
        result["collectTokens"] = input.collect_tokens

    if input.mask_details is not None:
        result["maskDetails"] = input.mask_details

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    if input.compliance is not None:
        result["compliance"] = input.compliance

    return result


def _serialize_inspection_result_filter(
    input: InspectionResultFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.page_id is not None:
        result["pageId"] = input.page_id

    if input.resource_ids is not None:
        result["resourceIds"] = input.resource_ids

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    if input.scan_iteration_id is not None:
        result["scanIterationId"] = input.scan_iteration_id

    if input.info_types is not None:
        result["infoTypes"] = _serialize_info_types_combination_filter(
            input.info_types, config
        )

    if input.user_emails is not None:
        result["userEmails"] = input.user_emails

    if input.status is not None:
        result["status"] = input.status

    if input.file_extension is not None:
        result["fileExtension"] = input.file_extension

    if input.categories is not None:
        result["categories"] = input.categories

    if input.infotype_confidence is not None:
        result["infotypeConfidence"] = input.infotype_confidence

    return result


def _serialize_inventory_list_filter(
    input: InventoryListFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.project_id is not None:
        result["projectId"] = input.project_id

    if input.region is not None:
        result["region"] = input.region

    if input.regions is not None:
        result["regions"] = input.regions

    if input.search is not None:
        result["search"] = input.search

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    if input.resource_ids is not None:
        result["resourceIds"] = input.resource_ids

    if input.parent_id is not None:
        result["parentId"] = input.parent_id

    if input.first_seen is not None:
        result["firstSeen"] = _serialize_time_filter(input.first_seen, config)

    if input.no_owner is not None:
        result["noOwner"] = input.no_owner

    if input.has_owner is not None:
        result["hasOwner"] = input.has_owner

    if input.has_pii is not None:
        result["hasPii"] = input.has_pii

    if input.data_risks is not None:
        result["dataRisks"] = input.data_risks

    if input.severity_score is not None:
        result["severityScore"] = input.severity_score

    result["hideBorneoResources"] = input.hide_borneo_resources

    if input.data_source_categories is not None:
        result["dataSourceCategories"] = input.data_source_categories

    if input.classification is not None:
        result["classification"] = input.classification

    if input.scannable_resource_types is not None:
        result["scannableResourceTypes"] = input.scannable_resource_types

    if input.resource_tags is not None:
        result["resourceTags"] = _serialize_inventory_tag_filter_list(
            input.resource_tags, config
        )

    if input.azure_connection_ids is not None:
        result["azureConnectionIds"] = input.azure_connection_ids

    if input.gcp_connection_ids is not None:
        result["gcpConnectionIds"] = input.gcp_connection_ids

    return result


def _serialize_inventory_tag_filter(
    input: InventoryTagFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["source"] = input.source

    result["tagKey"] = input.tag_key

    result["tagValue"] = input.tag_value

    return result


def _serialize_inventory_tag_filter_list(
    input: list[InventoryTagFilter], config: Config
) -> list[DocumentValue]:
    return [_serialize_inventory_tag_filter(e, config) for e in input]


def _serialize_issue_filter(
    input: IssueFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.resources is not None:
        result["resources"] = input.resources

    if input.resource_types is not None:
        result["resourceTypes"] = input.resource_types

    if input.cloud_account_types is not None:
        result["cloudAccountTypes"] = input.cloud_account_types

    if input.cloud_account_ids is not None:
        result["cloudAccountIds"] = input.cloud_account_ids

    if input.states is not None:
        result["states"] = input.states

    if input.severities is not None:
        result["severities"] = input.severities

    if input.search is not None:
        result["search"] = input.search

    if input.failed_controls is not None:
        result["failedControls"] = input.failed_controls

    return result


def _serialize_lawful_basis(
    input: LawfulBasis, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["lawfulnessType"] = input.lawfulness_type

    if input.comment is not None:
        result["comment"] = input.comment

    if input.additional_info_file is not None:
        result["additionalInfoFile"] = input.additional_info_file

    if input.additional_info_file_object is not None:
        result["additionalInfoFileObject"] = _serialize_file_info(
            input.additional_info_file_object, config
        )

    return result


def _serialize_lawful_basis_collection(
    input: list[LawfulBasis], config: Config
) -> list[DocumentValue]:
    return [_serialize_lawful_basis(e, config) for e in input]


def _serialize_leaf_resource_filter(
    input: LeafResourceFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.account is not None:
        result["account"] = input.account

    if input.project_ids is not None:
        result["projectIds"] = input.project_ids

    if input.instance is not None:
        result["instance"] = input.instance

    if input.database is not None:
        result["database"] = input.database

    if input.dataset is not None:
        result["dataset"] = input.dataset

    if input.schema is not None:
        result["schema"] = input.schema

    if input.drive_id is not None:
        result["driveId"] = input.drive_id

    if input.org_unit_id is not None:
        result["orgUnitId"] = input.org_unit_id

    if input.drive_type is not None:
        result["driveType"] = input.drive_type

    if input.region is not None:
        result["region"] = input.region

    if input.status is not None:
        result["status"] = input.status

    if input.parent_id is not None:
        result["parentId"] = input.parent_id

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    if input.scanned is not None:
        result["scanned"] = input.scanned

    if input.info_types is not None:
        result["infoTypes"] = _serialize_info_types_combination_filter(
            input.info_types, config
        )

    if input.classification is not None:
        result["classification"] = input.classification

    if input.categories is not None:
        result["categories"] = input.categories

    if input.space_status is not None:
        result["spaceStatus"] = input.space_status

    if input.space_type is not None:
        result["spaceType"] = input.space_type

    if input.severity_score is not None:
        result["severityScore"] = input.severity_score

    if input.resource_tags is not None:
        result["resourceTags"] = _serialize_inventory_tag_filter_list(
            input.resource_tags, config
        )

    if input.no_owner is not None:
        result["noOwner"] = input.no_owner

    if input.has_owner is not None:
        result["hasOwner"] = input.has_owner

    if input.first_seen is not None:
        result["firstSeen"] = _serialize_time_filter(input.first_seen, config)

    if input.catalog is not None:
        result["catalog"] = input.catalog

    return result


def _serialize_legal_document_select_filter(
    input: LegalDocumentSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.status is not None:
        result["status"] = input.status

    return result


def _serialize_list_access_logs_filter(
    input: ListAccessLogsFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    result["logType"] = input.log_type

    if input.email is not None:
        result["email"] = input.email

    if input.operation_name is not None:
        result["operationName"] = input.operation_name

    if input.request_id is not None:
        result["requestId"] = input.request_id

    if input.start is not None:
        result["start"] = input.start

    if input.end is not None:
        result["end"] = input.end

    return result


def _serialize_list_audit_logs_filter(
    input: ListAuditLogsFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.connector_id is not None:
        result["connectorId"] = input.connector_id

    if input.data_plane_id is not None:
        result["dataPlaneId"] = input.data_plane_id

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.gcp_connection_id is not None:
        result["gcpConnectionId"] = input.gcp_connection_id

    if input.gcp_project_id is not None:
        result["gcpProjectId"] = input.gcp_project_id

    if input.azure_connection_id is not None:
        result["azureConnectionId"] = input.azure_connection_id

    if input.azure_subscription_id is not None:
        result["azureSubscriptionId"] = input.azure_subscription_id

    if input.category is not None:
        result["category"] = input.category

    if input.start is not None:
        result["start"] = input.start

    if input.end is not None:
        result["end"] = input.end

    return result


def _serialize_list_dashboard_users_filter(
    input: ListDashboardUsersFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.roles is not None:
        result["roles"] = input.roles

    if input.tenant_id is not None:
        result["tenantId"] = input.tenant_id

    if input.organisation_id is not None:
        result["organisationId"] = input.organisation_id

    if input.departments is not None:
        result["departments"] = input.departments

    if input.enabled is not None:
        result["enabled"] = input.enabled

    return result


def _serialize_list_infotype_categories_filter(
    input: ListInfotypeCategoriesFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.categories is not None:
        result["categories"] = input.categories

    return result


def _serialize_management_method(
    input: ManagementMethod, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["methodType"] = input.method_type

    if input.email is not None:
        result["email"] = input.email

    if input.postal_address is not None:
        result["postalAddress"] = _serialize_postal_address(
            input.postal_address, config
        )

    return result


def _serialize_management_method_collection(
    input: list[ManagementMethod], config: Config
) -> list[DocumentValue]:
    return [_serialize_management_method(e, config) for e in input]


def _serialize_missing_dpia_field_options(
    input: MissingDpiaFieldOptions, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.missing_privacy_ops_field_options is not None:
        result["missingPrivacyOpsFieldOptions"] = (
            _serialize_missing_privacy_ops_field_options_list(
                input.missing_privacy_ops_field_options, config
            )
        )

    return result


def _serialize_missing_dpia_objects(
    input: MissingDpiaObjects, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.availability is not None:
        result["availability"] = _serialize_missing_dpia_field_options(
            input.availability, config
        )

    if input.integrity is not None:
        result["integrity"] = _serialize_missing_dpia_field_options(
            input.integrity, config
        )

    if input.confidentiality is not None:
        result["confidentiality"] = _serialize_missing_dpia_field_options(
            input.confidentiality, config
        )

    return result


def _serialize_missing_object(
    input: MissingObject, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["id"] = input.id

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_missing_object_list(
    input: list[MissingObject], config: Config
) -> list[DocumentValue]:
    return [_serialize_missing_object(e, config) for e in input]


def _serialize_missing_privacy_ops_field_options(
    input: MissingPrivacyOpsFieldOptions, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.type is not None:
        result["type"] = input.type

    if input.missing_options is not None:
        result["missingOptions"] = _serialize_missing_object_list(
            input.missing_options, config
        )

    return result


def _serialize_missing_privacy_ops_field_options_list(
    input: list[MissingPrivacyOpsFieldOptions], config: Config
) -> list[DocumentValue]:
    return [_serialize_missing_privacy_ops_field_options(e, config) for e in input]


def _serialize_missing_processing_activity_objects(
    input: MissingProcessingActivityObjects, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["missingDepartments"] = _serialize_missing_object_list(
        input.missing_departments, config
    )

    result["missingRecipients"] = _serialize_missing_object_list(
        input.missing_recipients, config
    )

    result["missingAssets"] = _serialize_missing_object_list(
        input.missing_assets, config
    )

    result["missingPrivacyOpsFieldOptions"] = (
        _serialize_missing_privacy_ops_field_options_list(
            input.missing_privacy_ops_field_options, config
        )
    )

    result["missingInfoTypes"] = _serialize_missing_object_list(
        input.missing_info_types, config
    )

    return result


def _serialize_postal_address(
    input: PostalAddress, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["street"] = input.street

    result["city"] = input.city

    result["country"] = input.country

    result["zipcode"] = input.zipcode

    return result


def _serialize_processing_activity_export_filters(
    input: ProcessingActivityExportFilters, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.processing_activity_id is not None:
        result["processingActivityId"] = input.processing_activity_id

    if input.status is not None:
        result["status"] = input.status

    if input.departments is not None:
        result["departments"] = input.departments

    if input.data_subjects is not None:
        result["dataSubjects"] = input.data_subjects

    if input.employees is not None:
        result["employees"] = input.employees

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    if input.owners is not None:
        result["owners"] = input.owners

    if input.recipients is not None:
        result["recipients"] = input.recipients

    if input.search is not None:
        result["search"] = input.search

    return result


def _serialize_processing_activity_recipient(
    input: ProcessingActivityRecipient, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["recipientId"] = input.recipient_id

    result["role"] = input.role

    if input.comment is not None:
        result["comment"] = input.comment

    return result


def _serialize_processing_activity_select_filter(
    input: ProcessingActivitySelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.departments is not None:
        result["departments"] = input.departments

    if input.assets is not None:
        result["assets"] = input.assets

    if input.owners is not None:
        result["owners"] = input.owners

    if input.status is not None:
        result["status"] = input.status

    if input.recipients is not None:
        result["recipients"] = input.recipients

    if input.data_types is not None:
        result["dataTypes"] = input.data_types

    if input.infotypes is not None:
        result["infotypes"] = input.infotypes

    if input.infotype_categories is not None:
        result["infotypeCategories"] = input.infotype_categories

    if input.employees is not None:
        result["employees"] = input.employees

    if input.data_subjects is not None:
        result["dataSubjects"] = input.data_subjects

    if input.data_sources is not None:
        result["dataSources"] = input.data_sources

    if input.languages is not None:
        result["languages"] = input.languages

    if input.company_roles is not None:
        result["companyRoles"] = input.company_roles

    if input.pa_as_data_source is not None:
        result["paAsDataSource"] = input.pa_as_data_source

    return result


def _serialize_recipient_collection(
    input: list[ProcessingActivityRecipient], config: Config
) -> list[DocumentValue]:
    return [_serialize_processing_activity_recipient(e, config) for e in input]


def _serialize_recipient_filters(
    input: RecipientFilters, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.discovery_source is not None:
        result["discoverySource"] = input.discovery_source

    if input.categories is not None:
        result["categories"] = input.categories

    if input.role is not None:
        result["role"] = input.role

    if input.used_in is not None:
        result["usedIn"] = _serialize_used_in_filter(input.used_in, config)

    if input.recipient_ids is not None:
        result["recipientIds"] = input.recipient_ids

    if input.sub_processor_ids is not None:
        result["subProcessorIds"] = input.sub_processor_ids

    if input.automation_status is not None:
        result["automationStatus"] = input.automation_status

    if input.with_no_processing_activity is not None:
        result["withNoProcessingActivity"] = input.with_no_processing_activity

    if input.departments is not None:
        result["departments"] = input.departments

    if input.status is not None:
        result["status"] = input.status

    if input.recipient_warranties is not None:
        result["recipientWarranties"] = input.recipient_warranties

    if input.recipient_state is not None:
        result["recipientState"] = input.recipient_state

    return result


def _serialize_report_select_filter(
    input: ReportSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.type is not None:
        result["type"] = input.type

    if input.frequency is not None:
        result["frequency"] = input.frequency

    return result


def _serialize_resource_based_filter(
    input: ResourceBasedFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.values is not None:
        result["values"] = input.values

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    return result


def _serialize_resource_based_filters(
    input: list[ResourceBasedFilter], config: Config
) -> list[DocumentValue]:
    return [_serialize_resource_based_filter(e, config) for e in input]


def _serialize_resource_lineage_filter(
    input: ResourceLineageFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    if input.upstream_depth is not None:
        result["upstreamDepth"] = input.upstream_depth

    if input.downstream_depth is not None:
        result["downstreamDepth"] = input.downstream_depth

    return result


def _serialize_retention_period(
    input: RetentionPeriod, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.unit is not None:
        result["unit"] = input.unit

    if input.value is not None:
        result["value"] = input.value

    return result


def _serialize_scan_execution_insights_list_filter(
    input: ScanExecutionInsightsListFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.scan_iteration_id is not None:
        result["scanIterationId"] = input.scan_iteration_id

    if input.resource_ids is not None:
        result["resourceIds"] = input.resource_ids

    if input.info_types is not None:
        result["infoTypes"] = _serialize_info_types_combination_filter(
            input.info_types, config
        )

    if input.statuses is not None:
        result["statuses"] = input.statuses

    if input.infotype_confidence is not None:
        result["infotypeConfidence"] = input.infotype_confidence

    return result


def _serialize_scan_filter(
    input: ScanFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.type is not None:
        result["type"] = input.type

    if input.filters is not None:
        result["filters"] = input.filters

    if input.resource_based_filters is not None:
        result["resourceBasedFilters"] = _serialize_resource_based_filters(
            input.resource_based_filters, config
        )

    return result


def _serialize_scan_filter_list(
    input: list[ScanFilter], config: Config
) -> list[DocumentValue]:
    return [_serialize_scan_filter(e, config) for e in input]


def _serialize_scan_iterations_filter(
    input: ScanIterationsFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.scan_id is not None:
        result["scanId"] = input.scan_id

    if input.resource_id is not None:
        result["resourceId"] = input.resource_id

    if input.scan_iteration_id is not None:
        result["scanIterationId"] = input.scan_iteration_id

    return result


def _serialize_scan_limits(
    input: ScanLimits, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.sample_percentage is not None:
        result["samplePercentage"] = limited_serialize_float(input.sample_percentage)

    if input.max_cumulative_data_size_mb is not None:
        result["maxCumulativeDataSizeMb"] = input.max_cumulative_data_size_mb

    if input.items_per_batch is not None:
        result["itemsPerBatch"] = input.items_per_batch

    if input.sample_duration_minutes is not None:
        result["sampleDurationMinutes"] = input.sample_duration_minutes

    return result


def _serialize_scan_resources(
    input: ScanResources, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.project_id is not None:
        result["projectId"] = input.project_id

    if input.region is not None:
        result["region"] = input.region

    if input.regions is not None:
        result["regions"] = input.regions

    if input.search is not None:
        result["search"] = input.search

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    if input.resource_ids is not None:
        result["resourceIds"] = input.resource_ids

    if input.parent_id is not None:
        result["parentId"] = input.parent_id

    if input.account_ids is not None:
        result["accountIds"] = input.account_ids

    if input.parent_ids is not None:
        result["parentIds"] = input.parent_ids

    if input.is_public is not None:
        result["isPublic"] = input.is_public

    if input.is_unencrypted is not None:
        result["isUnencrypted"] = input.is_unencrypted

    if input.tags is not None:
        result["tags"] = _serialize_tag_filter_list(input.tags, config)

    if input.database is not None:
        result["database"] = input.database

    if input.dataset is not None:
        result["dataset"] = input.dataset

    if input.name is not None:
        result["name"] = input.name

    if input.schema is not None:
        result["schema"] = input.schema

    if input.drive_id is not None:
        result["driveId"] = input.drive_id

    if input.zendesk_group_id is not None:
        result["zendeskGroupId"] = input.zendesk_group_id

    if input.google_groups is not None:
        result["googleGroups"] = input.google_groups

    if input.org_unit_id is not None:
        result["orgUnitId"] = input.org_unit_id

    if input.drive_type is not None:
        result["driveType"] = input.drive_type

    if input.info_types is not None:
        result["infoTypes"] = _serialize_info_types_combination_filter(
            input.info_types, config
        )

    if input.is_archived is not None:
        result["isArchived"] = input.is_archived

    if input.is_external is not None:
        result["isExternal"] = input.is_external

    if input.team_id is not None:
        result["teamId"] = input.team_id

    if input.team_name is not None:
        result["teamName"] = input.team_name

    if input.team_url is not None:
        result["teamUrl"] = input.team_url

    if input.is_private is not None:
        result["isPrivate"] = input.is_private

    if input.is_slack_direct_messages is not None:
        result["isSlackDirectMessages"] = input.is_slack_direct_messages

    if input.space_status is not None:
        result["spaceStatus"] = input.space_status

    if input.space_type is not None:
        result["spaceType"] = input.space_type

    if input.excluded_resources is not None:
        result["excludedResources"] = input.excluded_resources

    if input.namespace is not None:
        result["namespace"] = input.namespace

    if input.set is not None:
        result["set"] = input.set

    if input.all is not None:
        result["all"] = input.all

    return result


def _serialize_scan_resource_status_filter(
    input: ScanResourceStatusFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.name is not None:
        result["name"] = input.name

    return result


def _serialize_scan_schedule(
    input: ScanSchedule, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.calendars is not None:
        result["calendars"] = _serialize_calendar_spec_list(input.calendars, config)

    if input.timezone is not None:
        result["timezone"] = input.timezone

    return result


def _serialize_scan_select_filter(
    input: ScanSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.scan_type is not None:
        result["scanType"] = input.scan_type

    if input.connector_id is not None:
        result["connectorId"] = input.connector_id

    if input.resources is not None:
        result["resources"] = input.resources

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    if input.data_plane_name is not None:
        result["dataPlaneName"] = input.data_plane_name

    if input.data_plane_id is not None:
        result["dataPlaneId"] = input.data_plane_id

    if input.status is not None:
        result["status"] = input.status

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.gcp_project_id is not None:
        result["gcpProjectId"] = input.gcp_project_id

    if input.info_types is not None:
        result["infoTypes"] = _serialize_info_types_combination_filter(
            input.info_types, config
        )

    return result


def _serialize_sort_records(
    input: SortRecords, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.column is not None:
        result["column"] = input.column

    if input.order is not None:
        result["order"] = input.order

    return result


def _serialize_tag_entities_filter(
    input: TagEntitiesFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.account_id is not None:
        result["accountId"] = input.account_id

    if input.region is not None:
        result["region"] = input.region

    if input.regions is not None:
        result["regions"] = input.regions

    if input.search is not None:
        result["search"] = input.search

    if input.resource_type is not None:
        result["resourceType"] = input.resource_type

    return result


def _serialize_tag_entity_union(
    input: TagEntityUnion, config: Config
) -> dict[str, DocumentValue]:
    match input:
        case TagEntityUnionFilter():
            return {"filter": _serialize_tag_entities_filter(input.value, config)}

        case TagEntityUnionEntityIds():
            return {"entityIds": input.value}

        case _:
            raise ServiceError(f"Unexpected union variant: {type(input)}")


def _serialize_tag_filter(input: TagFilter, config: Config) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    result["action"] = input.action

    result["tagKey"] = input.tag_key

    if input.tag_value is not None:
        result["tagValue"] = input.tag_value

    return result


def _serialize_tag_filter_list(
    input: list[TagFilter], config: Config
) -> list[DocumentValue]:
    return [_serialize_tag_filter(e, config) for e in input]


def _serialize_time_filter(
    input: dict[str, datetime], config: Config
) -> dict[str, DocumentValue]:
    return {k: serialize_epoch_seconds(ensure_utc(v)) for k, v in input.items()}


def _serialize_tom_select_filter(
    input: TomSelectFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    if input.category is not None:
        result["category"] = input.category

    if input.list_ is not None:
        result["list"] = input.list_

    if input.type is not None:
        result["type"] = input.type

    if input.status is not None:
        result["status"] = input.status

    if input.object_category is not None:
        result["objectCategory"] = input.object_category

    if input.tom_id is not None:
        result["tomId"] = input.tom_id

    return result


def _serialize_used_in_filter(
    input: UsedInFilter, config: Config
) -> dict[str, DocumentValue]:
    match input:
        case UsedInFilterRecipientsWithoutCompletedPA():
            return {"recipientsWithoutCompletedPA": input.value}

        case UsedInFilterRecipientsWithAtleastOnePA():
            return {"recipientsWithAtleastOnePA": input.value}

        case _:
            raise ServiceError(f"Unexpected union variant: {type(input)}")


def _serialize_user_organisation(
    input: UserOrganisation, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.organisation_id is not None:
        result["organisationId"] = input.organisation_id

    result["roles"] = input.roles

    if input.departments is not None:
        result["departments"] = input.departments

    return result


def _serialize_user_organisations(
    input: list[UserOrganisation], config: Config
) -> list[DocumentValue]:
    return [_serialize_user_organisation(e, config) for e in input]


def _serialize_user_profile_filter(
    input: UserProfileFilter, config: Config
) -> dict[str, DocumentValue]:
    result: dict[str, DocumentValue] = {}

    if input.search is not None:
        result["search"] = input.search

    return result
