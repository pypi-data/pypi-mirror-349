# Code generated by smithy-python-codegen DO NOT EDIT.

import json
from typing import Any

from smithy_core.documents import Document, DocumentValue
from smithy_core.utils import (
    epoch_seconds_to_datetime,
    expect_type,
    limited_parse_float,
)
from smithy_http.aio.interfaces import HTTPResponse
from smithy_http.aio.restjson import parse_rest_json_error_info

from .config import Config
from .errors import (
    ApiError,
    DataValidationException,
    NoSuchResource,
    NotAllowed,
    ServiceError,
    Unauthorized,
    UnexpectedServerError,
    UnknownApiError,
    ValidationException,
)
from .models import (
    AccessLogMember,
    AccountListMember,
    AccountPermissions,
    AccountRole,
    AccountRoleValidation,
    AccountStatusDetails,
    ActiveResourcesStats,
    AddDiscoveredRecipientAsRecipientsOutput,
    AddTaDpiaFileOutput,
    AggregateScanStats,
    ArchiveDiscoveredRecipientOutput,
    AssetListRecord,
    AssetRecord,
    CalendarSpec,
    CategoryListMember,
    ChangeInProcessingActivityStatsOutput,
    ClassificationStatsData,
    ClonePaInTargetOrgOutput,
    CloudAccount,
    ComplianceDetail,
    ComplianceRisk,
    ConfidenceSnapshot,
    ConnectorListMember,
    ConnectorStatusDetails,
    CreateAndSendDashboardReportOutput,
    CreateAssetOutput,
    CreateCategoryOutput,
    CreateDashboardReportOutput,
    CreateDashboardUserOutput,
    CreateDataBreachOutput,
    CreateDepartmentOutput,
    CreateDomainOutput,
    CreateDpiaOutput,
    CreateEmployeeOutput,
    CreateFalsePositiveReportOutput,
    CreateHeadquarterOutput,
    CreateLegalDocumentOutput,
    CreateLopdpThresholdOutput,
    CreateProcessingActivityOutput,
    CreateRecipientOutput,
    CreateScanOutput,
    CreateThresholdOutput,
    DashboardReportDelivery,
    DashboardReportEditionListMember,
    DashboardReportListMember,
    DashboardUserRecord,
    DataBreachFilterFilterOutputListMember,
    DataBreachListRecord,
    DataFlowRelationship,
    DataFlowRelationshipOption,
    DataSecurityEvent,
    DataSize,
    DepartmentForFilterMember,
    DepartmentListMember,
    DepartmentObject,
    DescribeAccountOutput,
    DescribeAssetOutput,
    DescribeCatalogResourceOutput,
    DescribeCategoryOutput,
    DescribeCloudAccountOutput,
    DescribeConnectorOutput,
    DescribeCurrentUserOutput,
    DescribeDashboardReportEditionOutput,
    DescribeDashboardReportOutput,
    DescribeDataBreachEvaluationOutput,
    DescribeDataBreachOutput,
    DescribeDepartmentOutput,
    DescribeDiscoveredDocumentOutput,
    DescribeDiscoveredInfotypesOutput,
    DescribeDiscoveredRecipientOutput,
    DescribeDomainOutput,
    DescribeDpiaOutput,
    DescribeEmployeeOutput,
    DescribeErrorOutput,
    DescribeHeadquarterOutput,
    DescribeInspectionResultOutput,
    DescribeInventoryResourceOutput,
    DescribeIssueOutput,
    DescribeLegalDocumentOutput,
    DescribeLopdpThresholdOutput,
    DescribeProcessingActivityOutput,
    DescribeRecipientOutput,
    DescribeResourceLineageOutput,
    DescribeScanIterationOutput,
    DescribeScanOutput,
    DescribeThresholdOutput,
    DescribeTomOutput,
    DescribeUserProfileOutput,
    DisableDashboardUserOutput,
    DiscoveredDocumentsListMember,
    DiscoveredInfotypesListMember,
    DiscoveredRecipientListMember,
    DomainListMember,
    DownloadDashboardReportEditionOutput,
    DownloadDashboardReportForSuperAdminOutput,
    DownloadDashboardReportOutput,
    DpiaAvailabilityRisk,
    DpiaAvailabilityRiskImpact,
    DpiaAvailabilityRiskThreat,
    DpiaConfidentialityRisk,
    DpiaConfidentialityRiskImpact,
    DpiaConfidentialityRiskThreat,
    DpiaIntegrityRisk,
    DpiaIntegrityRiskImpact,
    DpiaIntegrityRiskThreat,
    DpiaPrivacyFramework,
    DpiaRiskRiskSource,
    EmployeeForFilterMember,
    EmployeeListMember,
    EnableDashboardUserOutput,
    ErrorRecord,
    Events,
    ExportedDataUrl,
    FalsePositiveReport,
    FileInfo,
    GetChatbotResponseOutput,
    HeadquarterListRecord,
    HeadquarterRecord,
    InfoTypesCombinationFilter,
    InfotypeSnapshot,
    InspectionPolicy,
    InspectionResultRecord,
    IssueNotification,
    IssueRecord,
    IssueResourceDetails,
    LawfulBasis,
    LeafResourceParent,
    LeafResourcesDataRecordMember,
    LegalDocumentListMember,
    ListAccessLogsOutput,
    ListAccountsOutput,
    ListActiveResourceTimelineOutput,
    ListAssetsOutput,
    ListAuditLogsOutput,
    ListAutoSuggestionsOutput,
    ListCatalogLeafResourcesExportOutput,
    ListCatalogLeafResourcesOutput,
    ListColumnsForResourcesOutput,
    ListConnectorsOutput,
    ListDashboardUsersOutput,
    ListDataBreachFilterOutput,
    ListDataBreachOutput,
    ListDepartmentsForFilterOutput,
    ListDepartmentsOutput,
    ListDiscoveredDocumentsOutput,
    ListDiscoveredInfotypesOutput,
    ListDiscoveredRecipientsOutput,
    ListDiscoveredRecipientsUsersOutput,
    ListDomainsOutput,
    ListEmployeesForFilterOutput,
    ListEmployeesOutput,
    ListErrorsOutput,
    ListEventsOutput,
    ListHeadquartersOutput,
    ListInfotypeCategoriesOutput,
    ListInsightsFilterOutput,
    ListInsightsFilterValueParameter,
    ListInspectionResultsOutput,
    ListInventoryResourcesExportOutput,
    ListInventoryResourcesOutput,
    ListIssuesOutput,
    ListLegalDocumentsOutput,
    ListProcessingActivitiesExportOutput,
    ListProcessingActivitiesOfRecipientOutput,
    ListProcessingActivitiesOutput,
    ListProcessingActivityFilterMember,
    ListProcessingActivityFilterOutput,
    ListRecipientFilterOutput,
    ListRecipientsExportOutput,
    ListRecipientsForFilterOutput,
    ListRecipientsOutput,
    ListReportSchedulesOutput,
    ListReportsEditionOutput,
    ListScanExecutionInsightsOutput,
    ListScanIterationsOutput,
    ListScanResourceStatusOutput,
    ListScansOutput,
    ListTomsOutput,
    ListTopResourcesWithSensitiveDataDetailsOutput,
    ListUserProfilesOutput,
    ManagementMethod,
    ManagerObject,
    MissingDpiaFieldOptions,
    MissingDpiaObjects,
    MissingObject,
    MissingPrivacyOpsFieldOptions,
    MissingProcessingActivityObjects,
    OktaUserDiscoveryListMember,
    OwnerObject,
    PaStatsTimeSeriesOutput,
    PaStatsTimeSeriesPoint,
    PageInsightsExportOutput,
    PauseScanOutput,
    PollDomainOutput,
    PostalAddress,
    PrepareDetailedInspectionResultOutput,
    ProcessingActivityDepartment,
    ProcessingActivityEmployee,
    ProcessingActivityListRecord,
    ProcessingActivityOfRecipientMember,
    ProcessingActivityRecipientMember,
    RecipientFilterOutputListMember,
    RecipientForFilterMember,
    RecipientListMember,
    RemoveAssetOutput,
    RemoveCategoryOutput,
    RemoveDashboardReportOutput,
    RemoveDashboardUserOutput,
    RemoveDataBreachEvaluationOutput,
    RemoveDataBreachOutput,
    RemoveDepartmentOutput,
    RemoveDomainOutput,
    RemoveDpiaOutput,
    RemoveEmployeeOutput,
    RemoveHeadquarterOutput,
    RemoveLegalDocumentOutput,
    RemoveLopdpThresholdOutput,
    RemoveProcessingActivityOutput,
    RemoveRecipientOutput,
    RemoveTaDpiaFileOutput,
    RemoveThresholdOutput,
    ResetPasswordDashboardUserOutput,
    ResourceBasedFilter,
    ResourceColumns,
    ResourceDataStats,
    ResourceInventoryListMember,
    ResourceLineageData,
    ResourceLineageEdge,
    ResourceParent,
    ResourceRecord,
    ResourceSensitiveDataDetails,
    ResourceStatsData,
    ResourceTrends,
    ResourceTypeScanStats,
    ResourceWithName,
    ResumeScanOutput,
    RetentionPeriod,
    SampleTokens,
    ScanDataProcessed,
    ScanDetail,
    ScanExecutionRecord,
    ScanFilter,
    ScanInformation,
    ScanIterationRecord,
    ScanIterationStats,
    ScanLegalDocumentOutput,
    ScanLimits,
    ScanMeta,
    ScanParameters,
    ScanRecord,
    ScanResources,
    ScanSchedule,
    ScanStats,
    ScanStatusCount,
    SecurityRisk,
    SeverityCount,
    SortRecords,
    StateChangeEvents,
    StopScanOutput,
    Suggestion,
    SummarizeClassificationStatsOutput,
    SummarizeDataIdentifierStatsOutput,
    SummarizeDataStatsOutput,
    SummarizePaStatsForOwnersOutput,
    SummarizeProcessingActivityStatsOutput,
    SummarizeResourceStatsOutput,
    SummarizeResourceTrendsOutput,
    SummarizeResourceTypeDataIdentifierCountsOutput,
    SummarizeScanStatsOutput,
    SummaryScanStats,
    TagFilter,
    TaggingResult,
    TomListMember,
    UntagEntitiesOutput,
    UpdateAssetOutput,
    UpdateCategoryOutput,
    UpdateDashboardReportOutput,
    UpdateDashboardUserOutput,
    UpdateDashboardUserRolesOutput,
    UpdateDataBreachEvaluationOutput,
    UpdateDataBreachOutput,
    UpdateDepartmentOutput,
    UpdateDiscoveredDocumentOutput,
    UpdateDiscoveredInfotypesOutput,
    UpdateDomainOutput,
    UpdateDpiaOutput,
    UpdateEmployeeOutput,
    UpdateHeadquarterOutput,
    UpdateLopdpThresholdOutput,
    UpdateProcessingActivityOutput,
    UpdateRecipientOutput,
    UpdateRecipientStatusOutput,
    UpdateTaDpiaFileOutput,
    UpdateThresholdOutput,
    UpdateTomOutput,
    UpdatefeedbackOutput,
    UserOrganisation,
    UserProfileRecord,
    ValidateClonePaForTargetOrgOutput,
    ValidationExceptionField,
    VerifyEmailOutput,
)


async def _deserialize_add_discovered_recipient_as_recipients(
    http_response: HTTPResponse, config: Config
) -> AddDiscoveredRecipientAsRecipientsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_add_discovered_recipient_as_recipients(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_recipient_ids := output.get("recipientIds")) is not None:
        kwargs["recipient_ids"] = _deserialize_uuid_collection(_recipient_ids, config)

    return AddDiscoveredRecipientAsRecipientsOutput(**kwargs)


async def _deserialize_error_add_discovered_recipient_as_recipients(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_add_ta_dpia_file(
    http_response: HTTPResponse, config: Config
) -> AddTaDpiaFileOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_add_ta_dpia_file(http_response, config)

    kwargs: dict[str, Any] = {}

    return AddTaDpiaFileOutput(**kwargs)


async def _deserialize_error_add_ta_dpia_file(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_archive_discovered_recipient(
    http_response: HTTPResponse, config: Config
) -> ArchiveDiscoveredRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_archive_discovered_recipient(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    return ArchiveDiscoveredRecipientOutput(**kwargs)


async def _deserialize_error_archive_discovered_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_clone_pa_in_target_org(
    http_response: HTTPResponse, config: Config
) -> ClonePaInTargetOrgOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_clone_pa_in_target_org(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "clonedPaId" not in output:
        raise ServiceError(
            'Expected to find "clonedPaId" in the operation output, but it was not present.'
        )
    kwargs["cloned_pa_id"] = expect_type(str, output["clonedPaId"])

    return ClonePaInTargetOrgOutput(**kwargs)


async def _deserialize_error_clone_pa_in_target_org(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_and_send_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> CreateAndSendDashboardReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_and_send_dashboard_report(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    return CreateAndSendDashboardReportOutput(**kwargs)


async def _deserialize_error_create_and_send_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_asset(
    http_response: HTTPResponse, config: Config
) -> CreateAssetOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_asset(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "assetId" not in output:
        raise ServiceError(
            'Expected to find "assetId" in the operation output, but it was not present.'
        )
    kwargs["asset_id"] = expect_type(str, output["assetId"])

    return CreateAssetOutput(**kwargs)


async def _deserialize_error_create_asset(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_category(
    http_response: HTTPResponse, config: Config
) -> CreateCategoryOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_category(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "categoryLabel" not in output:
        raise ServiceError(
            'Expected to find "categoryLabel" in the operation output, but it was not present.'
        )
    kwargs["category_label"] = expect_type(str, output["categoryLabel"])

    return CreateCategoryOutput(**kwargs)


async def _deserialize_error_create_category(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> CreateDashboardReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_dashboard_report(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "dashboardReportId" not in output:
        raise ServiceError(
            'Expected to find "dashboardReportId" in the operation output, but it was not present.'
        )
    kwargs["dashboard_report_id"] = expect_type(str, output["dashboardReportId"])

    return CreateDashboardReportOutput(**kwargs)


async def _deserialize_error_create_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> CreateDashboardUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_dashboard_user(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "username" not in output:
        raise ServiceError(
            'Expected to find "username" in the operation output, but it was not present.'
        )
    kwargs["username"] = expect_type(str, output["username"])

    if (_updated := output.get("updated")) is not None:
        kwargs["updated"] = expect_type(bool, _updated)

    return CreateDashboardUserOutput(**kwargs)


async def _deserialize_error_create_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_data_breach(
    http_response: HTTPResponse, config: Config
) -> CreateDataBreachOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_data_breach(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "dataBreachId" not in output:
        raise ServiceError(
            'Expected to find "dataBreachId" in the operation output, but it was not present.'
        )
    kwargs["data_breach_id"] = expect_type(str, output["dataBreachId"])

    return CreateDataBreachOutput(**kwargs)


async def _deserialize_error_create_data_breach(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_department(
    http_response: HTTPResponse, config: Config
) -> CreateDepartmentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_department(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    return CreateDepartmentOutput(**kwargs)


async def _deserialize_error_create_department(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_domain(
    http_response: HTTPResponse, config: Config
) -> CreateDomainOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_domain(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "domainId" not in output:
        raise ServiceError(
            'Expected to find "domainId" in the operation output, but it was not present.'
        )
    kwargs["domain_id"] = expect_type(str, output["domainId"])

    return CreateDomainOutput(**kwargs)


async def _deserialize_error_create_domain(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_dpia(
    http_response: HTTPResponse, config: Config
) -> CreateDpiaOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_dpia(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "dpiaId" not in output:
        raise ServiceError(
            'Expected to find "dpiaId" in the operation output, but it was not present.'
        )
    kwargs["dpia_id"] = expect_type(str, output["dpiaId"])

    return CreateDpiaOutput(**kwargs)


async def _deserialize_error_create_dpia(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_employee(
    http_response: HTTPResponse, config: Config
) -> CreateEmployeeOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_employee(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    return CreateEmployeeOutput(**kwargs)


async def _deserialize_error_create_employee(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_false_positive_report(
    http_response: HTTPResponse, config: Config
) -> CreateFalsePositiveReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_false_positive_report(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_false_positive_reports := output.get("falsePositiveReports")) is not None:
        kwargs["false_positive_reports"] = _deserialize_false_positive_report_list(
            _false_positive_reports, config
        )

    return CreateFalsePositiveReportOutput(**kwargs)


async def _deserialize_error_create_false_positive_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_headquarter(
    http_response: HTTPResponse, config: Config
) -> CreateHeadquarterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_headquarter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "headquarterId" not in output:
        raise ServiceError(
            'Expected to find "headquarterId" in the operation output, but it was not present.'
        )
    kwargs["headquarter_id"] = expect_type(str, output["headquarterId"])

    return CreateHeadquarterOutput(**kwargs)


async def _deserialize_error_create_headquarter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_legal_document(
    http_response: HTTPResponse, config: Config
) -> CreateLegalDocumentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_legal_document(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "documentId" not in output:
        raise ServiceError(
            'Expected to find "documentId" in the operation output, but it was not present.'
        )
    kwargs["document_id"] = expect_type(str, output["documentId"])

    return CreateLegalDocumentOutput(**kwargs)


async def _deserialize_error_create_legal_document(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> CreateLopdpThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_lopdp_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "lopdpThresholdId" not in output:
        raise ServiceError(
            'Expected to find "lopdpThresholdId" in the operation output, but it was not present.'
        )
    kwargs["lopdp_threshold_id"] = expect_type(str, output["lopdpThresholdId"])

    return CreateLopdpThresholdOutput(**kwargs)


async def _deserialize_error_create_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_processing_activity(
    http_response: HTTPResponse, config: Config
) -> CreateProcessingActivityOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_processing_activity(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "processingActivityId" not in output:
        raise ServiceError(
            'Expected to find "processingActivityId" in the operation output, but it was not present.'
        )
    kwargs["processing_activity_id"] = expect_type(str, output["processingActivityId"])

    return CreateProcessingActivityOutput(**kwargs)


async def _deserialize_error_create_processing_activity(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_recipient(
    http_response: HTTPResponse, config: Config
) -> CreateRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_recipient(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "recipientId" not in output:
        raise ServiceError(
            'Expected to find "recipientId" in the operation output, but it was not present.'
        )
    kwargs["recipient_id"] = expect_type(str, output["recipientId"])

    return CreateRecipientOutput(**kwargs)


async def _deserialize_error_create_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_scan(
    http_response: HTTPResponse, config: Config
) -> CreateScanOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_scan(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "scanId" not in output:
        raise ServiceError(
            'Expected to find "scanId" in the operation output, but it was not present.'
        )
    kwargs["scan_id"] = expect_type(str, output["scanId"])

    return CreateScanOutput(**kwargs)


async def _deserialize_error_create_scan(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_create_threshold(
    http_response: HTTPResponse, config: Config
) -> CreateThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "thresholdId" not in output:
        raise ServiceError(
            'Expected to find "thresholdId" in the operation output, but it was not present.'
        )
    kwargs["threshold_id"] = expect_type(str, output["thresholdId"])

    return CreateThresholdOutput(**kwargs)


async def _deserialize_error_create_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_account(
    http_response: HTTPResponse, config: Config
) -> DescribeAccountOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_account(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_cloud_account_id := output.get("cloudAccountId")) is not None:
        kwargs["cloud_account_id"] = expect_type(str, _cloud_account_id)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_account_roles(_roles, config)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if "accountId" not in output:
        raise ServiceError(
            'Expected to find "accountId" in the operation output, but it was not present.'
        )
    kwargs["account_id"] = expect_type(str, output["accountId"])

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_permissions := output.get("permissions")) is not None:
        kwargs["permissions"] = _deserialize_account_permissions(_permissions, config)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_status_details := output.get("statusDetails")) is not None:
        kwargs["status_details"] = _deserialize_account_status_details(
            _status_details, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DescribeAccountOutput(**kwargs)


async def _deserialize_error_describe_account(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_asset(
    http_response: HTTPResponse, config: Config
) -> DescribeAssetOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_asset(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_tom_ids := output.get("tomIds")) is not None:
        kwargs["tom_ids"] = _deserialize_uuid_collection(_tom_ids, config)

    if (_location_type := output.get("locationType")) is not None:
        kwargs["location_type"] = expect_type(str, _location_type)

    if (_location := output.get("location")) is not None:
        kwargs["location"] = _deserialize_headquarter_record(_location, config)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    if (_location_id := output.get("locationId")) is not None:
        kwargs["location_id"] = expect_type(str, _location_id)

    if "assetId" not in output:
        raise ServiceError(
            'Expected to find "assetId" in the operation output, but it was not present.'
        )
    kwargs["asset_id"] = expect_type(str, output["assetId"])

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    return DescribeAssetOutput(**kwargs)


async def _deserialize_error_describe_asset(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_catalog_resource(
    http_response: HTTPResponse, config: Config
) -> DescribeCatalogResourceOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_catalog_resource(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_sample_tokens := output.get("sampleTokens")) is not None:
        kwargs["sample_tokens"] = _deserialize_tokens(_sample_tokens, config)

    if (_parent := output.get("parent")) is not None:
        kwargs["parent"] = _deserialize_resource_parent(_parent, config)

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if (_last_scanned := output.get("lastScanned")) is not None:
        kwargs["last_scanned"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scanned)
        )

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    return DescribeCatalogResourceOutput(**kwargs)


async def _deserialize_error_describe_catalog_resource(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_category(
    http_response: HTTPResponse, config: Config
) -> DescribeCategoryOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_category(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "description" not in output:
        raise ServiceError(
            'Expected to find "description" in the operation output, but it was not present.'
        )
    kwargs["description"] = expect_type(str, output["description"])

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if "categoryLabel" not in output:
        raise ServiceError(
            'Expected to find "categoryLabel" in the operation output, but it was not present.'
        )
    kwargs["category_label"] = expect_type(str, output["categoryLabel"])

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    return DescribeCategoryOutput(**kwargs)


async def _deserialize_error_describe_category(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_cloud_account(
    http_response: HTTPResponse, config: Config
) -> DescribeCloudAccountOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_cloud_account(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "accountId" not in output:
        raise ServiceError(
            'Expected to find "accountId" in the operation output, but it was not present.'
        )
    kwargs["account_id"] = expect_type(str, output["accountId"])

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_permissions := output.get("permissions")) is not None:
        kwargs["permissions"] = _deserialize_account_permissions(_permissions, config)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_status_details := output.get("statusDetails")) is not None:
        kwargs["status_details"] = _deserialize_account_status_details(
            _status_details, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_cloud_account_id := output.get("cloudAccountId")) is not None:
        kwargs["cloud_account_id"] = expect_type(str, _cloud_account_id)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_account_roles(_roles, config)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    return DescribeCloudAccountOutput(**kwargs)


async def _deserialize_error_describe_cloud_account(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_connector(
    http_response: HTTPResponse, config: Config
) -> DescribeConnectorOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_connector(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_params := output.get("params")) is not None:
        kwargs["params"] = _deserialize_open_properties(_params, config)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if "connectorId" not in output:
        raise ServiceError(
            'Expected to find "connectorId" in the operation output, but it was not present.'
        )
    kwargs["connector_id"] = expect_type(str, output["connectorId"])

    if (_resource_account_id := output.get("resourceAccountId")) is not None:
        kwargs["resource_account_id"] = expect_type(str, _resource_account_id)

    if (_status_details := output.get("statusDetails")) is not None:
        kwargs["status_details"] = _deserialize_connector_status_details(
            _status_details, config
        )

    if (_gcp_connection_id := output.get("gcpConnectionId")) is not None:
        kwargs["gcp_connection_id"] = expect_type(str, _gcp_connection_id)

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    if (_data_plane_id := output.get("dataPlaneId")) is not None:
        kwargs["data_plane_id"] = expect_type(str, _data_plane_id)

    if (
        _custom_meta_data_sync_interval := output.get("customMetaDataSyncInterval")
    ) is not None:
        kwargs["custom_meta_data_sync_interval"] = expect_type(
            str, _custom_meta_data_sync_interval
        )

    if (_connector_type := output.get("connectorType")) is not None:
        kwargs["connector_type"] = expect_type(str, _connector_type)

    if (_meta_data_sync_interval := output.get("metaDataSyncInterval")) is not None:
        kwargs["meta_data_sync_interval"] = expect_type(str, _meta_data_sync_interval)

    if (
        _next_meta_data_sync_schedule := output.get("nextMetaDataSyncSchedule")
    ) is not None:
        kwargs["next_meta_data_sync_schedule"] = epoch_seconds_to_datetime(
            expect_type(int | float, _next_meta_data_sync_schedule)
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_is_meta_data_sync_running := output.get("isMetaDataSyncRunning")) is not None:
        kwargs["is_meta_data_sync_running"] = expect_type(
            bool, _is_meta_data_sync_running
        )

    return DescribeConnectorOutput(**kwargs)


async def _deserialize_error_describe_connector(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_current_user(
    http_response: HTTPResponse, config: Config
) -> DescribeCurrentUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_current_user(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_dashboard_user_roles(_roles, config)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    if (_super_admin := output.get("superAdmin")) is not None:
        kwargs["super_admin"] = expect_type(bool, _super_admin)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if "username" not in output:
        raise ServiceError(
            'Expected to find "username" in the operation output, but it was not present.'
        )
    kwargs["username"] = expect_type(str, output["username"])

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_company_name := output.get("companyName")) is not None:
        kwargs["company_name"] = expect_type(str, _company_name)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_external_provider := output.get("externalProvider")) is not None:
        kwargs["external_provider"] = expect_type(bool, _external_provider)

    if (_enabled := output.get("enabled")) is not None:
        kwargs["enabled"] = expect_type(bool, _enabled)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_provider := output.get("provider")) is not None:
        kwargs["provider"] = expect_type(str, _provider)

    if (_organisations := output.get("organisations")) is not None:
        kwargs["organisations"] = _deserialize_user_organisations(
            _organisations, config
        )

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    return DescribeCurrentUserOutput(**kwargs)


async def _deserialize_error_describe_current_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> DescribeDashboardReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_dashboard_report(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_external_email := output.get("externalEmail")) is not None:
        kwargs["external_email"] = _deserialize_report_recipients(
            _external_email, config
        )

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_report_recipients_roles(_roles, config)

    if (_report_types := output.get("reportTypes")) is not None:
        kwargs["report_types"] = _deserialize_report_type_list(_report_types, config)

    if (_recipients_email := output.get("recipientsEmail")) is not None:
        kwargs["recipients_email"] = _deserialize_report_recipients(
            _recipients_email, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_next_send_time := output.get("nextSendTime")) is not None:
        kwargs["next_send_time"] = epoch_seconds_to_datetime(
            expect_type(int | float, _next_send_time)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_frequency := output.get("frequency")) is not None:
        kwargs["frequency"] = expect_type(str, _frequency)

    if (_last_sent_time := output.get("lastSentTime")) is not None:
        kwargs["last_sent_time"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_sent_time)
        )

    if "dashboardReportId" not in output:
        raise ServiceError(
            'Expected to find "dashboardReportId" in the operation output, but it was not present.'
        )
    kwargs["dashboard_report_id"] = expect_type(str, output["dashboardReportId"])

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_report_edition := output.get("reportEdition")) is not None:
        kwargs["report_edition"] = _deserialize_dashboard_report_edition_list(
            _report_edition, config
        )

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    return DescribeDashboardReportOutput(**kwargs)


async def _deserialize_error_describe_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_dashboard_report_edition(
    http_response: HTTPResponse, config: Config
) -> DescribeDashboardReportEditionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_dashboard_report_edition(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_frequency := output.get("frequency")) is not None:
        kwargs["frequency"] = expect_type(str, _frequency)

    if (_dashboard_report_id := output.get("dashboardReportId")) is not None:
        kwargs["dashboard_report_id"] = expect_type(str, _dashboard_report_id)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if "reportEditionId" not in output:
        raise ServiceError(
            'Expected to find "reportEditionId" in the operation output, but it was not present.'
        )
    kwargs["report_edition_id"] = expect_type(str, output["reportEditionId"])

    if (_recipients_count := output.get("recipientsCount")) is not None:
        kwargs["recipients_count"] = expect_type(int, _recipients_count)

    if (_report_delivery := output.get("reportDelivery")) is not None:
        kwargs["report_delivery"] = _deserialize_dashboard_report_delivery_list(
            _report_delivery, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    return DescribeDashboardReportEditionOutput(**kwargs)


async def _deserialize_error_describe_dashboard_report_edition(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_data_breach(
    http_response: HTTPResponse, config: Config
) -> DescribeDataBreachOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_data_breach(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_translations := output.get("translations")) is not None:
        kwargs["translations"] = _deserialize_field_translations(_translations, config)

    if (_affected_people_from := output.get("affectedPeopleFrom")) is not None:
        kwargs["affected_people_from"] = expect_type(str, _affected_people_from)

    if (_was_intentional := output.get("wasIntentional")) is not None:
        kwargs["was_intentional"] = expect_type(str, _was_intentional)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_profile_people_affected := output.get("profilePeopleAffected")) is not None:
        kwargs["profile_people_affected"] = expect_type(str, _profile_people_affected)

    if "dataBreachId" not in output:
        raise ServiceError(
            'Expected to find "dataBreachId" in the operation output, but it was not present.'
        )
    kwargs["data_breach_id"] = expect_type(str, output["dataBreachId"])

    if (
        _security_measures_or_protocols := output.get("securityMeasuresOrProtocols")
    ) is not None:
        kwargs["security_measures_or_protocols"] = expect_type(
            str, _security_measures_or_protocols
        )

    if (_people_informed := output.get("peopleInformed")) is not None:
        kwargs["people_informed"] = expect_type(str, _people_informed)

    if (
        _problem_of_security_measures := output.get("problemOfSecurityMeasures")
    ) is not None:
        kwargs["problem_of_security_measures"] = expect_type(
            str, _problem_of_security_measures
        )

    if "shortDescription" not in output:
        raise ServiceError(
            'Expected to find "shortDescription" in the operation output, but it was not present.'
        )
    kwargs["short_description"] = expect_type(str, output["shortDescription"])

    if (_measures_to_prevent := output.get("measuresToPrevent")) is not None:
        kwargs["measures_to_prevent"] = expect_type(str, _measures_to_prevent)

    if (_kind_of_data := output.get("kindOfData")) is not None:
        kwargs["kind_of_data"] = expect_type(str, _kind_of_data)

    if (_evaluated_by := output.get("evaluatedBy")) is not None:
        kwargs["evaluated_by"] = expect_type(str, _evaluated_by)

    if (_occurred_at := output.get("occurredAt")) is not None:
        kwargs["occurred_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _occurred_at)
        )

    if (_description := output.get("description")) is not None:
        kwargs["description"] = expect_type(str, _description)

    if "sequence" not in output:
        raise ServiceError(
            'Expected to find "sequence" in the operation output, but it was not present.'
        )
    kwargs["sequence"] = expect_type(int, output["sequence"])

    if (_discovered_at := output.get("discoveredAt")) is not None:
        kwargs["discovered_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _discovered_at)
        )

    if (_authorities_informed := output.get("authoritiesInformed")) is not None:
        kwargs["authorities_informed"] = expect_type(str, _authorities_informed)

    if (_number_affected_people := output.get("numberAffectedPeople")) is not None:
        kwargs["number_affected_people"] = expect_type(int, _number_affected_people)

    if (
        _compromised_sensitive_data := output.get("compromisedSensitiveData")
    ) is not None:
        kwargs["compromised_sensitive_data"] = expect_type(
            str, _compromised_sensitive_data
        )

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_consequences := output.get("consequences")) is not None:
        kwargs["consequences"] = expect_type(str, _consequences)

    if (_additional_information := output.get("additionalInformation")) is not None:
        kwargs["additional_information"] = _deserialize_uuid_collection(
            _additional_information, config
        )

    if (_how_discovered := output.get("howDiscovered")) is not None:
        kwargs["how_discovered"] = expect_type(str, _how_discovered)

    return DescribeDataBreachOutput(**kwargs)


async def _deserialize_error_describe_data_breach(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_data_breach_evaluation(
    http_response: HTTPResponse, config: Config
) -> DescribeDataBreachEvaluationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_data_breach_evaluation(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_data_subjects_notified := output.get("dataSubjectsNotified")) is not None:
        kwargs["data_subjects_notified"] = expect_type(bool, _data_subjects_notified)

    if (_data_breach_location := output.get("dataBreachLocation")) is not None:
        kwargs["data_breach_location"] = expect_type(str, _data_breach_location)

    if (_companies_affected := output.get("companiesAffected")) is not None:
        kwargs["companies_affected"] = expect_type(str, _companies_affected)

    if (_processor_notified := output.get("processorNotified")) is not None:
        kwargs["processor_notified"] = expect_type(bool, _processor_notified)

    if (_data_breach_controller := output.get("dataBreachController")) is not None:
        kwargs["data_breach_controller"] = expect_type(str, _data_breach_controller)

    if (_role := output.get("role")) is not None:
        kwargs["role"] = expect_type(str, _role)

    if (_authorities_notified := output.get("authoritiesNotified")) is not None:
        kwargs["authorities_notified"] = expect_type(bool, _authorities_notified)

    if (_processors_involved := output.get("processorsInvolved")) is not None:
        kwargs["processors_involved"] = expect_type(str, _processors_involved)

    if (_evaluation := output.get("evaluation")) is not None:
        kwargs["evaluation"] = expect_type(str, _evaluation)

    if (_report_language := output.get("reportLanguage")) is not None:
        kwargs["report_language"] = expect_type(str, _report_language)

    if (_evaluated_by := output.get("evaluatedBy")) is not None:
        kwargs["evaluated_by"] = expect_type(str, _evaluated_by)

    return DescribeDataBreachEvaluationOutput(**kwargs)


async def _deserialize_error_describe_data_breach_evaluation(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_department(
    http_response: HTTPResponse, config: Config
) -> DescribeDepartmentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_department(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    return DescribeDepartmentOutput(**kwargs)


async def _deserialize_error_describe_department(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_discovered_document(
    http_response: HTTPResponse, config: Config
) -> DescribeDiscoveredDocumentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_discovered_document(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_domain_id := output.get("domainId")) is not None:
        kwargs["domain_id"] = expect_type(str, _domain_id)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_document_name := output.get("documentName")) is not None:
        kwargs["document_name"] = expect_type(str, _document_name)

    if (_domain_status := output.get("domainStatus")) is not None:
        kwargs["domain_status"] = expect_type(str, _domain_status)

    if (_domain_name := output.get("domainName")) is not None:
        kwargs["domain_name"] = expect_type(str, _domain_name)

    if "discoveredDocumentId" not in output:
        raise ServiceError(
            'Expected to find "discoveredDocumentId" in the operation output, but it was not present.'
        )
    kwargs["discovered_document_id"] = expect_type(str, output["discoveredDocumentId"])

    if (_discovered_at := output.get("discoveredAt")) is not None:
        kwargs["discovered_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _discovered_at)
        )

    return DescribeDiscoveredDocumentOutput(**kwargs)


async def _deserialize_error_describe_discovered_document(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_discovered_infotypes(
    http_response: HTTPResponse, config: Config
) -> DescribeDiscoveredInfotypesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_discovered_infotypes(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_legal_documents := output.get("legalDocuments")) is not None:
        kwargs["legal_documents"] = _deserialize_legal_document_list(
            _legal_documents, config
        )

    if "discoveredInfotypeId" not in output:
        raise ServiceError(
            'Expected to find "discoveredInfotypeId" in the operation output, but it was not present.'
        )
    kwargs["discovered_infotype_id"] = expect_type(str, output["discoveredInfotypeId"])

    if (_discovery := output.get("discovery")) is not None:
        kwargs["discovery"] = expect_type(str, _discovery)

    if (_last_discovered := output.get("lastDiscovered")) is not None:
        kwargs["last_discovered"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_discovered)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_keyword := output.get("keyword")) is not None:
        kwargs["keyword"] = _deserialize_unique_string_list(_keyword, config)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return DescribeDiscoveredInfotypesOutput(**kwargs)


async def _deserialize_error_describe_discovered_infotypes(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_discovered_recipient(
    http_response: HTTPResponse, config: Config
) -> DescribeDiscoveredRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_discovered_recipient(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "discoverySource" not in output:
        raise ServiceError(
            'Expected to find "discoverySource" in the operation output, but it was not present.'
        )
    kwargs["discovery_source"] = _deserialize_discovery_source_list(
        output["discoverySource"], config
    )

    if "recipientModelId" not in output:
        raise ServiceError(
            'Expected to find "recipientModelId" in the operation output, but it was not present.'
        )
    kwargs["recipient_model_id"] = expect_type(str, output["recipientModelId"])

    if "createdAt" not in output:
        raise ServiceError(
            'Expected to find "createdAt" in the operation output, but it was not present.'
        )
    kwargs["created_at"] = epoch_seconds_to_datetime(
        expect_type(int | float, output["createdAt"])
    )

    if "discoveredRecipientId" not in output:
        raise ServiceError(
            'Expected to find "discoveredRecipientId" in the operation output, but it was not present.'
        )
    kwargs["discovered_recipient_id"] = expect_type(
        str, output["discoveredRecipientId"]
    )

    return DescribeDiscoveredRecipientOutput(**kwargs)


async def _deserialize_error_describe_discovered_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_domain(
    http_response: HTTPResponse, config: Config
) -> DescribeDomainOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_domain(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_discovered_documents := output.get("discoveredDocuments")) is not None:
        kwargs["discovered_documents"] = (
            _deserialize_documents_discovered_of_domain_list(
                _discovered_documents, config
            )
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if "domainId" not in output:
        raise ServiceError(
            'Expected to find "domainId" in the operation output, but it was not present.'
        )
    kwargs["domain_id"] = expect_type(str, output["domainId"])

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_frequency := output.get("frequency")) is not None:
        kwargs["frequency"] = expect_type(str, _frequency)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_recipients := output.get("recipients")) is not None:
        kwargs["recipients"] = _deserialize_recipients_discovered_of_domain_list(
            _recipients, config
        )

    return DescribeDomainOutput(**kwargs)


async def _deserialize_error_describe_domain(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_dpia(
    http_response: HTTPResponse, config: Config
) -> DescribeDpiaOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_dpia(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_additional_information := output.get("additionalInformation")) is not None:
        kwargs["additional_information"] = expect_type(str, _additional_information)

    if (
        _additional_information_files := output.get("additionalInformationFiles")
    ) is not None:
        kwargs["additional_information_files"] = _deserialize_uuid_collection(
            _additional_information_files, config
        )

    if (_translations := output.get("translations")) is not None:
        kwargs["translations"] = _deserialize_field_translations(_translations, config)

    if (_confidentiality := output.get("confidentiality")) is not None:
        kwargs["confidentiality"] = _deserialize_dpia_confidentiality_risk(
            _confidentiality, config
        )

    if (_integrity := output.get("integrity")) is not None:
        kwargs["integrity"] = _deserialize_dpia_integrity_risk(_integrity, config)

    if (_availability := output.get("availability")) is not None:
        kwargs["availability"] = _deserialize_dpia_availability_risk(
            _availability, config
        )

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_uploaded_dpia_file_id := output.get("uploadedDpiaFileId")) is not None:
        kwargs["uploaded_dpia_file_id"] = expect_type(str, _uploaded_dpia_file_id)

    if (_privacy_framework := output.get("privacyFramework")) is not None:
        kwargs["privacy_framework"] = _deserialize_dpia_privacy_framework(
            _privacy_framework, config
        )

    return DescribeDpiaOutput(**kwargs)


async def _deserialize_error_describe_dpia(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_employee(
    http_response: HTTPResponse, config: Config
) -> DescribeEmployeeOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_employee(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_start_date := output.get("startDate")) is not None:
        kwargs["start_date"] = expect_type(str, _start_date)

    if (_department := output.get("department")) is not None:
        kwargs["department"] = expect_type(str, _department)

    if (_manager := output.get("manager")) is not None:
        kwargs["manager"] = expect_type(str, _manager)

    if (_department_object := output.get("departmentObject")) is not None:
        kwargs["department_object"] = _deserialize_department_object(
            _department_object, config
        )

    if (_end_date := output.get("endDate")) is not None:
        kwargs["end_date"] = expect_type(str, _end_date)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_position := output.get("position")) is not None:
        kwargs["position"] = expect_type(str, _position)

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if "createdBy" not in output:
        raise ServiceError(
            'Expected to find "createdBy" in the operation output, but it was not present.'
        )
    kwargs["created_by"] = expect_type(str, output["createdBy"])

    if "surname" not in output:
        raise ServiceError(
            'Expected to find "surname" in the operation output, but it was not present.'
        )
    kwargs["surname"] = expect_type(str, output["surname"])

    if (_manager_object := output.get("managerObject")) is not None:
        kwargs["manager_object"] = _deserialize_manager_object(_manager_object, config)

    if (_reference_id := output.get("referenceId")) is not None:
        kwargs["reference_id"] = expect_type(str, _reference_id)

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    if (_nif := output.get("nif")) is not None:
        kwargs["nif"] = expect_type(str, _nif)

    return DescribeEmployeeOutput(**kwargs)


async def _deserialize_error_describe_employee(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_error(
    http_response: HTTPResponse, config: Config
) -> DescribeErrorOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_error(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_stack_trace := output.get("stackTrace")) is not None:
        kwargs["stack_trace"] = expect_type(str, _stack_trace)

    if (_workflow_id := output.get("workflowId")) is not None:
        kwargs["workflow_id"] = expect_type(str, _workflow_id)

    if (_context := output.get("context")) is not None:
        kwargs["context"] = _deserialize_context_id_list(_context, config)

    if (_workflow_type := output.get("workflowType")) is not None:
        kwargs["workflow_type"] = expect_type(str, _workflow_type)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_activity_type := output.get("activityType")) is not None:
        kwargs["activity_type"] = expect_type(str, _activity_type)

    if (_workflow_run_id := output.get("workflowRunId")) is not None:
        kwargs["workflow_run_id"] = expect_type(str, _workflow_run_id)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if "errorId" not in output:
        raise ServiceError(
            'Expected to find "errorId" in the operation output, but it was not present.'
        )
    kwargs["error_id"] = expect_type(str, output["errorId"])

    if (_first_seen := output.get("firstSeen")) is not None:
        kwargs["first_seen"] = epoch_seconds_to_datetime(
            expect_type(int | float, _first_seen)
        )

    if (_component := output.get("component")) is not None:
        kwargs["component"] = expect_type(str, _component)

    if (_last_seen := output.get("lastSeen")) is not None:
        kwargs["last_seen"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_seen)
        )

    if (_component_id := output.get("componentId")) is not None:
        kwargs["component_id"] = expect_type(str, _component_id)

    if (_cluster := output.get("cluster")) is not None:
        kwargs["cluster"] = expect_type(str, _cluster)

    if (_hostname := output.get("hostname")) is not None:
        kwargs["hostname"] = expect_type(str, _hostname)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_message := output.get("message")) is not None:
        kwargs["message"] = expect_type(str, _message)

    return DescribeErrorOutput(**kwargs)


async def _deserialize_error_describe_error(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_headquarter(
    http_response: HTTPResponse, config: Config
) -> DescribeHeadquarterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_headquarter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    if (_city := output.get("city")) is not None:
        kwargs["city"] = expect_type(str, _city)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_country := output.get("country")) is not None:
        kwargs["country"] = expect_type(str, _country)

    if (_address := output.get("address")) is not None:
        kwargs["address"] = expect_type(str, _address)

    if (_zipcode := output.get("zipcode")) is not None:
        kwargs["zipcode"] = expect_type(str, _zipcode)

    if "headquarterId" not in output:
        raise ServiceError(
            'Expected to find "headquarterId" in the operation output, but it was not present.'
        )
    kwargs["headquarter_id"] = expect_type(str, output["headquarterId"])

    return DescribeHeadquarterOutput(**kwargs)


async def _deserialize_error_describe_headquarter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_inspection_result(
    http_response: HTTPResponse, config: Config
) -> DescribeInspectionResultOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_inspection_result(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_user_name := output.get("userName")) is not None:
        kwargs["user_name"] = expect_type(str, _user_name)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_scan_iteration_id := output.get("scanIterationId")) is not None:
        kwargs["scan_iteration_id"] = expect_type(str, _scan_iteration_id)

    if (_tokens := output.get("tokens")) is not None:
        kwargs["tokens"] = _deserialize_tokens(_tokens, config)

    if (_scan_parameters := output.get("scanParameters")) is not None:
        kwargs["scan_parameters"] = _deserialize_scan_parameters(
            _scan_parameters, config
        )

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_sample_tokens := output.get("sampleTokens")) is not None:
        kwargs["sample_tokens"] = _deserialize_tokens(_sample_tokens, config)

    if (_scan_id := output.get("scanId")) is not None:
        kwargs["scan_id"] = expect_type(str, _scan_id)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_categories := output.get("categories")) is not None:
        kwargs["categories"] = _deserialize_unique_string_list(_categories, config)

    if (_user_email := output.get("userEmail")) is not None:
        kwargs["user_email"] = expect_type(str, _user_email)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_has_finding := output.get("hasFinding")) is not None:
        kwargs["has_finding"] = expect_type(bool, _has_finding)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_confidence_snapshot := output.get("confidenceSnapshot")) is not None:
        kwargs["confidence_snapshot"] = _deserialize_inspection_confidence_snapshot(
            _confidence_snapshot, config
        )

    if (_file_name := output.get("fileName")) is not None:
        kwargs["file_name"] = expect_type(str, _file_name)

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_record_type(_stats, config)

    if (_resource_name := output.get("resourceName")) is not None:
        kwargs["resource_name"] = expect_type(str, _resource_name)

    return DescribeInspectionResultOutput(**kwargs)


async def _deserialize_error_describe_inspection_result(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_inventory_resource(
    http_response: HTTPResponse, config: Config
) -> DescribeInventoryResourceOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_inventory_resource(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_properties := output.get("properties")) is not None:
        kwargs["properties"] = _deserialize_open_properties(_properties, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_cloud_account := output.get("cloudAccount")) is not None:
        kwargs["cloud_account"] = _deserialize_cloud_account(_cloud_account, config)

    if (_severity_score := output.get("severityScore")) is not None:
        kwargs["severity_score"] = expect_type(int, _severity_score)

    if (
        _framework_exceptions_count := output.get("frameworkExceptionsCount")
    ) is not None:
        kwargs["framework_exceptions_count"] = expect_type(
            int, _framework_exceptions_count
        )

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_issue_id := output.get("issueId")) is not None:
        kwargs["issue_id"] = expect_type(str, _issue_id)

    if (_failed_policies := output.get("failedPolicies")) is not None:
        kwargs["failed_policies"] = _deserialize_unique_string_list(
            _failed_policies, config
        )

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_data_categories := output.get("dataCategories")) is not None:
        kwargs["data_categories"] = _deserialize_unique_string_list(
            _data_categories, config
        )

    if (_aka := output.get("aka")) is not None:
        kwargs["aka"] = expect_type(str, _aka)

    if (_violation_count := output.get("violationCount")) is not None:
        kwargs["violation_count"] = _deserialize_severity_count_list(
            _violation_count, config
        )

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_first_seen := output.get("firstSeen")) is not None:
        kwargs["first_seen"] = expect_type(str, _first_seen)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_failed_rules := output.get("failedRules")) is not None:
        kwargs["failed_rules"] = _deserialize_unique_string_list(_failed_rules, config)

    if (_scan := output.get("scan")) is not None:
        kwargs["scan"] = _deserialize_scan_information(_scan, config)

    if (_data_classification := output.get("dataClassification")) is not None:
        kwargs["data_classification"] = _deserialize_unique_string_list(
            _data_classification, config
        )

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_resource_stats_data(_stats, config)

    if (_last_updated := output.get("lastUpdated")) is not None:
        kwargs["last_updated"] = expect_type(str, _last_updated)

    return DescribeInventoryResourceOutput(**kwargs)


async def _deserialize_error_describe_inventory_resource(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_issue(
    http_response: HTTPResponse, config: Config
) -> DescribeIssueOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_issue(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    if (_security_risk := output.get("securityRisk")) is not None:
        kwargs["security_risk"] = _deserialize_security_risk(_security_risk, config)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if "issueId" not in output:
        raise ServiceError(
            'Expected to find "issueId" in the operation output, but it was not present.'
        )
    kwargs["issue_id"] = expect_type(str, output["issueId"])

    if (_compliance_risk := output.get("complianceRisk")) is not None:
        kwargs["compliance_risk"] = _deserialize_compliance_risk(
            _compliance_risk, config
        )

    if (_events := output.get("events")) is not None:
        kwargs["events"] = _deserialize_data_security_event_list(_events, config)

    if (_severity := output.get("severity")) is not None:
        kwargs["severity"] = expect_type(str, _severity)

    if (_resource := output.get("resource")) is not None:
        kwargs["resource"] = _deserialize_issue_resource_details(_resource, config)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_notifications := output.get("notifications")) is not None:
        kwargs["notifications"] = _deserialize_issue_notification_list(
            _notifications, config
        )

    return DescribeIssueOutput(**kwargs)


async def _deserialize_error_describe_issue(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_legal_document(
    http_response: HTTPResponse, config: Config
) -> DescribeLegalDocumentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_legal_document(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_discovered_infotypes := output.get("discoveredInfotypes")) is not None:
        kwargs["discovered_infotypes"] = _deserialize_legal_document_infotypes(
            _discovered_infotypes, config
        )

    if (_last_scanned := output.get("lastScanned")) is not None:
        kwargs["last_scanned"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scanned)
        )

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_is_discover_infotype := output.get("isDiscoverInfotype")) is not None:
        kwargs["is_discover_infotype"] = expect_type(bool, _is_discover_infotype)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (
        _from_discovered_document_id := output.get("fromDiscoveredDocumentId")
    ) is not None:
        kwargs["from_discovered_document_id"] = expect_type(
            str, _from_discovered_document_id
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if "documentId" not in output:
        raise ServiceError(
            'Expected to find "documentId" in the operation output, but it was not present.'
        )
    kwargs["document_id"] = expect_type(str, output["documentId"])

    if (_bucket_uri := output.get("bucketUri")) is not None:
        kwargs["bucket_uri"] = expect_type(str, _bucket_uri)

    if (_document_link := output.get("documentLink")) is not None:
        kwargs["document_link"] = expect_type(str, _document_link)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return DescribeLegalDocumentOutput(**kwargs)


async def _deserialize_error_describe_legal_document(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> DescribeLopdpThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_lopdp_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_large_scale_observation := output.get("largeScaleObservation")) is not None:
        kwargs["large_scale_observation"] = expect_type(bool, _large_scale_observation)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_dpia_status := output.get("dpiaStatus")) is not None:
        kwargs["dpia_status"] = expect_type(str, _dpia_status)

    if (
        _processing_vulnerable_data_subject := output.get(
            "processingVulnerableDataSubject"
        )
    ) is not None:
        kwargs["processing_vulnerable_data_subject"] = expect_type(
            bool, _processing_vulnerable_data_subject
        )

    if (
        _special_category_data_processed := output.get("specialCategoryDataProcessed")
    ) is not None:
        kwargs["special_category_data_processed"] = expect_type(
            bool, _special_category_data_processed
        )

    if (
        _freedom_risk_processing_data := output.get("freedomRiskProcessingData")
    ) is not None:
        kwargs["freedom_risk_processing_data"] = expect_type(
            bool, _freedom_risk_processing_data
        )

    if (_comment := output.get("comment")) is not None:
        kwargs["comment"] = expect_type(str, _comment)

    if (
        _rights_risk_processing_data := output.get("rightsRiskProcessingData")
    ) is not None:
        kwargs["rights_risk_processing_data"] = expect_type(
            bool, _rights_risk_processing_data
        )

    if (
        _systematic_personal_assessment := output.get("systematicPersonalAssessment")
    ) is not None:
        kwargs["systematic_personal_assessment"] = expect_type(
            bool, _systematic_personal_assessment
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (
        _innovative_technologies_used := output.get("innovativeTechnologiesUsed")
    ) is not None:
        kwargs["innovative_technologies_used"] = expect_type(
            bool, _innovative_technologies_used
        )

    if (
        _processing_personal_data_risk := output.get("processingPersonalDataRisk")
    ) is not None:
        kwargs["processing_personal_data_risk"] = expect_type(
            bool, _processing_personal_data_risk
        )

    if (_sensitive_or_special_data := output.get("sensitiveOrSpecialData")) is not None:
        kwargs["sensitive_or_special_data"] = expect_type(
            bool, _sensitive_or_special_data
        )

    if (_additional_comment := output.get("additionalComment")) is not None:
        kwargs["additional_comment"] = expect_type(bool, _additional_comment)

    return DescribeLopdpThresholdOutput(**kwargs)


async def _deserialize_error_describe_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_processing_activity(
    http_response: HTTPResponse, config: Config
) -> DescribeProcessingActivityOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_processing_activity(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_infotype_volume := output.get("infotypeVolume")) is not None:
        kwargs["infotype_volume"] = expect_type(str, _infotype_volume)

    if (
        _processing_frequency_comment := output.get("processingFrequencyComment")
    ) is not None:
        kwargs["processing_frequency_comment"] = expect_type(
            str, _processing_frequency_comment
        )

    if (_additional_info_files := output.get("additionalInfoFiles")) is not None:
        kwargs["additional_info_files"] = _deserialize_uuid_collection(
            _additional_info_files, config
        )

    if (
        _processing_activities_as_data_sources := output.get(
            "processingActivitiesAsDataSources"
        )
    ) is not None:
        kwargs["processing_activities_as_data_sources"] = _deserialize_uuid_collection(
            _processing_activities_as_data_sources, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (
        _are_access_requests_managed := output.get("areAccessRequestsManaged")
    ) is not None:
        kwargs["are_access_requests_managed"] = expect_type(
            bool, _are_access_requests_managed
        )

    if (_active := output.get("active")) is not None:
        kwargs["active"] = expect_type(bool, _active)

    if (_infotype_categories := output.get("infotypeCategories")) is not None:
        kwargs["infotype_categories"] = _deserialize_infotype_category_list(
            _infotype_categories, config
        )

    if (_translations := output.get("translations")) is not None:
        kwargs["translations"] = _deserialize_field_translations(_translations, config)

    if (_data_flow_relationships := output.get("dataFlowRelationships")) is not None:
        kwargs["data_flow_relationships"] = _deserialize_data_flow_relationships(
            _data_flow_relationships, config
        )

    if (_infotypes := output.get("infotypes")) is not None:
        kwargs["infotypes"] = _deserialize_infotypes_list(_infotypes, config)

    if (_data_types := output.get("dataTypes")) is not None:
        kwargs["data_types"] = _deserialize_uuid_collection(_data_types, config)

    if (_processing_frequency := output.get("processingFrequency")) is not None:
        kwargs["processing_frequency"] = expect_type(str, _processing_frequency)

    if "processingActivityId" not in output:
        raise ServiceError(
            'Expected to find "processingActivityId" in the operation output, but it was not present.'
        )
    kwargs["processing_activity_id"] = expect_type(str, output["processingActivityId"])

    if (_data_sources := output.get("dataSources")) is not None:
        kwargs["data_sources"] = (
            _deserialize_processing_activitiy_data_source_collection(
                _data_sources, config
            )
        )

    if (_retention_period := output.get("retentionPeriod")) is not None:
        kwargs["retention_period"] = _deserialize_retention_period(
            _retention_period, config
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_show_on_ropa_document := output.get("showOnRopaDocument")) is not None:
        kwargs["show_on_ropa_document"] = expect_type(bool, _show_on_ropa_document)

    if (_additional_info := output.get("additionalInfo")) is not None:
        kwargs["additional_info"] = expect_type(str, _additional_info)

    if (_asset_objects := output.get("assetObjects")) is not None:
        kwargs["asset_objects"] = _deserialize_processing_activity_asset_list(
            _asset_objects, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_model_id := output.get("modelId")) is not None:
        kwargs["model_id"] = expect_type(str, _model_id)

    if (_purpose := output.get("purpose")) is not None:
        kwargs["purpose"] = expect_type(str, _purpose)

    if (_retention_period_comment := output.get("retentionPeriodComment")) is not None:
        kwargs["retention_period_comment"] = expect_type(str, _retention_period_comment)

    if (_department_objects := output.get("departmentObjects")) is not None:
        kwargs["department_objects"] = _deserialize_processing_activity_department_list(
            _department_objects, config
        )

    if (_uploaded_ta_dpia_file_id := output.get("uploadedTaDpiaFileId")) is not None:
        kwargs["uploaded_ta_dpia_file_id"] = expect_type(str, _uploaded_ta_dpia_file_id)

    if (_employee_objects := output.get("employeeObjects")) is not None:
        kwargs["employee_objects"] = _deserialize_processing_activity_employee_list(
            _employee_objects, config
        )

    if (_management_methods := output.get("managementMethods")) is not None:
        kwargs["management_methods"] = _deserialize_management_method_collection(
            _management_methods, config
        )

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_uploaded_ta_file_id := output.get("uploadedTaFileId")) is not None:
        kwargs["uploaded_ta_file_id"] = expect_type(str, _uploaded_ta_file_id)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_uploaded_dpia_file_id := output.get("uploadedDpiaFileId")) is not None:
        kwargs["uploaded_dpia_file_id"] = expect_type(str, _uploaded_dpia_file_id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_recipient_objects := output.get("recipientObjects")) is not None:
        kwargs["recipient_objects"] = _deserialize_processing_activity_recipient_list(
            _recipient_objects, config
        )

    if (_lawful_basis := output.get("lawfulBasis")) is not None:
        kwargs["lawful_basis"] = _deserialize_lawful_basis_collection(
            _lawful_basis, config
        )

    if (_contact_person_employee := output.get("contactPersonEmployee")) is not None:
        kwargs["contact_person_employee"] = _deserialize_processing_activity_employee(
            _contact_person_employee, config
        )

    if (_is_data_stored := output.get("isDataStored")) is not None:
        kwargs["is_data_stored"] = expect_type(bool, _is_data_stored)

    if (_data_subjects := output.get("dataSubjects")) is not None:
        kwargs["data_subjects"] = _deserialize_data_subject_collection(
            _data_subjects, config
        )

    if (_framework := output.get("framework")) is not None:
        kwargs["framework"] = expect_type(str, _framework)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = expect_type(str, _owner)

    if (_company_role := output.get("companyRole")) is not None:
        kwargs["company_role"] = _deserialize_company_role_list(_company_role, config)

    return DescribeProcessingActivityOutput(**kwargs)


async def _deserialize_error_describe_processing_activity(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_recipient(
    http_response: HTTPResponse, config: Config
) -> DescribeRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_recipient(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_data_storage_location := output.get("dataStorageLocation")) is not None:
        kwargs["data_storage_location"] = _deserialize_country_list(
            _data_storage_location, config
        )

    if (_automation_status := output.get("automationStatus")) is not None:
        kwargs["automation_status"] = expect_type(str, _automation_status)

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    if (_role := output.get("role")) is not None:
        kwargs["role"] = _deserialize_recipient_role_list(_role, config)

    if (_contact_email := output.get("contactEmail")) is not None:
        kwargs["contact_email"] = expect_type(str, _contact_email)

    if (_discovery_source := output.get("discoverySource")) is not None:
        kwargs["discovery_source"] = _deserialize_discovery_source_list(
            _discovery_source, config
        )

    if (_sub_processors := output.get("subProcessors")) is not None:
        kwargs["sub_processors"] = _deserialize_recipients_for_filter_list(
            _sub_processors, config
        )

    if (_country := output.get("country")) is not None:
        kwargs["country"] = expect_type(str, _country)

    if (_privacy_policy_link := output.get("privacyPolicyLink")) is not None:
        kwargs["privacy_policy_link"] = expect_type(str, _privacy_policy_link)

    if (_business_name := output.get("businessName")) is not None:
        kwargs["business_name"] = expect_type(str, _business_name)

    if (_discovered_date := output.get("discoveredDate")) is not None:
        kwargs["discovered_date"] = epoch_seconds_to_datetime(
            expect_type(int | float, _discovered_date)
        )

    if (_categories := output.get("categories")) is not None:
        kwargs["categories"] = _deserialize_recipient_category_collection(
            _categories, config
        )

    if (_dpa := output.get("dpa")) is not None:
        kwargs["dpa"] = expect_type(str, _dpa)

    if (_dpa_status := output.get("dpaStatus")) is not None:
        kwargs["dpa_status"] = expect_type(str, _dpa_status)

    if (_dpa_files := output.get("dpaFiles")) is not None:
        kwargs["dpa_files"] = _deserialize_uuid_collection(_dpa_files, config)

    if (_recipient_model_id := output.get("recipientModelId")) is not None:
        kwargs["recipient_model_id"] = expect_type(str, _recipient_model_id)

    if (_recipient_state := output.get("recipientState")) is not None:
        kwargs["recipient_state"] = expect_type(str, _recipient_state)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_recipient_warranties := output.get("recipientWarranties")) is not None:
        kwargs["recipient_warranties"] = _deserialize_warranty_list(
            _recipient_warranties, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return DescribeRecipientOutput(**kwargs)


async def _deserialize_error_describe_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_resource_lineage(
    http_response: HTTPResponse, config: Config
) -> DescribeResourceLineageOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_resource_lineage(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sample_tokens := output.get("sampleTokens")) is not None:
        kwargs["sample_tokens"] = _deserialize_tokens(_sample_tokens, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_source_edges := output.get("sourceEdges")) is not None:
        kwargs["source_edges"] = _deserialize_resource_lineage_edge_list(
            _source_edges, config
        )

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if (_parent := output.get("parent")) is not None:
        kwargs["parent"] = _deserialize_resource_parent(_parent, config)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_last_scanned := output.get("lastScanned")) is not None:
        kwargs["last_scanned"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scanned)
        )

    if (_destination_edges := output.get("destinationEdges")) is not None:
        kwargs["destination_edges"] = _deserialize_resource_lineage_edge_list(
            _destination_edges, config
        )

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    return DescribeResourceLineageOutput(**kwargs)


async def _deserialize_error_describe_resource_lineage(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_scan(
    http_response: HTTPResponse, config: Config
) -> DescribeScanOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_scan(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_execution := output.get("nextExecution")) is not None:
        kwargs["next_execution"] = epoch_seconds_to_datetime(
            expect_type(int | float, _next_execution)
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_data_plane_slug := output.get("dataPlaneSlug")) is not None:
        kwargs["data_plane_slug"] = expect_type(str, _data_plane_slug)

    if (_connector_type := output.get("connectorType")) is not None:
        kwargs["connector_type"] = expect_type(str, _connector_type)

    if (_cron := output.get("cron")) is not None:
        kwargs["cron"] = expect_type(str, _cron)

    if (_false_positive_reports := output.get("falsePositiveReports")) is not None:
        kwargs["false_positive_reports"] = _deserialize_false_positive_report_list(
            _false_positive_reports, config
        )

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_scan_stats(_stats, config)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_scan_type := output.get("scanType")) is not None:
        kwargs["scan_type"] = expect_type(str, _scan_type)

    if (_confidence_snapshot := output.get("confidenceSnapshot")) is not None:
        kwargs["confidence_snapshot"] = _deserialize_inspection_confidence_snapshot(
            _confidence_snapshot, config
        )

    if (_inspection_policy := output.get("inspectionPolicy")) is not None:
        kwargs["inspection_policy"] = _deserialize_inspection_policy(
            _inspection_policy, config
        )

    if "scanId" not in output:
        raise ServiceError(
            'Expected to find "scanId" in the operation output, but it was not present.'
        )
    kwargs["scan_id"] = expect_type(str, output["scanId"])

    if (_connector_id := output.get("connectorId")) is not None:
        kwargs["connector_id"] = expect_type(str, _connector_id)

    if (_data_plane_id := output.get("dataPlaneId")) is not None:
        kwargs["data_plane_id"] = expect_type(str, _data_plane_id)

    if (_scan_limits := output.get("scanLimits")) is not None:
        kwargs["scan_limits"] = _deserialize_scan_limits(_scan_limits, config)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_latest_iteration_stats := output.get("latestIterationStats")) is not None:
        kwargs["latest_iteration_stats"] = _deserialize_scan_iteration_stats(
            _latest_iteration_stats, config
        )

    if (_elapsed_time_ms := output.get("elapsedTimeMs")) is not None:
        kwargs["elapsed_time_ms"] = expect_type(int, _elapsed_time_ms)

    if (_schedule_type := output.get("scheduleType")) is not None:
        kwargs["schedule_type"] = expect_type(str, _schedule_type)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_schedule := output.get("schedule")) is not None:
        kwargs["schedule"] = _deserialize_scan_schedule(_schedule, config)

    if (_data_plane_name := output.get("dataPlaneName")) is not None:
        kwargs["data_plane_name"] = expect_type(str, _data_plane_name)

    if (_scan_filter := output.get("scanFilter")) is not None:
        kwargs["scan_filter"] = _deserialize_scan_filter_list(_scan_filter, config)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_scan_meta(_meta, config)

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_scan_resources(_resources, config)

    return DescribeScanOutput(**kwargs)


async def _deserialize_error_describe_scan(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_scan_iteration(
    http_response: HTTPResponse, config: Config
) -> DescribeScanIterationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_scan_iteration(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "scanIterationId" not in output:
        raise ServiceError(
            'Expected to find "scanIterationId" in the operation output, but it was not present.'
        )
    kwargs["scan_iteration_id"] = expect_type(str, output["scanIterationId"])

    if (_failed_resources := output.get("failedResources")) is not None:
        kwargs["failed_resources"] = _deserialize_resources_list(
            _failed_resources, config
        )

    if (_scan_id := output.get("scanId")) is not None:
        kwargs["scan_id"] = expect_type(str, _scan_id)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_resources_list(_resources, config)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_deleted_resources := output.get("deletedResources")) is not None:
        kwargs["deleted_resources"] = _deserialize_resources_list(
            _deleted_resources, config
        )

    if (_successful_resources := output.get("successfulResources")) is not None:
        kwargs["successful_resources"] = _deserialize_resources_list(
            _successful_resources, config
        )

    return DescribeScanIterationOutput(**kwargs)


async def _deserialize_error_describe_scan_iteration(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_threshold(
    http_response: HTTPResponse, config: Config
) -> DescribeThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (
        _large_scale_processing_sensitive_data := output.get(
            "largeScaleProcessingSensitiveData"
        )
    ) is not None:
        kwargs["large_scale_processing_sensitive_data"] = expect_type(
            bool, _large_scale_processing_sensitive_data
        )

    if (
        _large_scale_data_processing := output.get("largeScaleDataProcessing")
    ) is not None:
        kwargs["large_scale_data_processing"] = expect_type(
            bool, _large_scale_data_processing
        )

    if (_translations := output.get("translations")) is not None:
        kwargs["translations"] = _deserialize_field_translations(_translations, config)

    if (_comment := output.get("comment")) is not None:
        kwargs["comment"] = expect_type(str, _comment)

    if (_uploaded_ta_file_id := output.get("uploadedTaFileId")) is not None:
        kwargs["uploaded_ta_file_id"] = expect_type(str, _uploaded_ta_file_id)

    if (
        _processing_vulnerable_data_subject := output.get(
            "processingVulnerableDataSubject"
        )
    ) is not None:
        kwargs["processing_vulnerable_data_subject"] = expect_type(
            bool, _processing_vulnerable_data_subject
        )

    if (_dpia_status := output.get("dpiaStatus")) is not None:
        kwargs["dpia_status"] = expect_type(str, _dpia_status)

    if (
        _monitoring_publicly_accessible_areas := output.get(
            "monitoringPubliclyAccessibleAreas"
        )
    ) is not None:
        kwargs["monitoring_publicly_accessible_areas"] = expect_type(
            bool, _monitoring_publicly_accessible_areas
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (
        _innovative_technologies_used := output.get("innovativeTechnologiesUsed")
    ) is not None:
        kwargs["innovative_technologies_used"] = expect_type(
            bool, _innovative_technologies_used
        )

    if (
        _extensive_automated_evaluation_characteristics := output.get(
            "extensiveAutomatedEvaluationCharacteristics"
        )
    ) is not None:
        kwargs["extensive_automated_evaluation_characteristics"] = expect_type(
            bool, _extensive_automated_evaluation_characteristics
        )

    if (
        _matching_merging_records_involved := output.get(
            "matchingMergingRecordsInvolved"
        )
    ) is not None:
        kwargs["matching_merging_records_involved"] = expect_type(
            bool, _matching_merging_records_involved
        )

    if (_blacklist := output.get("blacklist")) is not None:
        kwargs["blacklist"] = expect_type(bool, _blacklist)

    if (
        _automated_decision_making := output.get("automatedDecisionMaking")
    ) is not None:
        kwargs["automated_decision_making"] = expect_type(
            bool, _automated_decision_making
        )

    if (
        _systematic_monitoring_data_subject := output.get(
            "systematicMonitoringDataSubject"
        )
    ) is not None:
        kwargs["systematic_monitoring_data_subject"] = expect_type(
            bool, _systematic_monitoring_data_subject
        )

    if (
        _prevent_data_subjects_exercising_their_rights := output.get(
            "preventDataSubjectsExercisingTheirRights"
        )
    ) is not None:
        kwargs["prevent_data_subjects_exercising_their_rights"] = expect_type(
            bool, _prevent_data_subjects_exercising_their_rights
        )

    if (_classifying_data_subject := output.get("classifyingDataSubject")) is not None:
        kwargs["classifying_data_subject"] = expect_type(
            bool, _classifying_data_subject
        )

    if (
        _processing_confidential_sensitive_data := output.get(
            "processingConfidentialSensitiveData"
        )
    ) is not None:
        kwargs["processing_confidential_sensitive_data"] = expect_type(
            bool, _processing_confidential_sensitive_data
        )

    return DescribeThresholdOutput(**kwargs)


async def _deserialize_error_describe_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_tom(
    http_response: HTTPResponse, config: Config
) -> DescribeTomOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_tom(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_description := output.get("description")) is not None:
        kwargs["description"] = expect_type(str, _description)

    if (_note := output.get("note")) is not None:
        kwargs["note"] = expect_type(str, _note)

    if (_list_ := output.get("list")) is not None:
        kwargs["list_"] = expect_type(str, _list_)

    if (_category := output.get("category")) is not None:
        kwargs["category"] = expect_type(str, _category)

    if (_document_files := output.get("documentFiles")) is not None:
        kwargs["document_files"] = _deserialize_uuid_collection(_document_files, config)

    if (_object_category := output.get("objectCategory")) is not None:
        kwargs["object_category"] = expect_type(str, _object_category)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_reference_code := output.get("referenceCode")) is not None:
        kwargs["reference_code"] = expect_type(str, _reference_code)

    return DescribeTomOutput(**kwargs)


async def _deserialize_error_describe_tom(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_describe_user_profile(
    http_response: HTTPResponse, config: Config
) -> DescribeUserProfileOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_describe_user_profile(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_connector_username := output.get("connectorUsername")) is not None:
        kwargs["connector_username"] = expect_type(str, _connector_username)

    if (_external := output.get("external")) is not None:
        kwargs["external"] = expect_type(bool, _external)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_connector_source_type := output.get("connectorSourceType")) is not None:
        kwargs["connector_source_type"] = expect_type(str, _connector_source_type)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if "userId" not in output:
        raise ServiceError(
            'Expected to find "userId" in the operation output, but it was not present.'
        )
    kwargs["user_id"] = expect_type(str, output["userId"])

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    if (_connector_user_id := output.get("connectorUserId")) is not None:
        kwargs["connector_user_id"] = expect_type(str, _connector_user_id)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_connector_id := output.get("connectorId")) is not None:
        kwargs["connector_id"] = expect_type(str, _connector_id)

    return DescribeUserProfileOutput(**kwargs)


async def _deserialize_error_describe_user_profile(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_disable_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> DisableDashboardUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_disable_dashboard_user(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_external_provider := output.get("externalProvider")) is not None:
        kwargs["external_provider"] = expect_type(bool, _external_provider)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_company_name := output.get("companyName")) is not None:
        kwargs["company_name"] = expect_type(str, _company_name)

    if (_provider := output.get("provider")) is not None:
        kwargs["provider"] = expect_type(str, _provider)

    if (_enabled := output.get("enabled")) is not None:
        kwargs["enabled"] = expect_type(bool, _enabled)

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_dashboard_user_roles(_roles, config)

    if (_super_admin := output.get("superAdmin")) is not None:
        kwargs["super_admin"] = expect_type(bool, _super_admin)

    if (_organisations := output.get("organisations")) is not None:
        kwargs["organisations"] = _deserialize_user_organisations(
            _organisations, config
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if "username" not in output:
        raise ServiceError(
            'Expected to find "username" in the operation output, but it was not present.'
        )
    kwargs["username"] = expect_type(str, output["username"])

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return DisableDashboardUserOutput(**kwargs)


async def _deserialize_error_disable_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_download_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> DownloadDashboardReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_download_dashboard_report(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return DownloadDashboardReportOutput(**kwargs)


async def _deserialize_error_download_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_download_dashboard_report_edition(
    http_response: HTTPResponse, config: Config
) -> DownloadDashboardReportEditionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_download_dashboard_report_edition(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return DownloadDashboardReportEditionOutput(**kwargs)


async def _deserialize_error_download_dashboard_report_edition(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_download_dashboard_report_for_super_admin(
    http_response: HTTPResponse, config: Config
) -> DownloadDashboardReportForSuperAdminOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_download_dashboard_report_for_super_admin(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return DownloadDashboardReportForSuperAdminOutput(**kwargs)


async def _deserialize_error_download_dashboard_report_for_super_admin(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_enable_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> EnableDashboardUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_enable_dashboard_user(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_dashboard_user_roles(_roles, config)

    if (_super_admin := output.get("superAdmin")) is not None:
        kwargs["super_admin"] = expect_type(bool, _super_admin)

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_provider := output.get("provider")) is not None:
        kwargs["provider"] = expect_type(str, _provider)

    if (_enabled := output.get("enabled")) is not None:
        kwargs["enabled"] = expect_type(bool, _enabled)

    if (_company_name := output.get("companyName")) is not None:
        kwargs["company_name"] = expect_type(str, _company_name)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if "username" not in output:
        raise ServiceError(
            'Expected to find "username" in the operation output, but it was not present.'
        )
    kwargs["username"] = expect_type(str, output["username"])

    if (_organisations := output.get("organisations")) is not None:
        kwargs["organisations"] = _deserialize_user_organisations(
            _organisations, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_external_provider := output.get("externalProvider")) is not None:
        kwargs["external_provider"] = expect_type(bool, _external_provider)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    return EnableDashboardUserOutput(**kwargs)


async def _deserialize_error_enable_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_get_chatbot_response(
    http_response: HTTPResponse, config: Config
) -> GetChatbotResponseOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_chatbot_response(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_recommendations := output.get("recommendations")) is not None:
        kwargs["recommendations"] = expect_type(str, _recommendations)

    if (_answer := output.get("answer")) is not None:
        kwargs["answer"] = expect_type(str, _answer)

    if (_relevant_links := output.get("relevantLinks")) is not None:
        kwargs["relevant_links"] = _deserialize_links(_relevant_links, config)

    if (_summary := output.get("summary")) is not None:
        kwargs["summary"] = expect_type(str, _summary)

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    return GetChatbotResponseOutput(**kwargs)


async def _deserialize_error_get_chatbot_response(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_access_logs(
    http_response: HTTPResponse, config: Config
) -> ListAccessLogsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_access_logs(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_size := output.get("size")) is not None:
        kwargs["size"] = expect_type(int, _size)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_logs := output.get("logs")) is not None:
        kwargs["logs"] = _deserialize_access_logs_results(_logs, config)

    return ListAccessLogsOutput(**kwargs)


async def _deserialize_error_list_access_logs(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_accounts(
    http_response: HTTPResponse, config: Config
) -> ListAccountsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_accounts(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_accounts := output.get("accounts")) is not None:
        kwargs["accounts"] = _deserialize_accounts_list(_accounts, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListAccountsOutput(**kwargs)


async def _deserialize_error_list_accounts(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_active_resource_timeline(
    http_response: HTTPResponse, config: Config
) -> ListActiveResourceTimelineOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_active_resource_timeline(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_active_resources_stats_list(_result, config)

    return ListActiveResourceTimelineOutput(**kwargs)


async def _deserialize_error_list_active_resource_timeline(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_assets(
    http_response: HTTPResponse, config: Config
) -> ListAssetsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_assets(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "assets" not in output:
        raise ServiceError(
            'Expected to find "assets" in the operation output, but it was not present.'
        )
    kwargs["assets"] = _deserialize_asset_list(output["assets"], config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if "total" not in output:
        raise ServiceError(
            'Expected to find "total" in the operation output, but it was not present.'
        )
    kwargs["total"] = expect_type(int, output["total"])

    return ListAssetsOutput(**kwargs)


async def _deserialize_error_list_assets(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_audit_logs(
    http_response: HTTPResponse, config: Config
) -> ListAuditLogsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_audit_logs(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_size := output.get("size")) is not None:
        kwargs["size"] = expect_type(int, _size)

    if (_logs := output.get("logs")) is not None:
        kwargs["logs"] = _deserialize_audit_logs_results(_logs, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListAuditLogsOutput(**kwargs)


async def _deserialize_error_list_audit_logs(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_auto_suggestions(
    http_response: HTTPResponse, config: Config
) -> ListAutoSuggestionsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_auto_suggestions(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_suggestions := output.get("suggestions")) is not None:
        kwargs["suggestions"] = _deserialize_suggestions(_suggestions, config)

    return ListAutoSuggestionsOutput(**kwargs)


async def _deserialize_error_list_auto_suggestions(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_catalog_leaf_resources(
    http_response: HTTPResponse, config: Config
) -> ListCatalogLeafResourcesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_catalog_leaf_resources(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_leaf_resources_data_list(_resources, config)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListCatalogLeafResourcesOutput(**kwargs)


async def _deserialize_error_list_catalog_leaf_resources(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_catalog_leaf_resources_export(
    http_response: HTTPResponse, config: Config
) -> ListCatalogLeafResourcesExportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_catalog_leaf_resources_export(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return ListCatalogLeafResourcesExportOutput(**kwargs)


async def _deserialize_error_list_catalog_leaf_resources_export(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_columns_for_resources(
    http_response: HTTPResponse, config: Config
) -> ListColumnsForResourcesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_columns_for_resources(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_resource_columns_list(_result, config)

    return ListColumnsForResourcesOutput(**kwargs)


async def _deserialize_error_list_columns_for_resources(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_connectors(
    http_response: HTTPResponse, config: Config
) -> ListConnectorsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_connectors(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_connectors := output.get("connectors")) is not None:
        kwargs["connectors"] = _deserialize_connectors_list(_connectors, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListConnectorsOutput(**kwargs)


async def _deserialize_error_list_connectors(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_dashboard_users(
    http_response: HTTPResponse, config: Config
) -> ListDashboardUsersOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_dashboard_users(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_users := output.get("users")) is not None:
        kwargs["users"] = _deserialize_users_list(_users, config)

    return ListDashboardUsersOutput(**kwargs)


async def _deserialize_error_list_dashboard_users(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_data_breach(
    http_response: HTTPResponse, config: Config
) -> ListDataBreachOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_data_breach(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "total" not in output:
        raise ServiceError(
            'Expected to find "total" in the operation output, but it was not present.'
        )
    kwargs["total"] = expect_type(int, output["total"])

    if "dataBreaches" not in output:
        raise ServiceError(
            'Expected to find "dataBreaches" in the operation output, but it was not present.'
        )
    kwargs["data_breaches"] = _deserialize_data_breach_list(
        output["dataBreaches"], config
    )

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    return ListDataBreachOutput(**kwargs)


async def _deserialize_error_list_data_breach(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_data_breach_filter(
    http_response: HTTPResponse, config: Config
) -> ListDataBreachFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_data_breach_filter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_entries := output.get("entries")) is not None:
        kwargs["entries"] = _deserialize_data_breach_filter_filter_output_list(
            _entries, config
        )

    return ListDataBreachFilterOutput(**kwargs)


async def _deserialize_error_list_data_breach_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_departments(
    http_response: HTTPResponse, config: Config
) -> ListDepartmentsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_departments(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if "total" not in output:
        raise ServiceError(
            'Expected to find "total" in the operation output, but it was not present.'
        )
    kwargs["total"] = expect_type(int, output["total"])

    if "departments" not in output:
        raise ServiceError(
            'Expected to find "departments" in the operation output, but it was not present.'
        )
    kwargs["departments"] = _deserialize_department_list(output["departments"], config)

    return ListDepartmentsOutput(**kwargs)


async def _deserialize_error_list_departments(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_departments_for_filter(
    http_response: HTTPResponse, config: Config
) -> ListDepartmentsForFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_departments_for_filter(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "departments" not in output:
        raise ServiceError(
            'Expected to find "departments" in the operation output, but it was not present.'
        )
    kwargs["departments"] = _deserialize_department_for_filter_list(
        output["departments"], config
    )

    return ListDepartmentsForFilterOutput(**kwargs)


async def _deserialize_error_list_departments_for_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_discovered_documents(
    http_response: HTTPResponse, config: Config
) -> ListDiscoveredDocumentsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_discovered_documents(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_discovered_documents := output.get("discoveredDocuments")) is not None:
        kwargs["discovered_documents"] = _deserialize_discovered_documents_list(
            _discovered_documents, config
        )

    return ListDiscoveredDocumentsOutput(**kwargs)


async def _deserialize_error_list_discovered_documents(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_discovered_infotypes(
    http_response: HTTPResponse, config: Config
) -> ListDiscoveredInfotypesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_discovered_infotypes(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_discovered_infotypes := output.get("discoveredInfotypes")) is not None:
        kwargs["discovered_infotypes"] = _deserialize_discovered_infotypes_list(
            _discovered_infotypes, config
        )

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListDiscoveredInfotypesOutput(**kwargs)


async def _deserialize_error_list_discovered_infotypes(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_discovered_recipients(
    http_response: HTTPResponse, config: Config
) -> ListDiscoveredRecipientsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_discovered_recipients(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_discovered_recipients := output.get("discoveredRecipients")) is not None:
        kwargs["discovered_recipients"] = _deserialize_discovered_recipient_list(
            _discovered_recipients, config
        )

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListDiscoveredRecipientsOutput(**kwargs)


async def _deserialize_error_list_discovered_recipients(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_discovered_recipients_users(
    http_response: HTTPResponse, config: Config
) -> ListDiscoveredRecipientsUsersOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_discovered_recipients_users(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_okta_users := output.get("oktaUsers")) is not None:
        kwargs["okta_users"] = _deserialize_okta_user_discovery_list(
            _okta_users, config
        )

    return ListDiscoveredRecipientsUsersOutput(**kwargs)


async def _deserialize_error_list_discovered_recipients_users(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_domains(
    http_response: HTTPResponse, config: Config
) -> ListDomainsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_domains(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_domains := output.get("domains")) is not None:
        kwargs["domains"] = _deserialize_domain_list(_domains, config)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListDomainsOutput(**kwargs)


async def _deserialize_error_list_domains(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_employees(
    http_response: HTTPResponse, config: Config
) -> ListEmployeesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_employees(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if "employees" not in output:
        raise ServiceError(
            'Expected to find "employees" in the operation output, but it was not present.'
        )
    kwargs["employees"] = _deserialize_employee_list(output["employees"], config)

    if "total" not in output:
        raise ServiceError(
            'Expected to find "total" in the operation output, but it was not present.'
        )
    kwargs["total"] = expect_type(int, output["total"])

    return ListEmployeesOutput(**kwargs)


async def _deserialize_error_list_employees(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_employees_for_filter(
    http_response: HTTPResponse, config: Config
) -> ListEmployeesForFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_employees_for_filter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "employees" not in output:
        raise ServiceError(
            'Expected to find "employees" in the operation output, but it was not present.'
        )
    kwargs["employees"] = _deserialize_employees_for_filter_list(
        output["employees"], config
    )

    return ListEmployeesForFilterOutput(**kwargs)


async def _deserialize_error_list_employees_for_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_errors(
    http_response: HTTPResponse, config: Config
) -> ListErrorsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_errors(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_errors := output.get("errors")) is not None:
        kwargs["errors"] = _deserialize_errors_list(_errors, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListErrorsOutput(**kwargs)


async def _deserialize_error_list_errors(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_events(
    http_response: HTTPResponse, config: Config
) -> ListEventsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_events(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_events := output.get("events")) is not None:
        kwargs["events"] = _deserialize_events_list(_events, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListEventsOutput(**kwargs)


async def _deserialize_error_list_events(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_headquarters(
    http_response: HTTPResponse, config: Config
) -> ListHeadquartersOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_headquarters(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if "headquarters" not in output:
        raise ServiceError(
            'Expected to find "headquarters" in the operation output, but it was not present.'
        )
    kwargs["headquarters"] = _deserialize_headquarter_list(
        output["headquarters"], config
    )

    if "total" not in output:
        raise ServiceError(
            'Expected to find "total" in the operation output, but it was not present.'
        )
    kwargs["total"] = expect_type(int, output["total"])

    return ListHeadquartersOutput(**kwargs)


async def _deserialize_error_list_headquarters(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_infotype_categories(
    http_response: HTTPResponse, config: Config
) -> ListInfotypeCategoriesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_infotype_categories(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_categories := output.get("categories")) is not None:
        kwargs["categories"] = _deserialize_category_list(_categories, config)

    return ListInfotypeCategoriesOutput(**kwargs)


async def _deserialize_error_list_infotype_categories(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_insights_filter(
    http_response: HTTPResponse, config: Config
) -> ListInsightsFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_insights_filter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_entries := output.get("entries")) is not None:
        kwargs["entries"] = _deserialize_insights_filter_value_parameter_list(
            _entries, config
        )

    return ListInsightsFilterOutput(**kwargs)


async def _deserialize_error_list_insights_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_inspection_results(
    http_response: HTTPResponse, config: Config
) -> ListInspectionResultsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_inspection_results(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_inspection_results := output.get("inspectionResults")) is not None:
        kwargs["inspection_results"] = _deserialize_inspection_result_list(
            _inspection_results, config
        )

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListInspectionResultsOutput(**kwargs)


async def _deserialize_error_list_inspection_results(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_inventory_resources(
    http_response: HTTPResponse, config: Config
) -> ListInventoryResourcesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_inventory_resources(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_resource_inventory_list(_resources, config)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    return ListInventoryResourcesOutput(**kwargs)


async def _deserialize_error_list_inventory_resources(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_inventory_resources_export(
    http_response: HTTPResponse, config: Config
) -> ListInventoryResourcesExportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_inventory_resources_export(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return ListInventoryResourcesExportOutput(**kwargs)


async def _deserialize_error_list_inventory_resources_export(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_issues(
    http_response: HTTPResponse, config: Config
) -> ListIssuesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_issues(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_issues := output.get("issues")) is not None:
        kwargs["issues"] = _deserialize_issue_list(_issues, config)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListIssuesOutput(**kwargs)


async def _deserialize_error_list_issues(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_legal_documents(
    http_response: HTTPResponse, config: Config
) -> ListLegalDocumentsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_legal_documents(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_is_borneo_ai_scanning := output.get("isBorneoAiScanning")) is not None:
        kwargs["is_borneo_ai_scanning"] = expect_type(bool, _is_borneo_ai_scanning)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_legal_documents := output.get("legalDocuments")) is not None:
        kwargs["legal_documents"] = _deserialize_legal_document_list(
            _legal_documents, config
        )

    return ListLegalDocumentsOutput(**kwargs)


async def _deserialize_error_list_legal_documents(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_processing_activities(
    http_response: HTTPResponse, config: Config
) -> ListProcessingActivitiesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_processing_activities(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if "total" not in output:
        raise ServiceError(
            'Expected to find "total" in the operation output, but it was not present.'
        )
    kwargs["total"] = expect_type(int, output["total"])

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if "processingActivities" not in output:
        raise ServiceError(
            'Expected to find "processingActivities" in the operation output, but it was not present.'
        )
    kwargs["processing_activities"] = _deserialize_processing_activity_list(
        output["processingActivities"], config
    )

    return ListProcessingActivitiesOutput(**kwargs)


async def _deserialize_error_list_processing_activities(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_processing_activities_export(
    http_response: HTTPResponse, config: Config
) -> ListProcessingActivitiesExportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_processing_activities_export(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url_list := output.get("urlList")) is not None:
        kwargs["url_list"] = _deserialize_url_list(_url_list, config)

    return ListProcessingActivitiesExportOutput(**kwargs)


async def _deserialize_error_list_processing_activities_export(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_processing_activities_of_recipient(
    http_response: HTTPResponse, config: Config
) -> ListProcessingActivitiesOfRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_processing_activities_of_recipient(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (
        _processing_activities_of_recipient := output.get(
            "processingActivitiesOfRecipient"
        )
    ) is not None:
        kwargs["processing_activities_of_recipient"] = (
            _deserialize_processing_activity_of_recipient_list(
                _processing_activities_of_recipient, config
            )
        )

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListProcessingActivitiesOfRecipientOutput(**kwargs)


async def _deserialize_error_list_processing_activities_of_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_processing_activity_filter(
    http_response: HTTPResponse, config: Config
) -> ListProcessingActivityFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_processing_activity_filter(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_enteries := output.get("enteries")) is not None:
        kwargs["enteries"] = _deserialize_processing_activity_filter_output_list(
            _enteries, config
        )

    return ListProcessingActivityFilterOutput(**kwargs)


async def _deserialize_error_list_processing_activity_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_recipient_filter(
    http_response: HTTPResponse, config: Config
) -> ListRecipientFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_recipient_filter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_entries := output.get("entries")) is not None:
        kwargs["entries"] = _deserialize_recipient_filter_output_list(_entries, config)

    return ListRecipientFilterOutput(**kwargs)


async def _deserialize_error_list_recipient_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_recipients(
    http_response: HTTPResponse, config: Config
) -> ListRecipientsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_recipients(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_recipients := output.get("recipients")) is not None:
        kwargs["recipients"] = _deserialize_recipient_list(_recipients, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListRecipientsOutput(**kwargs)


async def _deserialize_error_list_recipients(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_recipients_export(
    http_response: HTTPResponse, config: Config
) -> ListRecipientsExportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_recipients_export(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url_list := output.get("urlList")) is not None:
        kwargs["url_list"] = _deserialize_url_list(_url_list, config)

    return ListRecipientsExportOutput(**kwargs)


async def _deserialize_error_list_recipients_export(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_recipients_for_filter(
    http_response: HTTPResponse, config: Config
) -> ListRecipientsForFilterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_recipients_for_filter(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_recipients := output.get("recipients")) is not None:
        kwargs["recipients"] = _deserialize_recipients_for_filter_list(
            _recipients, config
        )

    return ListRecipientsForFilterOutput(**kwargs)


async def _deserialize_error_list_recipients_for_filter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_report_schedules(
    http_response: HTTPResponse, config: Config
) -> ListReportSchedulesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_report_schedules(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_dashboard_reports := output.get("dashboardReports")) is not None:
        kwargs["dashboard_reports"] = _deserialize_dashboard_report_list(
            _dashboard_reports, config
        )

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListReportSchedulesOutput(**kwargs)


async def _deserialize_error_list_report_schedules(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_reports_edition(
    http_response: HTTPResponse, config: Config
) -> ListReportsEditionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_reports_edition(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (
        _dashboard_report_editions := output.get("dashboardReportEditions")
    ) is not None:
        kwargs["dashboard_report_editions"] = (
            _deserialize_dashboard_report_edition_list(
                _dashboard_report_editions, config
            )
        )

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    return ListReportsEditionOutput(**kwargs)


async def _deserialize_error_list_reports_edition(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_scan_execution_insights(
    http_response: HTTPResponse, config: Config
) -> ListScanExecutionInsightsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_scan_execution_insights(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_results := output.get("results")) is not None:
        kwargs["results"] = _deserialize_scan_execution_records_list(_results, config)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListScanExecutionInsightsOutput(**kwargs)


async def _deserialize_error_list_scan_execution_insights(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_scan_iterations(
    http_response: HTTPResponse, config: Config
) -> ListScanIterationsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_scan_iterations(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_scan_iterations := output.get("scanIterations")) is not None:
        kwargs["scan_iterations"] = _deserialize_scan_iterations_list(
            _scan_iterations, config
        )

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListScanIterationsOutput(**kwargs)


async def _deserialize_error_list_scan_iterations(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_scan_resource_status(
    http_response: HTTPResponse, config: Config
) -> ListScanResourceStatusOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_scan_resource_status(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_scan_resource_status := output.get("scanResourceStatus")) is not None:
        kwargs["scan_resource_status"] = _deserialize_scan_resource_status_list(
            _scan_resource_status, config
        )

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    return ListScanResourceStatusOutput(**kwargs)


async def _deserialize_error_list_scan_resource_status(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_scans(
    http_response: HTTPResponse, config: Config
) -> ListScansOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_scans(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_scans := output.get("scans")) is not None:
        kwargs["scans"] = _deserialize_scans_list(_scans, config)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListScansOutput(**kwargs)


async def _deserialize_error_list_scans(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_toms(
    http_response: HTTPResponse, config: Config
) -> ListTomsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_toms(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    return ListTomsOutput(**kwargs)


async def _deserialize_error_list_toms(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_top_resources_with_sensitive_data_details(
    http_response: HTTPResponse, config: Config
) -> ListTopResourcesWithSensitiveDataDetailsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_top_resources_with_sensitive_data_details(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_resource_sensitive_data_details_list(
            _resources, config
        )

    return ListTopResourcesWithSensitiveDataDetailsOutput(**kwargs)


async def _deserialize_error_list_top_resources_with_sensitive_data_details(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_list_user_profiles(
    http_response: HTTPResponse, config: Config
) -> ListUserProfilesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_user_profiles(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_user_profiles := output.get("userProfiles")) is not None:
        kwargs["user_profiles"] = _deserialize_user_profile_list(_user_profiles, config)

    if (_sort := output.get("sort")) is not None:
        kwargs["sort"] = _deserialize_sort_records(_sort, config)

    if (_next_token := output.get("nextToken")) is not None:
        kwargs["next_token"] = expect_type(str, _next_token)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    return ListUserProfilesOutput(**kwargs)


async def _deserialize_error_list_user_profiles(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_page_insights_export(
    http_response: HTTPResponse, config: Config
) -> PageInsightsExportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_page_insights_export(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return PageInsightsExportOutput(**kwargs)


async def _deserialize_error_page_insights_export(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_pa_stats_time_series(
    http_response: HTTPResponse, config: Config
) -> PaStatsTimeSeriesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_pa_stats_time_series(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "result" not in output:
        raise ServiceError(
            'Expected to find "result" in the operation output, but it was not present.'
        )
    kwargs["result"] = _deserialize_pa_stats_time_series_list(output["result"], config)

    return PaStatsTimeSeriesOutput(**kwargs)


async def _deserialize_error_pa_stats_time_series(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_pause_scan(
    http_response: HTTPResponse, config: Config
) -> PauseScanOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_pause_scan(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "scanId" not in output:
        raise ServiceError(
            'Expected to find "scanId" in the operation output, but it was not present.'
        )
    kwargs["scan_id"] = expect_type(str, output["scanId"])

    return PauseScanOutput(**kwargs)


async def _deserialize_error_pause_scan(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_poll_domain(
    http_response: HTTPResponse, config: Config
) -> PollDomainOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_poll_domain(http_response, config)

    kwargs: dict[str, Any] = {}

    return PollDomainOutput(**kwargs)


async def _deserialize_error_poll_domain(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_prepare_detailed_inspection_result(
    http_response: HTTPResponse, config: Config
) -> PrepareDetailedInspectionResultOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_prepare_detailed_inspection_result(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    if (_success := output.get("success")) is not None:
        kwargs["success"] = expect_type(bool, _success)

    return PrepareDetailedInspectionResultOutput(**kwargs)


async def _deserialize_error_prepare_detailed_inspection_result(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_asset(
    http_response: HTTPResponse, config: Config
) -> RemoveAssetOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_asset(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveAssetOutput(**kwargs)


async def _deserialize_error_remove_asset(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_category(
    http_response: HTTPResponse, config: Config
) -> RemoveCategoryOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_category(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "categoryLabel" not in output:
        raise ServiceError(
            'Expected to find "categoryLabel" in the operation output, but it was not present.'
        )
    kwargs["category_label"] = expect_type(str, output["categoryLabel"])

    return RemoveCategoryOutput(**kwargs)


async def _deserialize_error_remove_category(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> RemoveDashboardReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_dashboard_report(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "dashboardReportId" not in output:
        raise ServiceError(
            'Expected to find "dashboardReportId" in the operation output, but it was not present.'
        )
    kwargs["dashboard_report_id"] = expect_type(str, output["dashboardReportId"])

    return RemoveDashboardReportOutput(**kwargs)


async def _deserialize_error_remove_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> RemoveDashboardUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_dashboard_user(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveDashboardUserOutput(**kwargs)


async def _deserialize_error_remove_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_data_breach(
    http_response: HTTPResponse, config: Config
) -> RemoveDataBreachOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_data_breach(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveDataBreachOutput(**kwargs)


async def _deserialize_error_remove_data_breach(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_data_breach_evaluation(
    http_response: HTTPResponse, config: Config
) -> RemoveDataBreachEvaluationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_data_breach_evaluation(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    return RemoveDataBreachEvaluationOutput(**kwargs)


async def _deserialize_error_remove_data_breach_evaluation(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_department(
    http_response: HTTPResponse, config: Config
) -> RemoveDepartmentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_department(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    return RemoveDepartmentOutput(**kwargs)


async def _deserialize_error_remove_department(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_domain(
    http_response: HTTPResponse, config: Config
) -> RemoveDomainOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_domain(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveDomainOutput(**kwargs)


async def _deserialize_error_remove_domain(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_dpia(
    http_response: HTTPResponse, config: Config
) -> RemoveDpiaOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_dpia(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveDpiaOutput(**kwargs)


async def _deserialize_error_remove_dpia(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_employee(
    http_response: HTTPResponse, config: Config
) -> RemoveEmployeeOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_employee(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveEmployeeOutput(**kwargs)


async def _deserialize_error_remove_employee(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_headquarter(
    http_response: HTTPResponse, config: Config
) -> RemoveHeadquarterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_headquarter(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveHeadquarterOutput(**kwargs)


async def _deserialize_error_remove_headquarter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_legal_document(
    http_response: HTTPResponse, config: Config
) -> RemoveLegalDocumentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_legal_document(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "documentId" not in output:
        raise ServiceError(
            'Expected to find "documentId" in the operation output, but it was not present.'
        )
    kwargs["document_id"] = expect_type(str, output["documentId"])

    return RemoveLegalDocumentOutput(**kwargs)


async def _deserialize_error_remove_legal_document(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> RemoveLopdpThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_lopdp_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveLopdpThresholdOutput(**kwargs)


async def _deserialize_error_remove_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_processing_activity(
    http_response: HTTPResponse, config: Config
) -> RemoveProcessingActivityOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_processing_activity(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveProcessingActivityOutput(**kwargs)


async def _deserialize_error_remove_processing_activity(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_recipient(
    http_response: HTTPResponse, config: Config
) -> RemoveRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_recipient(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveRecipientOutput(**kwargs)


async def _deserialize_error_remove_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_ta_dpia_file(
    http_response: HTTPResponse, config: Config
) -> RemoveTaDpiaFileOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_ta_dpia_file(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveTaDpiaFileOutput(**kwargs)


async def _deserialize_error_remove_ta_dpia_file(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_remove_threshold(
    http_response: HTTPResponse, config: Config
) -> RemoveThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_remove_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    return RemoveThresholdOutput(**kwargs)


async def _deserialize_error_remove_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_reset_password_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ResetPasswordDashboardUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_reset_password_dashboard_user(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    return ResetPasswordDashboardUserOutput(**kwargs)


async def _deserialize_error_reset_password_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_resume_scan(
    http_response: HTTPResponse, config: Config
) -> ResumeScanOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_resume_scan(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "scanId" not in output:
        raise ServiceError(
            'Expected to find "scanId" in the operation output, but it was not present.'
        )
    kwargs["scan_id"] = expect_type(str, output["scanId"])

    return ResumeScanOutput(**kwargs)


async def _deserialize_error_resume_scan(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_scan_legal_document(
    http_response: HTTPResponse, config: Config
) -> ScanLegalDocumentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_scan_legal_document(http_response, config)

    kwargs: dict[str, Any] = {}

    return ScanLegalDocumentOutput(**kwargs)


async def _deserialize_error_scan_legal_document(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_stop_scan(
    http_response: HTTPResponse, config: Config
) -> StopScanOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_stop_scan(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "scanId" not in output:
        raise ServiceError(
            'Expected to find "scanId" in the operation output, but it was not present.'
        )
    kwargs["scan_id"] = expect_type(str, output["scanId"])

    return StopScanOutput(**kwargs)


async def _deserialize_error_stop_scan(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_classification_stats(
    http_response: HTTPResponse, config: Config
) -> SummarizeClassificationStatsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_classification_stats(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_classification_stats(_result, config)

    return SummarizeClassificationStatsOutput(**kwargs)


async def _deserialize_error_summarize_classification_stats(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_data_identifier_stats(
    http_response: HTTPResponse, config: Config
) -> SummarizeDataIdentifierStatsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_data_identifier_stats(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_identifier_stats(_stats, config)

    return SummarizeDataIdentifierStatsOutput(**kwargs)


async def _deserialize_error_summarize_data_identifier_stats(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_data_stats(
    http_response: HTTPResponse, config: Config
) -> SummarizeDataStatsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_data_stats(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_resource_data_stats(_result, config)

    return SummarizeDataStatsOutput(**kwargs)


async def _deserialize_error_summarize_data_stats(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_pa_stats_for_owners(
    http_response: HTTPResponse, config: Config
) -> SummarizePaStatsForOwnersOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_pa_stats_for_owners(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_pa_stats_per_owner_list(_result, config)

    return SummarizePaStatsForOwnersOutput(**kwargs)


async def _deserialize_error_summarize_pa_stats_for_owners(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_resource_stats(
    http_response: HTTPResponse, config: Config
) -> SummarizeResourceStatsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_resource_stats(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_resource_stats(_result, config)

    return SummarizeResourceStatsOutput(**kwargs)


async def _deserialize_error_summarize_resource_stats(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_resource_trends(
    http_response: HTTPResponse, config: Config
) -> SummarizeResourceTrendsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_resource_trends(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_total := output.get("total")) is not None:
        kwargs["total"] = expect_type(int, _total)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_resource_trends_list(_result, config)

    return SummarizeResourceTrendsOutput(**kwargs)


async def _deserialize_error_summarize_resource_trends(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_resource_type_data_identifier_counts(
    http_response: HTTPResponse, config: Config
) -> SummarizeResourceTypeDataIdentifierCountsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_resource_type_data_identifier_counts(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_identifier_stats(_stats, config)

    return SummarizeResourceTypeDataIdentifierCountsOutput(**kwargs)


async def _deserialize_error_summarize_resource_type_data_identifier_counts(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_summarize_scan_stats(
    http_response: HTTPResponse, config: Config
) -> SummarizeScanStatsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_summarize_scan_stats(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_result := output.get("result")) is not None:
        kwargs["result"] = _deserialize_summary_scan_stats(_result, config)

    return SummarizeScanStatsOutput(**kwargs)


async def _deserialize_error_summarize_scan_stats(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_untag_entities(
    http_response: HTTPResponse, config: Config
) -> UntagEntitiesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_untag_entities(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_results := output.get("results")) is not None:
        kwargs["results"] = _deserialize_tagging_results_list(_results, config)

    return UntagEntitiesOutput(**kwargs)


async def _deserialize_error_untag_entities(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_asset(
    http_response: HTTPResponse, config: Config
) -> UpdateAssetOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_asset(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateAssetOutput(**kwargs)


async def _deserialize_error_update_asset(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_category(
    http_response: HTTPResponse, config: Config
) -> UpdateCategoryOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_category(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "categoryLabel" not in output:
        raise ServiceError(
            'Expected to find "categoryLabel" in the operation output, but it was not present.'
        )
    kwargs["category_label"] = expect_type(str, output["categoryLabel"])

    return UpdateCategoryOutput(**kwargs)


async def _deserialize_error_update_category(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> UpdateDashboardReportOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_dashboard_report(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "dashboardReportId" not in output:
        raise ServiceError(
            'Expected to find "dashboardReportId" in the operation output, but it was not present.'
        )
    kwargs["dashboard_report_id"] = expect_type(str, output["dashboardReportId"])

    return UpdateDashboardReportOutput(**kwargs)


async def _deserialize_error_update_dashboard_report(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> UpdateDashboardUserOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_dashboard_user(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateDashboardUserOutput(**kwargs)


async def _deserialize_error_update_dashboard_user(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_dashboard_user_roles(
    http_response: HTTPResponse, config: Config
) -> UpdateDashboardUserRolesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_dashboard_user_roles(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    return UpdateDashboardUserRolesOutput(**kwargs)


async def _deserialize_error_update_dashboard_user_roles(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_data_breach(
    http_response: HTTPResponse, config: Config
) -> UpdateDataBreachOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_data_breach(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateDataBreachOutput(**kwargs)


async def _deserialize_error_update_data_breach(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_data_breach_evaluation(
    http_response: HTTPResponse, config: Config
) -> UpdateDataBreachEvaluationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_data_breach_evaluation(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    return UpdateDataBreachEvaluationOutput(**kwargs)


async def _deserialize_error_update_data_breach_evaluation(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_department(
    http_response: HTTPResponse, config: Config
) -> UpdateDepartmentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_department(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    return UpdateDepartmentOutput(**kwargs)


async def _deserialize_error_update_department(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_discovered_document(
    http_response: HTTPResponse, config: Config
) -> UpdateDiscoveredDocumentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_discovered_document(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateDiscoveredDocumentOutput(**kwargs)


async def _deserialize_error_update_discovered_document(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_discovered_infotypes(
    http_response: HTTPResponse, config: Config
) -> UpdateDiscoveredInfotypesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_discovered_infotypes(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "discoveredInfotypeId" not in output:
        raise ServiceError(
            'Expected to find "discoveredInfotypeId" in the operation output, but it was not present.'
        )
    kwargs["discovered_infotype_id"] = expect_type(str, output["discoveredInfotypeId"])

    return UpdateDiscoveredInfotypesOutput(**kwargs)


async def _deserialize_error_update_discovered_infotypes(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_domain(
    http_response: HTTPResponse, config: Config
) -> UpdateDomainOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_domain(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateDomainOutput(**kwargs)


async def _deserialize_error_update_domain(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_dpia(
    http_response: HTTPResponse, config: Config
) -> UpdateDpiaOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_dpia(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateDpiaOutput(**kwargs)


async def _deserialize_error_update_dpia(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_employee(
    http_response: HTTPResponse, config: Config
) -> UpdateEmployeeOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_employee(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    return UpdateEmployeeOutput(**kwargs)


async def _deserialize_error_update_employee(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_updatefeedback(
    http_response: HTTPResponse, config: Config
) -> UpdatefeedbackOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_updatefeedback(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return UpdatefeedbackOutput(**kwargs)


async def _deserialize_error_updatefeedback(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_headquarter(
    http_response: HTTPResponse, config: Config
) -> UpdateHeadquarterOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_headquarter(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateHeadquarterOutput(**kwargs)


async def _deserialize_error_update_headquarter(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> UpdateLopdpThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_lopdp_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateLopdpThresholdOutput(**kwargs)


async def _deserialize_error_update_lopdp_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_processing_activity(
    http_response: HTTPResponse, config: Config
) -> UpdateProcessingActivityOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_processing_activity(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateProcessingActivityOutput(**kwargs)


async def _deserialize_error_update_processing_activity(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_recipient(
    http_response: HTTPResponse, config: Config
) -> UpdateRecipientOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_recipient(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateRecipientOutput(**kwargs)


async def _deserialize_error_update_recipient(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_recipient_status(
    http_response: HTTPResponse, config: Config
) -> UpdateRecipientStatusOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_recipient_status(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateRecipientStatusOutput(**kwargs)


async def _deserialize_error_update_recipient_status(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_ta_dpia_file(
    http_response: HTTPResponse, config: Config
) -> UpdateTaDpiaFileOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_ta_dpia_file(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateTaDpiaFileOutput(**kwargs)


async def _deserialize_error_update_ta_dpia_file(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_threshold(
    http_response: HTTPResponse, config: Config
) -> UpdateThresholdOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_threshold(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateThresholdOutput(**kwargs)


async def _deserialize_error_update_threshold(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_update_tom(
    http_response: HTTPResponse, config: Config
) -> UpdateTomOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_tom(http_response, config)

    kwargs: dict[str, Any] = {}

    return UpdateTomOutput(**kwargs)


async def _deserialize_error_update_tom(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "notallowed":
            return await _deserialize_error_not_allowed(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_validate_clone_pa_for_target_org(
    http_response: HTTPResponse, config: Config
) -> ValidateClonePaForTargetOrgOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_validate_clone_pa_for_target_org(
            http_response, config
        )

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if "missingDpiaObjects" not in output:
        raise ServiceError(
            'Expected to find "missingDpiaObjects" in the operation output, but it was not present.'
        )
    kwargs["missing_dpia_objects"] = _deserialize_missing_dpia_objects(
        output["missingDpiaObjects"], config
    )

    if "missingOwner" not in output:
        raise ServiceError(
            'Expected to find "missingOwner" in the operation output, but it was not present.'
        )
    kwargs["missing_owner"] = expect_type(bool, output["missingOwner"])

    if "missingProcessingActivityObjects" not in output:
        raise ServiceError(
            'Expected to find "missingProcessingActivityObjects" in the operation output, but it was not present.'
        )
    kwargs["missing_processing_activity_objects"] = (
        _deserialize_missing_processing_activity_objects(
            output["missingProcessingActivityObjects"], config
        )
    )

    return ValidateClonePaForTargetOrgOutput(**kwargs)


async def _deserialize_error_validate_clone_pa_for_target_org(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_verify_email(
    http_response: HTTPResponse, config: Config
) -> VerifyEmailOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_verify_email(http_response, config)

    kwargs: dict[str, Any] = {}

    output: dict[str, DocumentValue] = {}
    if body := await http_response.consume_body_async():
        output = json.loads(body)

    if (_token := output.get("token")) is not None:
        kwargs["token"] = expect_type(str, _token)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if "verificationId" not in output:
        raise ServiceError(
            'Expected to find "verificationId" in the operation output, but it was not present.'
        )
    kwargs["verification_id"] = expect_type(str, output["verificationId"])

    if (_is_used := output.get("isUsed")) is not None:
        kwargs["is_used"] = expect_type(bool, _is_used)

    if (_expires_at := output.get("expiresAt")) is not None:
        kwargs["expires_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _expires_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    return VerifyEmailOutput(**kwargs)


async def _deserialize_error_verify_email(
    http_response: HTTPResponse, config: Config
) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "unauthorized":
            return await _deserialize_error_unauthorized(
                http_response, config, parsed_body, message
            )

        case "validationexception":
            return await _deserialize_error_validation_exception(
                http_response, config, parsed_body, message
            )

        case "datavalidationexception":
            return await _deserialize_error_data_validation_exception(
                http_response, config, parsed_body, message
            )

        case "unexpectedservererror":
            return await _deserialize_error_unexpected_server_error(
                http_response, config, parsed_body, message
            )

        case "nosuchresource":
            return await _deserialize_error_no_such_resource(
                http_response, config, parsed_body, message
            )

        case _:
            return UnknownApiError(message)


async def _deserialize_error_data_validation_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> DataValidationException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if (_data := output.get("data")) is not None:
        kwargs["data"] = Document(_data)

    if (_message := output.get("message")) is not None:
        kwargs["message"] = expect_type(str, _message)

    if (_field_list := output.get("fieldList")) is not None:
        kwargs["field_list"] = _deserialize_field_list(_field_list, config)

    return DataValidationException(**kwargs)


async def _deserialize_error_no_such_resource(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> NoSuchResource:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "resourceType" not in output:
        raise ServiceError(
            'Expected to find "resourceType" in the operation output, but it was not present.'
        )
    kwargs["resource_type"] = expect_type(str, output["resourceType"])

    return NoSuchResource(**kwargs)


async def _deserialize_error_not_allowed(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> NotAllowed:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError(
            'Expected to find "message" in the operation output, but it was not present.'
        )
    kwargs["message"] = expect_type(str, output["message"])

    return NotAllowed(**kwargs)


async def _deserialize_error_unauthorized(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> Unauthorized:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if (_message := output.get("message")) is not None:
        kwargs["message"] = expect_type(str, _message)

    return Unauthorized(**kwargs)


async def _deserialize_error_unexpected_server_error(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> UnexpectedServerError:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if "message" not in output:
        raise ServiceError(
            'Expected to find "message" in the operation output, but it was not present.'
        )
    kwargs["message"] = expect_type(str, output["message"])

    return UnexpectedServerError(**kwargs)


async def _deserialize_error_validation_exception(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> ValidationException:
    kwargs: dict[str, Any] = {"message": default_message}

    if (parsed_body is None) and (body := await http_response.consume_body_async()):
        parsed_body = json.loads(body)

    output: dict[str, DocumentValue] = parsed_body if parsed_body is not None else {}

    if (_field_list := output.get("fieldList")) is not None:
        kwargs["field_list"] = _deserialize_validation_exception_field_list(
            _field_list, config
        )

    if "message" not in output:
        raise ServiceError(
            'Expected to find "message" in the operation output, but it was not present.'
        )
    kwargs["message"] = expect_type(str, output["message"])

    return ValidationException(**kwargs)


def _deserialize_access_log_member(
    output: DocumentValue, config: Config
) -> AccessLogMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_time := output.get("time")) is not None:
        kwargs["time"] = expect_type(str, _time)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_request_id := output.get("requestId")) is not None:
        kwargs["request_id"] = expect_type(str, _request_id)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_unique_string_list(_roles, config)

    if (_operation := output.get("operation")) is not None:
        kwargs["operation"] = expect_type(str, _operation)

    if (_msg := output.get("msg")) is not None:
        kwargs["msg"] = expect_type(str, _msg)

    if (_input := output.get("input")) is not None:
        kwargs["input"] = Document(_input)

    return AccessLogMember(**kwargs)


def _deserialize_access_logs_results(
    output: DocumentValue, config: Config
) -> list[AccessLogMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_access_log_member(e, config) for e in output]


def _deserialize_account_list_member(
    output: DocumentValue, config: Config
) -> AccountListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "accountId" not in output:
        raise ServiceError(
            'Expected to find "accountId" in the operation output, but it was not present.'
        )
    kwargs["account_id"] = expect_type(str, output["accountId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_cloud_account_id := output.get("cloudAccountId")) is not None:
        kwargs["cloud_account_id"] = expect_type(str, _cloud_account_id)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_account_roles(_roles, config)

    if (_permissions := output.get("permissions")) is not None:
        kwargs["permissions"] = _deserialize_account_permissions(_permissions, config)

    if (_status_details := output.get("statusDetails")) is not None:
        kwargs["status_details"] = _deserialize_account_status_details(
            _status_details, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    return AccountListMember(**kwargs)


def _deserialize_account_permissions(
    output: DocumentValue, config: Config
) -> AccountPermissions:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "enableInventoryPolicy" not in output:
        raise ServiceError(
            'Expected to find "enableInventoryPolicy" in the operation output, but it was not present.'
        )
    kwargs["enable_inventory_policy"] = expect_type(
        bool, output["enableInventoryPolicy"]
    )

    if "enableAwsConfigPolicy" not in output:
        raise ServiceError(
            'Expected to find "enableAwsConfigPolicy" in the operation output, but it was not present.'
        )
    kwargs["enable_aws_config_policy"] = expect_type(
        bool, output["enableAwsConfigPolicy"]
    )

    if "enableDataplaneDeployPolicy" not in output:
        raise ServiceError(
            'Expected to find "enableDataplaneDeployPolicy" in the operation output, but it was not present.'
        )
    kwargs["enable_dataplane_deploy_policy"] = expect_type(
        bool, output["enableDataplaneDeployPolicy"]
    )

    if "enableDpCli" not in output:
        raise ServiceError(
            'Expected to find "enableDpCli" in the operation output, but it was not present.'
        )
    kwargs["enable_dp_cli"] = expect_type(bool, output["enableDpCli"])

    if "regions" not in output:
        raise ServiceError(
            'Expected to find "regions" in the operation output, but it was not present.'
        )
    kwargs["regions"] = _deserialize_unique_string_list(output["regions"], config)

    if (
        _add_event_bridge_permission := output.get("addEventBridgePermission")
    ) is not None:
        kwargs["add_event_bridge_permission"] = expect_type(
            bool, _add_event_bridge_permission
        )

    if (_trusted_data_planes := output.get("trustedDataPlanes")) is not None:
        kwargs["trusted_data_planes"] = _deserialize_unique_string_list(
            _trusted_data_planes, config
        )

    if (_enabled_resource_types := output.get("enabledResourceTypes")) is not None:
        kwargs["enabled_resource_types"] = _deserialize_enabled_resource_type_list(
            _enabled_resource_types, config
        )

    return AccountPermissions(**kwargs)


def _deserialize_account_role(output: DocumentValue, config: Config) -> AccountRole:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_external_id := output.get("externalId")) is not None:
        kwargs["external_id"] = expect_type(str, _external_id)

    if (_validations := output.get("validations")) is not None:
        kwargs["validations"] = _deserialize_account_role_validations(
            _validations, config
        )

    return AccountRole(**kwargs)


def _deserialize_account_roles(
    output: DocumentValue, config: Config
) -> list[AccountRole]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_account_role(e, config) for e in output]


def _deserialize_account_role_validation(
    output: DocumentValue, config: Config
) -> AccountRoleValidation:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_validated := output.get("validated")) is not None:
        kwargs["validated"] = expect_type(bool, _validated)

    if (_data_plane_id := output.get("dataPlaneId")) is not None:
        kwargs["data_plane_id"] = expect_type(str, _data_plane_id)

    return AccountRoleValidation(**kwargs)


def _deserialize_account_role_validations(
    output: DocumentValue, config: Config
) -> list[AccountRoleValidation]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_account_role_validation(e, config) for e in output]


def _deserialize_accounts_list(
    output: DocumentValue, config: Config
) -> list[AccountListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_account_list_member(e, config) for e in output]


def _deserialize_account_status_details(
    output: DocumentValue, config: Config
) -> AccountStatusDetails:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_validation_time := output.get("validationTime")) is not None:
        kwargs["validation_time"] = expect_type(int, _validation_time)

    if (_validation_message := output.get("validationMessage")) is not None:
        kwargs["validation_message"] = expect_type(str, _validation_message)

    return AccountStatusDetails(**kwargs)


def _deserialize_active_resources_stats(
    output: DocumentValue, config: Config
) -> ActiveResourcesStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_timestamp := output.get("timestamp")) is not None:
        kwargs["timestamp"] = epoch_seconds_to_datetime(
            expect_type(int | float, _timestamp)
        )

    if (_active_count := output.get("activeCount")) is not None:
        kwargs["active_count"] = expect_type(int, _active_count)

    return ActiveResourcesStats(**kwargs)


def _deserialize_active_resources_stats_list(
    output: DocumentValue, config: Config
) -> list[ActiveResourcesStats]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_active_resources_stats(e, config) for e in output]


def _deserialize_aggregate_scan_stats(
    output: DocumentValue, config: Config
) -> AggregateScanStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_scan_durationin_ms := output.get("scanDurationinMs")) is not None:
        kwargs["scan_durationin_ms"] = limited_parse_float(_scan_durationin_ms)

    if (_data_scanned := output.get("dataScanned")) is not None:
        kwargs["data_scanned"] = limited_parse_float(_data_scanned)

    if (_identifiers_matched := output.get("identifiersMatched")) is not None:
        kwargs["identifiers_matched"] = expect_type(int, _identifiers_matched)

    if (_scanned_resources := output.get("scannedResources")) is not None:
        kwargs["scanned_resources"] = expect_type(int, _scanned_resources)

    if (_total_resource_count := output.get("totalResourceCount")) is not None:
        kwargs["total_resource_count"] = expect_type(int, _total_resource_count)

    if (_failed_scans := output.get("failedScans")) is not None:
        kwargs["failed_scans"] = expect_type(int, _failed_scans)

    if (_total_scans := output.get("totalScans")) is not None:
        kwargs["total_scans"] = expect_type(int, _total_scans)

    if (_successful_scans := output.get("successfulScans")) is not None:
        kwargs["successful_scans"] = expect_type(int, _successful_scans)

    if (_repeated_scans := output.get("repeatedScans")) is not None:
        kwargs["repeated_scans"] = expect_type(int, _repeated_scans)

    if (_one_time_scans := output.get("oneTimeScans")) is not None:
        kwargs["one_time_scans"] = expect_type(int, _one_time_scans)

    if (_full_scans := output.get("fullScans")) is not None:
        kwargs["full_scans"] = expect_type(int, _full_scans)

    if (_sample_scans := output.get("sampleScans")) is not None:
        kwargs["sample_scans"] = expect_type(int, _sample_scans)

    if (
        _increment_scanned_resources := output.get("incrementScannedResources")
    ) is not None:
        kwargs["increment_scanned_resources"] = expect_type(
            int, _increment_scanned_resources
        )

    return AggregateScanStats(**kwargs)


def _deserialize_asset_list(
    output: DocumentValue, config: Config
) -> list[AssetListRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_asset_list_record(e, config) for e in output]


def _deserialize_asset_list_record(
    output: DocumentValue, config: Config
) -> AssetListRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "assetId" not in output:
        raise ServiceError(
            'Expected to find "assetId" in the operation output, but it was not present.'
        )
    kwargs["asset_id"] = expect_type(str, output["assetId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_location_type := output.get("locationType")) is not None:
        kwargs["location_type"] = expect_type(str, _location_type)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    if (_location := output.get("location")) is not None:
        kwargs["location"] = _deserialize_headquarter_record(_location, config)

    if (
        _no_of_processing_activities := output.get("noOfProcessingActivities")
    ) is not None:
        kwargs["no_of_processing_activities"] = expect_type(
            int, _no_of_processing_activities
        )

    return AssetListRecord(**kwargs)


def _deserialize_asset_record(output: DocumentValue, config: Config) -> AssetRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "assetId" not in output:
        raise ServiceError(
            'Expected to find "assetId" in the operation output, but it was not present.'
        )
    kwargs["asset_id"] = expect_type(str, output["assetId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_tom_ids := output.get("tomIds")) is not None:
        kwargs["tom_ids"] = _deserialize_uuid_collection(_tom_ids, config)

    if (_location_type := output.get("locationType")) is not None:
        kwargs["location_type"] = expect_type(str, _location_type)

    if (_location_id := output.get("locationId")) is not None:
        kwargs["location_id"] = expect_type(str, _location_id)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    if (_location := output.get("location")) is not None:
        kwargs["location"] = _deserialize_headquarter_record(_location, config)

    return AssetRecord(**kwargs)


def _deserialize_audit_logs_results(
    output: DocumentValue, config: Config
) -> list[Document]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [Document(e) for e in output]


def _deserialize_calendar_spec(output: DocumentValue, config: Config) -> CalendarSpec:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_second := output.get("second")) is not None:
        kwargs["second"] = expect_type(int, _second)

    if (_minute := output.get("minute")) is not None:
        kwargs["minute"] = expect_type(int, _minute)

    if (_hour := output.get("hour")) is not None:
        kwargs["hour"] = expect_type(int, _hour)

    if (_day_of_month := output.get("dayOfMonth")) is not None:
        kwargs["day_of_month"] = expect_type(int, _day_of_month)

    if (_month := output.get("month")) is not None:
        kwargs["month"] = expect_type(str, _month)

    if (_year := output.get("year")) is not None:
        kwargs["year"] = expect_type(int, _year)

    return CalendarSpec(**kwargs)


def _deserialize_calendar_spec_list(
    output: DocumentValue, config: Config
) -> list[CalendarSpec]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_calendar_spec(e, config) for e in output]


def _deserialize_category_list(
    output: DocumentValue, config: Config
) -> list[CategoryListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_category_list_member(e, config) for e in output]


def _deserialize_category_list_member(
    output: DocumentValue, config: Config
) -> CategoryListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "categoryLabel" not in output:
        raise ServiceError(
            'Expected to find "categoryLabel" in the operation output, but it was not present.'
        )
    kwargs["category_label"] = expect_type(str, output["categoryLabel"])

    if "description" not in output:
        raise ServiceError(
            'Expected to find "description" in the operation output, but it was not present.'
        )
    kwargs["description"] = expect_type(str, output["description"])

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return CategoryListMember(**kwargs)


def _deserialize_change_in_processing_activity_stats_output(
    output: DocumentValue, config: Config
) -> ChangeInProcessingActivityStatsOutput:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_pa_in_draft_change := output.get("paInDraftChange")) is not None:
        kwargs["pa_in_draft_change"] = expect_type(int, _pa_in_draft_change)

    if (_pending_ta_change := output.get("pendingTAChange")) is not None:
        kwargs["pending_ta_change"] = expect_type(int, _pending_ta_change)

    if (_ta_in_draft_change := output.get("taInDraftChange")) is not None:
        kwargs["ta_in_draft_change"] = expect_type(int, _ta_in_draft_change)

    if (_dpia_optional_change := output.get("dpiaOptionalChange")) is not None:
        kwargs["dpia_optional_change"] = expect_type(int, _dpia_optional_change)

    if (_dpia_recommended_change := output.get("dpiaRecommendedChange")) is not None:
        kwargs["dpia_recommended_change"] = expect_type(int, _dpia_recommended_change)

    if (_dpia_required_change := output.get("dpiaRequiredChange")) is not None:
        kwargs["dpia_required_change"] = expect_type(int, _dpia_required_change)

    if (_dpia_in_draft_change := output.get("dpiaInDraftChange")) is not None:
        kwargs["dpia_in_draft_change"] = expect_type(int, _dpia_in_draft_change)

    if (_dpia_completed_change := output.get("dpiaCompletedChange")) is not None:
        kwargs["dpia_completed_change"] = expect_type(int, _dpia_completed_change)

    if (_total_pa_change := output.get("totalPAChange")) is not None:
        kwargs["total_pa_change"] = expect_type(int, _total_pa_change)

    if (_complete_ta_change := output.get("completeTAChange")) is not None:
        kwargs["complete_ta_change"] = expect_type(int, _complete_ta_change)

    if (_readiness_score_change := output.get("readinessScoreChange")) is not None:
        kwargs["readiness_score_change"] = expect_type(int, _readiness_score_change)

    if (
        _required_dpias_in_draft_change := output.get("requiredDpiasInDraftChange")
    ) is not None:
        kwargs["required_dpias_in_draft_change"] = expect_type(
            int, _required_dpias_in_draft_change
        )

    if (_all_required_dpia_change := output.get("allRequiredDpiaChange")) is not None:
        kwargs["all_required_dpia_change"] = expect_type(int, _all_required_dpia_change)

    if (_previous_reading_date := output.get("previousReadingDate")) is not None:
        kwargs["previous_reading_date"] = epoch_seconds_to_datetime(
            expect_type(int | float, _previous_reading_date)
        )

    if (_current_reading_date := output.get("currentReadingDate")) is not None:
        kwargs["current_reading_date"] = epoch_seconds_to_datetime(
            expect_type(int | float, _current_reading_date)
        )

    return ChangeInProcessingActivityStatsOutput(**kwargs)


def _deserialize_classification_stats(
    output: DocumentValue, config: Config
) -> dict[str, list[ClassificationStatsData]]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_classification_stats_list(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_classification_stats_data(
    output: DocumentValue, config: Config
) -> ClassificationStatsData:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_classification := output.get("classification")) is not None:
        kwargs["classification"] = expect_type(str, _classification)

    return ClassificationStatsData(**kwargs)


def _deserialize_classification_stats_list(
    output: DocumentValue, config: Config
) -> list[ClassificationStatsData]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_classification_stats_data(e, config) for e in output]


def _deserialize_cloud_account(output: DocumentValue, config: Config) -> CloudAccount:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_cloud_provider := output.get("cloudProvider")) is not None:
        kwargs["cloud_provider"] = expect_type(str, _cloud_provider)

    if (_cloud_connection_name := output.get("cloudConnectionName")) is not None:
        kwargs["cloud_connection_name"] = expect_type(str, _cloud_connection_name)

    return CloudAccount(**kwargs)


def _deserialize_company_role_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_compliance_detail(
    output: DocumentValue, config: Config
) -> ComplianceDetail:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_compliant := output.get("compliant")) is not None:
        kwargs["compliant"] = expect_type(bool, _compliant)

    if (_infotypes := output.get("infotypes")) is not None:
        kwargs["infotypes"] = _deserialize_unique_string_list(_infotypes, config)

    return ComplianceDetail(**kwargs)


def _deserialize_compliance_detail_list(
    output: DocumentValue, config: Config
) -> list[ComplianceDetail]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_compliance_detail(e, config) for e in output]


def _deserialize_compliance_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_compliance_risk(
    output: DocumentValue, config: Config
) -> ComplianceRisk:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_infotypes := output.get("infotypes")) is not None:
        kwargs["infotypes"] = _deserialize_unique_string_list(_infotypes, config)

    if (_classifications := output.get("classifications")) is not None:
        kwargs["classifications"] = _deserialize_unique_string_list(
            _classifications, config
        )

    if (_sensitive := output.get("sensitive")) is not None:
        kwargs["sensitive"] = expect_type(bool, _sensitive)

    return ComplianceRisk(**kwargs)


def _deserialize_confidence_snapshot(
    output: DocumentValue, config: Config
) -> ConfidenceSnapshot:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_certain_count := output.get("certainCount")) is not None:
        kwargs["certain_count"] = expect_type(int, _certain_count)

    if (_likely_count := output.get("likelyCount")) is not None:
        kwargs["likely_count"] = expect_type(int, _likely_count)

    if (_possible_count := output.get("possibleCount")) is not None:
        kwargs["possible_count"] = expect_type(int, _possible_count)

    if (_found := output.get("found")) is not None:
        kwargs["found"] = expect_type(bool, _found)

    if (_columns := output.get("columns")) is not None:
        kwargs["columns"] = _deserialize_unique_string_list(_columns, config)

    return ConfidenceSnapshot(**kwargs)


def _deserialize_connector_list_member(
    output: DocumentValue, config: Config
) -> ConnectorListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "connectorId" not in output:
        raise ServiceError(
            'Expected to find "connectorId" in the operation output, but it was not present.'
        )
    kwargs["connector_id"] = expect_type(str, output["connectorId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_status_details := output.get("statusDetails")) is not None:
        kwargs["status_details"] = _deserialize_connector_status_details(
            _status_details, config
        )

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    if (_data_plane_id := output.get("dataPlaneId")) is not None:
        kwargs["data_plane_id"] = expect_type(str, _data_plane_id)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_connector_type := output.get("connectorType")) is not None:
        kwargs["connector_type"] = expect_type(str, _connector_type)

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_params := output.get("params")) is not None:
        kwargs["params"] = _deserialize_open_properties(_params, config)

    if (_resource_account_id := output.get("resourceAccountId")) is not None:
        kwargs["resource_account_id"] = expect_type(str, _resource_account_id)

    if (_gcp_connection_id := output.get("gcpConnectionId")) is not None:
        kwargs["gcp_connection_id"] = expect_type(str, _gcp_connection_id)

    if (
        _next_meta_data_sync_schedule := output.get("nextMetaDataSyncSchedule")
    ) is not None:
        kwargs["next_meta_data_sync_schedule"] = epoch_seconds_to_datetime(
            expect_type(int | float, _next_meta_data_sync_schedule)
        )

    if (_is_meta_data_sync_running := output.get("isMetaDataSyncRunning")) is not None:
        kwargs["is_meta_data_sync_running"] = expect_type(
            bool, _is_meta_data_sync_running
        )

    if (_meta_data_sync_interval := output.get("metaDataSyncInterval")) is not None:
        kwargs["meta_data_sync_interval"] = expect_type(str, _meta_data_sync_interval)

    if (
        _custom_meta_data_sync_interval := output.get("customMetaDataSyncInterval")
    ) is not None:
        kwargs["custom_meta_data_sync_interval"] = expect_type(
            str, _custom_meta_data_sync_interval
        )

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    return ConnectorListMember(**kwargs)


def _deserialize_connectors_list(
    output: DocumentValue, config: Config
) -> list[ConnectorListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_connector_list_member(e, config) for e in output]


def _deserialize_connector_status_details(
    output: DocumentValue, config: Config
) -> ConnectorStatusDetails:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_validation_time := output.get("validationTime")) is not None:
        kwargs["validation_time"] = expect_type(int, _validation_time)

    if (_validation_message := output.get("validationMessage")) is not None:
        kwargs["validation_message"] = expect_type(str, _validation_message)

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    return ConnectorStatusDetails(**kwargs)


def _deserialize_context_id_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_country_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_dashboard_report_delivery(
    output: DocumentValue, config: Config
) -> DashboardReportDelivery:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_report_delivery_id := output.get("reportDeliveryId")) is not None:
        kwargs["report_delivery_id"] = expect_type(str, _report_delivery_id)

    if (_report_edition_id := output.get("reportEditionId")) is not None:
        kwargs["report_edition_id"] = expect_type(str, _report_edition_id)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return DashboardReportDelivery(**kwargs)


def _deserialize_dashboard_report_delivery_list(
    output: DocumentValue, config: Config
) -> list[DashboardReportDelivery]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dashboard_report_delivery(e, config) for e in output]


def _deserialize_dashboard_report_edition_list(
    output: DocumentValue, config: Config
) -> list[DashboardReportEditionListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [
        _deserialize_dashboard_report_edition_list_member(e, config) for e in output
    ]


def _deserialize_dashboard_report_edition_list_member(
    output: DocumentValue, config: Config
) -> DashboardReportEditionListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "reportEditionId" not in output:
        raise ServiceError(
            'Expected to find "reportEditionId" in the operation output, but it was not present.'
        )
    kwargs["report_edition_id"] = expect_type(str, output["reportEditionId"])

    if (_dashboard_report_id := output.get("dashboardReportId")) is not None:
        kwargs["dashboard_report_id"] = expect_type(str, _dashboard_report_id)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    if (_frequency := output.get("frequency")) is not None:
        kwargs["frequency"] = expect_type(str, _frequency)

    if (_recipients_count := output.get("recipientsCount")) is not None:
        kwargs["recipients_count"] = expect_type(int, _recipients_count)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    if (_report_delivery := output.get("reportDelivery")) is not None:
        kwargs["report_delivery"] = _deserialize_dashboard_report_delivery_list(
            _report_delivery, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return DashboardReportEditionListMember(**kwargs)


def _deserialize_dashboard_report_list(
    output: DocumentValue, config: Config
) -> list[DashboardReportListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dashboard_report_list_member(e, config) for e in output]


def _deserialize_dashboard_report_list_member(
    output: DocumentValue, config: Config
) -> DashboardReportListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "dashboardReportId" not in output:
        raise ServiceError(
            'Expected to find "dashboardReportId" in the operation output, but it was not present.'
        )
    kwargs["dashboard_report_id"] = expect_type(str, output["dashboardReportId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_report_types := output.get("reportTypes")) is not None:
        kwargs["report_types"] = _deserialize_report_type_list(_report_types, config)

    if (_recipients_email := output.get("recipientsEmail")) is not None:
        kwargs["recipients_email"] = _deserialize_report_recipients(
            _recipients_email, config
        )

    if (_external_email := output.get("externalEmail")) is not None:
        kwargs["external_email"] = _deserialize_report_recipients(
            _external_email, config
        )

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_report_recipients_roles(_roles, config)

    if (_frequency := output.get("frequency")) is not None:
        kwargs["frequency"] = expect_type(str, _frequency)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_report_edition := output.get("reportEdition")) is not None:
        kwargs["report_edition"] = _deserialize_dashboard_report_edition_list(
            _report_edition, config
        )

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_last_sent_time := output.get("lastSentTime")) is not None:
        kwargs["last_sent_time"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_sent_time)
        )

    if (_next_send_time := output.get("nextSendTime")) is not None:
        kwargs["next_send_time"] = epoch_seconds_to_datetime(
            expect_type(int | float, _next_send_time)
        )

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return DashboardReportListMember(**kwargs)


def _deserialize_dashboard_user_record(
    output: DocumentValue, config: Config
) -> DashboardUserRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "username" not in output:
        raise ServiceError(
            'Expected to find "username" in the operation output, but it was not present.'
        )
    kwargs["username"] = expect_type(str, output["username"])

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_roles := output.get("roles")) is not None:
        kwargs["roles"] = _deserialize_dashboard_user_roles(_roles, config)

    if (_organisations := output.get("organisations")) is not None:
        kwargs["organisations"] = _deserialize_user_organisations(
            _organisations, config
        )

    if (_super_admin := output.get("superAdmin")) is not None:
        kwargs["super_admin"] = expect_type(bool, _super_admin)

    if (_enabled := output.get("enabled")) is not None:
        kwargs["enabled"] = expect_type(bool, _enabled)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_provider := output.get("provider")) is not None:
        kwargs["provider"] = expect_type(str, _provider)

    if (_external_provider := output.get("externalProvider")) is not None:
        kwargs["external_provider"] = expect_type(bool, _external_provider)

    if (_tenant_id := output.get("tenantId")) is not None:
        kwargs["tenant_id"] = expect_type(str, _tenant_id)

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_company_name := output.get("companyName")) is not None:
        kwargs["company_name"] = expect_type(str, _company_name)

    return DashboardUserRecord(**kwargs)


def _deserialize_dashboard_user_roles(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_data_breach_filter_filter_output_list(
    output: DocumentValue, config: Config
) -> list[DataBreachFilterFilterOutputListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [
        _deserialize_data_breach_filter_filter_output_list_member(e, config)
        for e in output
    ]


def _deserialize_data_breach_filter_filter_output_list_member(
    output: DocumentValue, config: Config
) -> DataBreachFilterFilterOutputListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DataBreachFilterFilterOutputListMember(**kwargs)


def _deserialize_data_breach_list(
    output: DocumentValue, config: Config
) -> list[DataBreachListRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_data_breach_list_record(e, config) for e in output]


def _deserialize_data_breach_list_record(
    output: DocumentValue, config: Config
) -> DataBreachListRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "dataBreachId" not in output:
        raise ServiceError(
            'Expected to find "dataBreachId" in the operation output, but it was not present.'
        )
    kwargs["data_breach_id"] = expect_type(str, output["dataBreachId"])

    if "sequence" not in output:
        raise ServiceError(
            'Expected to find "sequence" in the operation output, but it was not present.'
        )
    kwargs["sequence"] = expect_type(int, output["sequence"])

    if "shortDescription" not in output:
        raise ServiceError(
            'Expected to find "shortDescription" in the operation output, but it was not present.'
        )
    kwargs["short_description"] = expect_type(str, output["shortDescription"])

    if (_occurred_at := output.get("occurredAt")) is not None:
        kwargs["occurred_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _occurred_at)
        )

    if (_discovered_at := output.get("discoveredAt")) is not None:
        kwargs["discovered_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _discovered_at)
        )

    if "status" not in output:
        raise ServiceError(
            'Expected to find "status" in the operation output, but it was not present.'
        )
    kwargs["status"] = expect_type(str, output["status"])

    if "createdBy" not in output:
        raise ServiceError(
            'Expected to find "createdBy" in the operation output, but it was not present.'
        )
    kwargs["created_by"] = expect_type(str, output["createdBy"])

    if (_evaluated_by := output.get("evaluatedBy")) is not None:
        kwargs["evaluated_by"] = expect_type(str, _evaluated_by)

    return DataBreachListRecord(**kwargs)


def _deserialize_data_flow_relationship(
    output: DocumentValue, config: Config
) -> DataFlowRelationship:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "from" not in output:
        raise ServiceError(
            'Expected to find "from" in the operation output, but it was not present.'
        )
    kwargs["from_"] = _deserialize_data_flow_relationship_option(output["from"], config)

    if "to" not in output:
        raise ServiceError(
            'Expected to find "to" in the operation output, but it was not present.'
        )
    kwargs["to"] = _deserialize_data_flow_relationship_option(output["to"], config)

    return DataFlowRelationship(**kwargs)


def _deserialize_data_flow_relationship_option(
    output: DocumentValue, config: Config
) -> DataFlowRelationshipOption:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "type" not in output:
        raise ServiceError(
            'Expected to find "type" in the operation output, but it was not present.'
        )
    kwargs["type"] = expect_type(str, output["type"])

    if (_value := output.get("value")) is not None:
        kwargs["value"] = expect_type(str, _value)

    return DataFlowRelationshipOption(**kwargs)


def _deserialize_data_flow_relationships(
    output: DocumentValue, config: Config
) -> list[DataFlowRelationship]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_data_flow_relationship(e, config) for e in output]


def _deserialize_data_security_event(
    output: DocumentValue, config: Config
) -> DataSecurityEvent:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_event_id := output.get("eventId")) is not None:
        kwargs["event_id"] = expect_type(str, _event_id)

    if (_issue_id := output.get("issueId")) is not None:
        kwargs["issue_id"] = expect_type(str, _issue_id)

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_details := output.get("details")) is not None:
        kwargs["details"] = _deserialize_open_properties(_details, config)

    return DataSecurityEvent(**kwargs)


def _deserialize_data_security_event_list(
    output: DocumentValue, config: Config
) -> list[DataSecurityEvent]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_data_security_event(e, config) for e in output]


def _deserialize_data_size(output: DocumentValue, config: Config) -> DataSize:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_bytes_ := output.get("bytes")) is not None:
        kwargs["bytes_"] = expect_type(int, _bytes_)

    if (_rows := output.get("rows")) is not None:
        kwargs["rows"] = expect_type(int, _rows)

    if (_objects := output.get("objects")) is not None:
        kwargs["objects"] = expect_type(int, _objects)

    return DataSize(**kwargs)


def _deserialize_data_subject_collection(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_department_for_filter_list(
    output: DocumentValue, config: Config
) -> list[DepartmentForFilterMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_department_for_filter_member(e, config) for e in output]


def _deserialize_department_for_filter_member(
    output: DocumentValue, config: Config
) -> DepartmentForFilterMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    return DepartmentForFilterMember(**kwargs)


def _deserialize_department_list(
    output: DocumentValue, config: Config
) -> list[DepartmentListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_department_list_member(e, config) for e in output]


def _deserialize_department_list_member(
    output: DocumentValue, config: Config
) -> DepartmentListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_employees := output.get("employees")) is not None:
        kwargs["employees"] = expect_type(int, _employees)

    if (_processing_activities := output.get("processingActivities")) is not None:
        kwargs["processing_activities"] = expect_type(int, _processing_activities)

    if (_number_of_users := output.get("numberOfUsers")) is not None:
        kwargs["number_of_users"] = expect_type(int, _number_of_users)

    return DepartmentListMember(**kwargs)


def _deserialize_department_object(
    output: DocumentValue, config: Config
) -> DepartmentObject:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    return DepartmentObject(**kwargs)


def _deserialize_discovered_documents_list(
    output: DocumentValue, config: Config
) -> list[DiscoveredDocumentsListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_discovered_documents_list_member(e, config) for e in output]


def _deserialize_discovered_documents_list_member(
    output: DocumentValue, config: Config
) -> DiscoveredDocumentsListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "discoveredDocumentId" not in output:
        raise ServiceError(
            'Expected to find "discoveredDocumentId" in the operation output, but it was not present.'
        )
    kwargs["discovered_document_id"] = expect_type(str, output["discoveredDocumentId"])

    if (_domain_id := output.get("domainId")) is not None:
        kwargs["domain_id"] = expect_type(str, _domain_id)

    if (_domain_name := output.get("domainName")) is not None:
        kwargs["domain_name"] = expect_type(str, _domain_name)

    if (_document_name := output.get("documentName")) is not None:
        kwargs["document_name"] = expect_type(str, _document_name)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_domain_status := output.get("domainStatus")) is not None:
        kwargs["domain_status"] = expect_type(str, _domain_status)

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if (_discovered_at := output.get("discoveredAt")) is not None:
        kwargs["discovered_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _discovered_at)
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return DiscoveredDocumentsListMember(**kwargs)


def _deserialize_discovered_infotypes_list(
    output: DocumentValue, config: Config
) -> list[DiscoveredInfotypesListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_discovered_infotypes_list_member(e, config) for e in output]


def _deserialize_discovered_infotypes_list_member(
    output: DocumentValue, config: Config
) -> DiscoveredInfotypesListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "discoveredInfotypeId" not in output:
        raise ServiceError(
            'Expected to find "discoveredInfotypeId" in the operation output, but it was not present.'
        )
    kwargs["discovered_infotype_id"] = expect_type(str, output["discoveredInfotypeId"])

    if (_keyword := output.get("keyword")) is not None:
        kwargs["keyword"] = _deserialize_unique_string_list(_keyword, config)

    if (_discovery := output.get("discovery")) is not None:
        kwargs["discovery"] = expect_type(str, _discovery)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_last_discovered := output.get("lastDiscovered")) is not None:
        kwargs["last_discovered"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_discovered)
        )

    if (_legal_documents := output.get("legalDocuments")) is not None:
        kwargs["legal_documents"] = _deserialize_legal_document_list(
            _legal_documents, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return DiscoveredInfotypesListMember(**kwargs)


def _deserialize_discovered_recipient_list(
    output: DocumentValue, config: Config
) -> list[DiscoveredRecipientListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_discovered_recipient_list_member(e, config) for e in output]


def _deserialize_discovered_recipient_list_member(
    output: DocumentValue, config: Config
) -> DiscoveredRecipientListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "discoveredRecipientId" not in output:
        raise ServiceError(
            'Expected to find "discoveredRecipientId" in the operation output, but it was not present.'
        )
    kwargs["discovered_recipient_id"] = expect_type(
        str, output["discoveredRecipientId"]
    )

    if (_recipient_model_id := output.get("recipientModelId")) is not None:
        kwargs["recipient_model_id"] = expect_type(str, _recipient_model_id)

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if "discoverySource" not in output:
        raise ServiceError(
            'Expected to find "discoverySource" in the operation output, but it was not present.'
        )
    kwargs["discovery_source"] = _deserialize_discovery_source_list(
        output["discoverySource"], config
    )

    if "createdAt" not in output:
        raise ServiceError(
            'Expected to find "createdAt" in the operation output, but it was not present.'
        )
    kwargs["created_at"] = epoch_seconds_to_datetime(
        expect_type(int | float, output["createdAt"])
    )

    if "status" not in output:
        raise ServiceError(
            'Expected to find "status" in the operation output, but it was not present.'
        )
    kwargs["status"] = expect_type(str, output["status"])

    if (_user_count := output.get("userCount")) is not None:
        kwargs["user_count"] = expect_type(int, _user_count)

    return DiscoveredRecipientListMember(**kwargs)


def _deserialize_discovery_source_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_documents_discovered_of_domain_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_domain_list(
    output: DocumentValue, config: Config
) -> list[DomainListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_domain_list_member(e, config) for e in output]


def _deserialize_domain_list_member(
    output: DocumentValue, config: Config
) -> DomainListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "domainId" not in output:
        raise ServiceError(
            'Expected to find "domainId" in the operation output, but it was not present.'
        )
    kwargs["domain_id"] = expect_type(str, output["domainId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if "frequency" not in output:
        raise ServiceError(
            'Expected to find "frequency" in the operation output, but it was not present.'
        )
    kwargs["frequency"] = expect_type(str, output["frequency"])

    if "createdAt" not in output:
        raise ServiceError(
            'Expected to find "createdAt" in the operation output, but it was not present.'
        )
    kwargs["created_at"] = epoch_seconds_to_datetime(
        expect_type(int | float, output["createdAt"])
    )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_recipients := output.get("recipients")) is not None:
        kwargs["recipients"] = _deserialize_recipients_discovered_of_domain_list(
            _recipients, config
        )

    if (_discovered_documents := output.get("discoveredDocuments")) is not None:
        kwargs["discovered_documents"] = (
            _deserialize_documents_discovered_of_domain_list(
                _discovered_documents, config
            )
        )

    return DomainListMember(**kwargs)


def _deserialize_dpia_availability_risk(
    output: DocumentValue, config: Config
) -> DpiaAvailabilityRisk:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_threats := output.get("threats")) is not None:
        kwargs["threats"] = _deserialize_dpia_availability_risk_threats_collection(
            _threats, config
        )

    if (_threats_comment := output.get("threatsComment")) is not None:
        kwargs["threats_comment"] = expect_type(str, _threats_comment)

    if (_impacts := output.get("impacts")) is not None:
        kwargs["impacts"] = _deserialize_dpia_availability_risk_impacts_collection(
            _impacts, config
        )

    if (_impacts_comment := output.get("impactsComment")) is not None:
        kwargs["impacts_comment"] = expect_type(str, _impacts_comment)

    if (_risk_sources := output.get("riskSources")) is not None:
        kwargs["risk_sources"] = _deserialize_dpia_risk_risk_sources_collection(
            _risk_sources, config
        )

    if (_risk_sources_comment := output.get("riskSourcesComment")) is not None:
        kwargs["risk_sources_comment"] = expect_type(str, _risk_sources_comment)

    if (_implemented_toms := output.get("implementedToms")) is not None:
        kwargs["implemented_toms"] = _deserialize_uuid_collection(
            _implemented_toms, config
        )

    if (_implemented_toms_comment := output.get("implementedTomsComment")) is not None:
        kwargs["implemented_toms_comment"] = expect_type(str, _implemented_toms_comment)

    if (_planned_toms := output.get("plannedToms")) is not None:
        kwargs["planned_toms"] = _deserialize_uuid_collection(_planned_toms, config)

    if (_planned_toms_comment := output.get("plannedTomsComment")) is not None:
        kwargs["planned_toms_comment"] = expect_type(str, _planned_toms_comment)

    if (_baseline_severity := output.get("baselineSeverity")) is not None:
        kwargs["baseline_severity"] = expect_type(str, _baseline_severity)

    if (_baseline_likelihood := output.get("baselineLikelihood")) is not None:
        kwargs["baseline_likelihood"] = expect_type(str, _baseline_likelihood)

    if (_baseline_comment := output.get("baselineComment")) is not None:
        kwargs["baseline_comment"] = expect_type(str, _baseline_comment)

    if (_residual_risk_severity := output.get("residualRiskSeverity")) is not None:
        kwargs["residual_risk_severity"] = expect_type(str, _residual_risk_severity)

    if (_residual_risk_likelihood := output.get("residualRiskLikelihood")) is not None:
        kwargs["residual_risk_likelihood"] = expect_type(str, _residual_risk_likelihood)

    if (_residual_risk_comment := output.get("residualRiskComment")) is not None:
        kwargs["residual_risk_comment"] = expect_type(str, _residual_risk_comment)

    return DpiaAvailabilityRisk(**kwargs)


def _deserialize_dpia_availability_risk_impact(
    output: DocumentValue, config: Config
) -> DpiaAvailabilityRiskImpact:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaAvailabilityRiskImpact(**kwargs)


def _deserialize_dpia_availability_risk_impacts_collection(
    output: DocumentValue, config: Config
) -> list[DpiaAvailabilityRiskImpact]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_availability_risk_impact(e, config) for e in output]


def _deserialize_dpia_availability_risk_threat(
    output: DocumentValue, config: Config
) -> DpiaAvailabilityRiskThreat:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaAvailabilityRiskThreat(**kwargs)


def _deserialize_dpia_availability_risk_threats_collection(
    output: DocumentValue, config: Config
) -> list[DpiaAvailabilityRiskThreat]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_availability_risk_threat(e, config) for e in output]


def _deserialize_dpia_confidentiality_risk(
    output: DocumentValue, config: Config
) -> DpiaConfidentialityRisk:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_threats := output.get("threats")) is not None:
        kwargs["threats"] = _deserialize_dpia_confidentiality_risk_threats_collection(
            _threats, config
        )

    if (_threats_comment := output.get("threatsComment")) is not None:
        kwargs["threats_comment"] = expect_type(str, _threats_comment)

    if (_impacts := output.get("impacts")) is not None:
        kwargs["impacts"] = _deserialize_dpia_confidentiality_risk_impacts_collection(
            _impacts, config
        )

    if (_impacts_comment := output.get("impactsComment")) is not None:
        kwargs["impacts_comment"] = expect_type(str, _impacts_comment)

    if (_risk_sources := output.get("riskSources")) is not None:
        kwargs["risk_sources"] = _deserialize_dpia_risk_risk_sources_collection(
            _risk_sources, config
        )

    if (_risk_sources_comment := output.get("riskSourcesComment")) is not None:
        kwargs["risk_sources_comment"] = expect_type(str, _risk_sources_comment)

    if (_implemented_toms := output.get("implementedToms")) is not None:
        kwargs["implemented_toms"] = _deserialize_uuid_collection(
            _implemented_toms, config
        )

    if (_implemented_toms_comment := output.get("implementedTomsComment")) is not None:
        kwargs["implemented_toms_comment"] = expect_type(str, _implemented_toms_comment)

    if (_planned_toms := output.get("plannedToms")) is not None:
        kwargs["planned_toms"] = _deserialize_uuid_collection(_planned_toms, config)

    if (_planned_toms_comment := output.get("plannedTomsComment")) is not None:
        kwargs["planned_toms_comment"] = expect_type(str, _planned_toms_comment)

    if (_baseline_severity := output.get("baselineSeverity")) is not None:
        kwargs["baseline_severity"] = expect_type(str, _baseline_severity)

    if (_baseline_likelihood := output.get("baselineLikelihood")) is not None:
        kwargs["baseline_likelihood"] = expect_type(str, _baseline_likelihood)

    if (_baseline_comment := output.get("baselineComment")) is not None:
        kwargs["baseline_comment"] = expect_type(str, _baseline_comment)

    if (_residual_risk_severity := output.get("residualRiskSeverity")) is not None:
        kwargs["residual_risk_severity"] = expect_type(str, _residual_risk_severity)

    if (_residual_risk_likelihood := output.get("residualRiskLikelihood")) is not None:
        kwargs["residual_risk_likelihood"] = expect_type(str, _residual_risk_likelihood)

    if (_residual_risk_comment := output.get("residualRiskComment")) is not None:
        kwargs["residual_risk_comment"] = expect_type(str, _residual_risk_comment)

    return DpiaConfidentialityRisk(**kwargs)


def _deserialize_dpia_confidentiality_risk_impact(
    output: DocumentValue, config: Config
) -> DpiaConfidentialityRiskImpact:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaConfidentialityRiskImpact(**kwargs)


def _deserialize_dpia_confidentiality_risk_impacts_collection(
    output: DocumentValue, config: Config
) -> list[DpiaConfidentialityRiskImpact]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_confidentiality_risk_impact(e, config) for e in output]


def _deserialize_dpia_confidentiality_risk_threat(
    output: DocumentValue, config: Config
) -> DpiaConfidentialityRiskThreat:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaConfidentialityRiskThreat(**kwargs)


def _deserialize_dpia_confidentiality_risk_threats_collection(
    output: DocumentValue, config: Config
) -> list[DpiaConfidentialityRiskThreat]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_confidentiality_risk_threat(e, config) for e in output]


def _deserialize_dpia_integrity_risk(
    output: DocumentValue, config: Config
) -> DpiaIntegrityRisk:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_threats := output.get("threats")) is not None:
        kwargs["threats"] = _deserialize_dpia_integrity_risk_threats_collection(
            _threats, config
        )

    if (_threats_comment := output.get("threatsComment")) is not None:
        kwargs["threats_comment"] = expect_type(str, _threats_comment)

    if (_impacts := output.get("impacts")) is not None:
        kwargs["impacts"] = _deserialize_dpia_integrity_risk_impacts_collection(
            _impacts, config
        )

    if (_impacts_comment := output.get("impactsComment")) is not None:
        kwargs["impacts_comment"] = expect_type(str, _impacts_comment)

    if (_risk_sources := output.get("riskSources")) is not None:
        kwargs["risk_sources"] = _deserialize_dpia_risk_risk_sources_collection(
            _risk_sources, config
        )

    if (_risk_sources_comment := output.get("riskSourcesComment")) is not None:
        kwargs["risk_sources_comment"] = expect_type(str, _risk_sources_comment)

    if (_implemented_toms := output.get("implementedToms")) is not None:
        kwargs["implemented_toms"] = _deserialize_uuid_collection(
            _implemented_toms, config
        )

    if (_implemented_toms_comment := output.get("implementedTomsComment")) is not None:
        kwargs["implemented_toms_comment"] = expect_type(str, _implemented_toms_comment)

    if (_planned_toms := output.get("plannedToms")) is not None:
        kwargs["planned_toms"] = _deserialize_uuid_collection(_planned_toms, config)

    if (_planned_toms_comment := output.get("plannedTomsComment")) is not None:
        kwargs["planned_toms_comment"] = expect_type(str, _planned_toms_comment)

    if (_baseline_severity := output.get("baselineSeverity")) is not None:
        kwargs["baseline_severity"] = expect_type(str, _baseline_severity)

    if (_baseline_likelihood := output.get("baselineLikelihood")) is not None:
        kwargs["baseline_likelihood"] = expect_type(str, _baseline_likelihood)

    if (_baseline_comment := output.get("baselineComment")) is not None:
        kwargs["baseline_comment"] = expect_type(str, _baseline_comment)

    if (_residual_risk_severity := output.get("residualRiskSeverity")) is not None:
        kwargs["residual_risk_severity"] = expect_type(str, _residual_risk_severity)

    if (_residual_risk_likelihood := output.get("residualRiskLikelihood")) is not None:
        kwargs["residual_risk_likelihood"] = expect_type(str, _residual_risk_likelihood)

    if (_residual_risk_comment := output.get("residualRiskComment")) is not None:
        kwargs["residual_risk_comment"] = expect_type(str, _residual_risk_comment)

    return DpiaIntegrityRisk(**kwargs)


def _deserialize_dpia_integrity_risk_impact(
    output: DocumentValue, config: Config
) -> DpiaIntegrityRiskImpact:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaIntegrityRiskImpact(**kwargs)


def _deserialize_dpia_integrity_risk_impacts_collection(
    output: DocumentValue, config: Config
) -> list[DpiaIntegrityRiskImpact]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_integrity_risk_impact(e, config) for e in output]


def _deserialize_dpia_integrity_risk_threat(
    output: DocumentValue, config: Config
) -> DpiaIntegrityRiskThreat:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaIntegrityRiskThreat(**kwargs)


def _deserialize_dpia_integrity_risk_threats_collection(
    output: DocumentValue, config: Config
) -> list[DpiaIntegrityRiskThreat]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_integrity_risk_threat(e, config) for e in output]


def _deserialize_dpia_privacy_framework(
    output: DocumentValue, config: Config
) -> DpiaPrivacyFramework:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_purpose_limitation := output.get("purposeLimitation")) is not None:
        kwargs["purpose_limitation"] = expect_type(str, _purpose_limitation)

    if (_data_minimisation := output.get("dataMinimisation")) is not None:
        kwargs["data_minimisation"] = expect_type(str, _data_minimisation)

    if (_accuracy := output.get("accuracy")) is not None:
        kwargs["accuracy"] = expect_type(str, _accuracy)

    if (_retention := output.get("retention")) is not None:
        kwargs["retention"] = expect_type(bool, _retention)

    if (_retention_comment := output.get("retentionComment")) is not None:
        kwargs["retention_comment"] = expect_type(str, _retention_comment)

    if (_transparency := output.get("transparency")) is not None:
        kwargs["transparency"] = expect_type(str, _transparency)

    if (_consent := output.get("consent")) is not None:
        kwargs["consent"] = expect_type(str, _consent)

    if (_data_rights_exercised := output.get("dataRightsExercised")) is not None:
        kwargs["data_rights_exercised"] = expect_type(str, _data_rights_exercised)

    if (_additional_comment := output.get("additionalComment")) is not None:
        kwargs["additional_comment"] = expect_type(str, _additional_comment)

    return DpiaPrivacyFramework(**kwargs)


def _deserialize_dpia_risk_risk_source(
    output: DocumentValue, config: Config
) -> DpiaRiskRiskSource:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return DpiaRiskRiskSource(**kwargs)


def _deserialize_dpia_risk_risk_sources_collection(
    output: DocumentValue, config: Config
) -> list[DpiaRiskRiskSource]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dpia_risk_risk_source(e, config) for e in output]


def _deserialize_employee_for_filter_member(
    output: DocumentValue, config: Config
) -> EmployeeForFilterMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if (_surname := output.get("surname")) is not None:
        kwargs["surname"] = expect_type(str, _surname)

    return EmployeeForFilterMember(**kwargs)


def _deserialize_employee_list(
    output: DocumentValue, config: Config
) -> list[EmployeeListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_employee_list_member(e, config) for e in output]


def _deserialize_employee_list_member(
    output: DocumentValue, config: Config
) -> EmployeeListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if "surname" not in output:
        raise ServiceError(
            'Expected to find "surname" in the operation output, but it was not present.'
        )
    kwargs["surname"] = expect_type(str, output["surname"])

    if (_position := output.get("position")) is not None:
        kwargs["position"] = expect_type(str, _position)

    if (_nif := output.get("nif")) is not None:
        kwargs["nif"] = expect_type(str, _nif)

    if (_start_date := output.get("startDate")) is not None:
        kwargs["start_date"] = expect_type(str, _start_date)

    if (_end_date := output.get("endDate")) is not None:
        kwargs["end_date"] = expect_type(str, _end_date)

    if "createdBy" not in output:
        raise ServiceError(
            'Expected to find "createdBy" in the operation output, but it was not present.'
        )
    kwargs["created_by"] = expect_type(str, output["createdBy"])

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_manager := output.get("manager")) is not None:
        kwargs["manager"] = expect_type(str, _manager)

    if (_department := output.get("department")) is not None:
        kwargs["department"] = expect_type(str, _department)

    if (_reference_id := output.get("referenceId")) is not None:
        kwargs["reference_id"] = expect_type(str, _reference_id)

    if (_department_object := output.get("departmentObject")) is not None:
        kwargs["department_object"] = _deserialize_department_object(
            _department_object, config
        )

    if (_manager_object := output.get("managerObject")) is not None:
        kwargs["manager_object"] = _deserialize_manager_object(_manager_object, config)

    if (_processing_activities := output.get("processingActivities")) is not None:
        kwargs["processing_activities"] = expect_type(int, _processing_activities)

    return EmployeeListMember(**kwargs)


def _deserialize_employees_for_filter_list(
    output: DocumentValue, config: Config
) -> list[EmployeeForFilterMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_employee_for_filter_member(e, config) for e in output]


def _deserialize_enabled_resource_type_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_error_record(output: DocumentValue, config: Config) -> ErrorRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "errorId" not in output:
        raise ServiceError(
            'Expected to find "errorId" in the operation output, but it was not present.'
        )
    kwargs["error_id"] = expect_type(str, output["errorId"])

    if (_context := output.get("context")) is not None:
        kwargs["context"] = _deserialize_context_id_list(_context, config)

    if (_stack_trace := output.get("stackTrace")) is not None:
        kwargs["stack_trace"] = expect_type(str, _stack_trace)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_message := output.get("message")) is not None:
        kwargs["message"] = expect_type(str, _message)

    if (_first_seen := output.get("firstSeen")) is not None:
        kwargs["first_seen"] = epoch_seconds_to_datetime(
            expect_type(int | float, _first_seen)
        )

    if (_last_seen := output.get("lastSeen")) is not None:
        kwargs["last_seen"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_seen)
        )

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    if (_component := output.get("component")) is not None:
        kwargs["component"] = expect_type(str, _component)

    if (_component_id := output.get("componentId")) is not None:
        kwargs["component_id"] = expect_type(str, _component_id)

    if (_workflow_id := output.get("workflowId")) is not None:
        kwargs["workflow_id"] = expect_type(str, _workflow_id)

    if (_workflow_type := output.get("workflowType")) is not None:
        kwargs["workflow_type"] = expect_type(str, _workflow_type)

    if (_workflow_run_id := output.get("workflowRunId")) is not None:
        kwargs["workflow_run_id"] = expect_type(str, _workflow_run_id)

    if (_activity_type := output.get("activityType")) is not None:
        kwargs["activity_type"] = expect_type(str, _activity_type)

    if (_cluster := output.get("cluster")) is not None:
        kwargs["cluster"] = expect_type(str, _cluster)

    if (_hostname := output.get("hostname")) is not None:
        kwargs["hostname"] = expect_type(str, _hostname)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return ErrorRecord(**kwargs)


def _deserialize_errors_list(
    output: DocumentValue, config: Config
) -> list[ErrorRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_error_record(e, config) for e in output]


def _deserialize_events(output: DocumentValue, config: Config) -> Events:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_event_id := output.get("eventId")) is not None:
        kwargs["event_id"] = expect_type(str, _event_id)

    if (_issue_id := output.get("issueId")) is not None:
        kwargs["issue_id"] = expect_type(str, _issue_id)

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_details := output.get("details")) is not None:
        kwargs["details"] = Document(_details)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_resource_name := output.get("resourceName")) is not None:
        kwargs["resource_name"] = expect_type(str, _resource_name)

    if (_scan_id := output.get("scanId")) is not None:
        kwargs["scan_id"] = expect_type(str, _scan_id)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_inspection_policy := output.get("inspectionPolicy")) is not None:
        kwargs["inspection_policy"] = _deserialize_inspection_policy(
            _inspection_policy, config
        )

    if (_tokens := output.get("tokens")) is not None:
        kwargs["tokens"] = _deserialize_tokens(_tokens, config)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_scan_iteration_id := output.get("scanIterationId")) is not None:
        kwargs["scan_iteration_id"] = expect_type(str, _scan_iteration_id)

    if (_scan_execution_id := output.get("scanExecutionId")) is not None:
        kwargs["scan_execution_id"] = expect_type(str, _scan_execution_id)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = Document(_meta)

    if (
        _page_inspection_insight_id := output.get("pageInspectionInsightId")
    ) is not None:
        kwargs["page_inspection_insight_id"] = expect_type(
            str, _page_inspection_insight_id
        )

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_user_id := output.get("userId")) is not None:
        kwargs["user_id"] = expect_type(str, _user_id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_connector_user_id := output.get("connectorUserId")) is not None:
        kwargs["connector_user_id"] = expect_type(str, _connector_user_id)

    if (_connector_username := output.get("connectorUsername")) is not None:
        kwargs["connector_username"] = expect_type(str, _connector_username)

    if (_external := output.get("external")) is not None:
        kwargs["external"] = expect_type(bool, _external)

    return Events(**kwargs)


def _deserialize_events_list(output: DocumentValue, config: Config) -> list[Events]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_events(e, config) for e in output]


def _deserialize_exported_data_url(
    output: DocumentValue, config: Config
) -> ExportedDataUrl:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    return ExportedDataUrl(**kwargs)


def _deserialize_false_positive_report(
    output: DocumentValue, config: Config
) -> FalsePositiveReport:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_false_positive_count := output.get("falsePositiveCount")) is not None:
        kwargs["false_positive_count"] = expect_type(int, _false_positive_count)

    if (_hash := output.get("hash")) is not None:
        kwargs["hash"] = expect_type(str, _hash)

    return FalsePositiveReport(**kwargs)


def _deserialize_false_positive_report_list(
    output: DocumentValue, config: Config
) -> list[FalsePositiveReport]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_false_positive_report(e, config) for e in output]


def _deserialize_field_list(
    output: DocumentValue, config: Config
) -> list[ValidationExceptionField]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_validation_exception_field(e, config) for e in output]


def _deserialize_field_translations(
    output: DocumentValue, config: Config
) -> dict[str, dict[str, str]]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_translations(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_file_info(output: DocumentValue, config: Config) -> FileInfo:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_uploaded_file_id := output.get("uploadedFileId")) is not None:
        kwargs["uploaded_file_id"] = expect_type(str, _uploaded_file_id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_category := output.get("category")) is not None:
        kwargs["category"] = expect_type(str, _category)

    if (_url := output.get("url")) is not None:
        kwargs["url"] = expect_type(str, _url)

    return FileInfo(**kwargs)


def _deserialize_headquarter_list(
    output: DocumentValue, config: Config
) -> list[HeadquarterListRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_headquarter_list_record(e, config) for e in output]


def _deserialize_headquarter_list_record(
    output: DocumentValue, config: Config
) -> HeadquarterListRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "headquarterId" not in output:
        raise ServiceError(
            'Expected to find "headquarterId" in the operation output, but it was not present.'
        )
    kwargs["headquarter_id"] = expect_type(str, output["headquarterId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_city := output.get("city")) is not None:
        kwargs["city"] = expect_type(str, _city)

    if (_address := output.get("address")) is not None:
        kwargs["address"] = expect_type(str, _address)

    if (_country := output.get("country")) is not None:
        kwargs["country"] = expect_type(str, _country)

    if (_zipcode := output.get("zipcode")) is not None:
        kwargs["zipcode"] = expect_type(str, _zipcode)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    return HeadquarterListRecord(**kwargs)


def _deserialize_headquarter_record(
    output: DocumentValue, config: Config
) -> HeadquarterRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "headquarterId" not in output:
        raise ServiceError(
            'Expected to find "headquarterId" in the operation output, but it was not present.'
        )
    kwargs["headquarter_id"] = expect_type(str, output["headquarterId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_city := output.get("city")) is not None:
        kwargs["city"] = expect_type(str, _city)

    if (_address := output.get("address")) is not None:
        kwargs["address"] = expect_type(str, _address)

    if (_country := output.get("country")) is not None:
        kwargs["country"] = expect_type(str, _country)

    if (_zipcode := output.get("zipcode")) is not None:
        kwargs["zipcode"] = expect_type(str, _zipcode)

    if (_toms := output.get("toms")) is not None:
        kwargs["toms"] = _deserialize_tom_collection(_toms, config)

    return HeadquarterRecord(**kwargs)


def _deserialize_identifier_stats(
    output: DocumentValue, config: Config
) -> dict[str, int]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {k: expect_type(int, v) for k, v in output.items() if v is not None}


def _deserialize_infotype_category_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_info_types_combination_filter(
    output: DocumentValue, config: Config
) -> InfoTypesCombinationFilter:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "infoTypes" not in output:
        raise ServiceError(
            'Expected to find "infoTypes" in the operation output, but it was not present.'
        )
    kwargs["info_types"] = _deserialize_unique_string_list(output["infoTypes"], config)

    if "ops" not in output:
        raise ServiceError(
            'Expected to find "ops" in the operation output, but it was not present.'
        )
    kwargs["ops"] = expect_type(str, output["ops"])

    return InfoTypesCombinationFilter(**kwargs)


def _deserialize_infotypes_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_infotype_snapshot(
    output: DocumentValue, config: Config
) -> InfotypeSnapshot:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "found" not in output:
        raise ServiceError(
            'Expected to find "found" in the operation output, but it was not present.'
        )
    kwargs["found"] = expect_type(bool, output["found"])

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    return InfotypeSnapshot(**kwargs)


def _deserialize_insights_filter_value_parameter_list(
    output: DocumentValue, config: Config
) -> list[ListInsightsFilterValueParameter]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [
        _deserialize_list_insights_filter_value_parameter(e, config) for e in output
    ]


def _deserialize_inspection_confidence_snapshot(
    output: DocumentValue, config: Config
) -> dict[str, ConfidenceSnapshot]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_confidence_snapshot(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_inspection_policy(
    output: DocumentValue, config: Config
) -> InspectionPolicy:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_collect_tokens := output.get("collectTokens")) is not None:
        kwargs["collect_tokens"] = expect_type(bool, _collect_tokens)

    if (_mask_details := output.get("maskDetails")) is not None:
        kwargs["mask_details"] = expect_type(bool, _mask_details)

    if (_infotypes := output.get("infotypes")) is not None:
        kwargs["infotypes"] = _deserialize_infotypes_list(_infotypes, config)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_list(_compliance, config)

    return InspectionPolicy(**kwargs)


def _deserialize_inspection_result_list(
    output: DocumentValue, config: Config
) -> list[InspectionResultRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_inspection_result_record(e, config) for e in output]


def _deserialize_inspection_result_record(
    output: DocumentValue, config: Config
) -> InspectionResultRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_scan_id := output.get("scanId")) is not None:
        kwargs["scan_id"] = expect_type(str, _scan_id)

    if (_scan_iteration_id := output.get("scanIterationId")) is not None:
        kwargs["scan_iteration_id"] = expect_type(str, _scan_iteration_id)

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_resource_name := output.get("resourceName")) is not None:
        kwargs["resource_name"] = expect_type(str, _resource_name)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_file_name := output.get("fileName")) is not None:
        kwargs["file_name"] = expect_type(str, _file_name)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_confidence_snapshot := output.get("confidenceSnapshot")) is not None:
        kwargs["confidence_snapshot"] = _deserialize_inspection_confidence_snapshot(
            _confidence_snapshot, config
        )

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_record_type(_stats, config)

    if (_tokens := output.get("tokens")) is not None:
        kwargs["tokens"] = _deserialize_tokens(_tokens, config)

    if (_sample_tokens := output.get("sampleTokens")) is not None:
        kwargs["sample_tokens"] = _deserialize_tokens(_sample_tokens, config)

    if (_scan_parameters := output.get("scanParameters")) is not None:
        kwargs["scan_parameters"] = _deserialize_scan_parameters(
            _scan_parameters, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_has_finding := output.get("hasFinding")) is not None:
        kwargs["has_finding"] = expect_type(bool, _has_finding)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_user_name := output.get("userName")) is not None:
        kwargs["user_name"] = expect_type(str, _user_name)

    if (_user_email := output.get("userEmail")) is not None:
        kwargs["user_email"] = expect_type(str, _user_email)

    if (_categories := output.get("categories")) is not None:
        kwargs["categories"] = _deserialize_unique_string_list(_categories, config)

    return InspectionResultRecord(**kwargs)


def _deserialize_inspection_result_snapshot(
    output: DocumentValue, config: Config
) -> dict[str, InfotypeSnapshot]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_infotype_snapshot(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_issue_list(output: DocumentValue, config: Config) -> list[IssueRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_issue_record(e, config) for e in output]


def _deserialize_issue_notification(
    output: DocumentValue, config: Config
) -> IssueNotification:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_success := output.get("success")) is not None:
        kwargs["success"] = expect_type(bool, _success)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_link := output.get("link")) is not None:
        kwargs["link"] = expect_type(str, _link)

    if (_time := output.get("time")) is not None:
        kwargs["time"] = expect_type(str, _time)

    return IssueNotification(**kwargs)


def _deserialize_issue_notification_list(
    output: DocumentValue, config: Config
) -> list[IssueNotification]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_issue_notification(e, config) for e in output]


def _deserialize_issue_record(output: DocumentValue, config: Config) -> IssueRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "issueId" not in output:
        raise ServiceError(
            'Expected to find "issueId" in the operation output, but it was not present.'
        )
    kwargs["issue_id"] = expect_type(str, output["issueId"])

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    if (_severity := output.get("severity")) is not None:
        kwargs["severity"] = expect_type(str, _severity)

    if (_resource := output.get("resource")) is not None:
        kwargs["resource"] = _deserialize_issue_resource_details(_resource, config)

    if (_security_risk := output.get("securityRisk")) is not None:
        kwargs["security_risk"] = _deserialize_security_risk(_security_risk, config)

    if (_compliance_risk := output.get("complianceRisk")) is not None:
        kwargs["compliance_risk"] = _deserialize_compliance_risk(
            _compliance_risk, config
        )

    if (_events := output.get("events")) is not None:
        kwargs["events"] = _deserialize_data_security_event_list(_events, config)

    if (_notifications := output.get("notifications")) is not None:
        kwargs["notifications"] = _deserialize_issue_notification_list(
            _notifications, config
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return IssueRecord(**kwargs)


def _deserialize_issue_resource_details(
    output: DocumentValue, config: Config
) -> IssueResourceDetails:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_aka := output.get("aka")) is not None:
        kwargs["aka"] = expect_type(str, _aka)

    if (_properties := output.get("properties")) is not None:
        kwargs["properties"] = _deserialize_open_properties(_properties, config)

    return IssueResourceDetails(**kwargs)


def _deserialize_lawful_basis(output: DocumentValue, config: Config) -> LawfulBasis:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "lawfulnessType" not in output:
        raise ServiceError(
            'Expected to find "lawfulnessType" in the operation output, but it was not present.'
        )
    kwargs["lawfulness_type"] = expect_type(str, output["lawfulnessType"])

    if (_comment := output.get("comment")) is not None:
        kwargs["comment"] = expect_type(str, _comment)

    if (_additional_info_file := output.get("additionalInfoFile")) is not None:
        kwargs["additional_info_file"] = expect_type(str, _additional_info_file)

    if (
        _additional_info_file_object := output.get("additionalInfoFileObject")
    ) is not None:
        kwargs["additional_info_file_object"] = _deserialize_file_info(
            _additional_info_file_object, config
        )

    return LawfulBasis(**kwargs)


def _deserialize_lawful_basis_collection(
    output: DocumentValue, config: Config
) -> list[LawfulBasis]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_lawful_basis(e, config) for e in output]


def _deserialize_leaf_resource_parent(
    output: DocumentValue, config: Config
) -> LeafResourceParent:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return LeafResourceParent(**kwargs)


def _deserialize_leaf_resources_data_list(
    output: DocumentValue, config: Config
) -> list[LeafResourcesDataRecordMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_leaf_resources_data_record_member(e, config) for e in output]


def _deserialize_leaf_resources_data_record_member(
    output: DocumentValue, config: Config
) -> LeafResourcesDataRecordMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_last_scanned := output.get("lastScanned")) is not None:
        kwargs["last_scanned"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scanned)
        )

    if (_violation_metrics := output.get("violationMetrics")) is not None:
        kwargs["violation_metrics"] = _deserialize_severity_count_list(
            _violation_metrics, config
        )

    if (
        _framework_exceptions_count := output.get("frameworkExceptionsCount")
    ) is not None:
        kwargs["framework_exceptions_count"] = expect_type(
            int, _framework_exceptions_count
        )

    if (_parent := output.get("parent")) is not None:
        kwargs["parent"] = _deserialize_leaf_resource_parent(_parent, config)

    return LeafResourcesDataRecordMember(**kwargs)


def _deserialize_legal_document_infotypes(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_legal_document_list(
    output: DocumentValue, config: Config
) -> list[LegalDocumentListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_legal_document_list_member(e, config) for e in output]


def _deserialize_legal_document_list_member(
    output: DocumentValue, config: Config
) -> LegalDocumentListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "documentId" not in output:
        raise ServiceError(
            'Expected to find "documentId" in the operation output, but it was not present.'
        )
    kwargs["document_id"] = expect_type(str, output["documentId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_document_link := output.get("documentLink")) is not None:
        kwargs["document_link"] = expect_type(str, _document_link)

    if (_bucket_uri := output.get("bucketUri")) is not None:
        kwargs["bucket_uri"] = expect_type(str, _bucket_uri)

    if (_discovered_infotypes := output.get("discoveredInfotypes")) is not None:
        kwargs["discovered_infotypes"] = _deserialize_legal_document_infotypes(
            _discovered_infotypes, config
        )

    if (_last_scanned := output.get("lastScanned")) is not None:
        kwargs["last_scanned"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scanned)
        )

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_is_discover_infotype := output.get("isDiscoverInfotype")) is not None:
        kwargs["is_discover_infotype"] = expect_type(bool, _is_discover_infotype)

    if (
        _from_discovered_document_id := output.get("fromDiscoveredDocumentId")
    ) is not None:
        kwargs["from_discovered_document_id"] = expect_type(
            str, _from_discovered_document_id
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    return LegalDocumentListMember(**kwargs)


def _deserialize_links(output: DocumentValue, config: Config) -> list[Document]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [Document(e) for e in output]


def _deserialize_list_insights_filter_value_parameter(
    output: DocumentValue, config: Config
) -> ListInsightsFilterValueParameter:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return ListInsightsFilterValueParameter(**kwargs)


def _deserialize_list_processing_activity_filter_member(
    output: DocumentValue, config: Config
) -> ListProcessingActivityFilterMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return ListProcessingActivityFilterMember(**kwargs)


def _deserialize_management_method(
    output: DocumentValue, config: Config
) -> ManagementMethod:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "methodType" not in output:
        raise ServiceError(
            'Expected to find "methodType" in the operation output, but it was not present.'
        )
    kwargs["method_type"] = expect_type(str, output["methodType"])

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_postal_address := output.get("postalAddress")) is not None:
        kwargs["postal_address"] = _deserialize_postal_address(_postal_address, config)

    return ManagementMethod(**kwargs)


def _deserialize_management_method_collection(
    output: DocumentValue, config: Config
) -> list[ManagementMethod]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_management_method(e, config) for e in output]


def _deserialize_manager_object(output: DocumentValue, config: Config) -> ManagerObject:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if "surname" not in output:
        raise ServiceError(
            'Expected to find "surname" in the operation output, but it was not present.'
        )
    kwargs["surname"] = expect_type(str, output["surname"])

    if (_position := output.get("position")) is not None:
        kwargs["position"] = expect_type(str, _position)

    if (_nif := output.get("nif")) is not None:
        kwargs["nif"] = expect_type(str, _nif)

    if (_start_date := output.get("startDate")) is not None:
        kwargs["start_date"] = expect_type(str, _start_date)

    if (_end_date := output.get("endDate")) is not None:
        kwargs["end_date"] = expect_type(str, _end_date)

    if "createdBy" not in output:
        raise ServiceError(
            'Expected to find "createdBy" in the operation output, but it was not present.'
        )
    kwargs["created_by"] = expect_type(str, output["createdBy"])

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_manager := output.get("manager")) is not None:
        kwargs["manager"] = expect_type(str, _manager)

    if (_department := output.get("department")) is not None:
        kwargs["department"] = expect_type(str, _department)

    if (_reference_id := output.get("referenceId")) is not None:
        kwargs["reference_id"] = expect_type(str, _reference_id)

    if (_department_object := output.get("departmentObject")) is not None:
        kwargs["department_object"] = _deserialize_department_object(
            _department_object, config
        )

    if (_manager_object := output.get("managerObject")) is not None:
        kwargs["manager_object"] = _deserialize_manager_object(_manager_object, config)

    return ManagerObject(**kwargs)


def _deserialize_missing_dpia_field_options(
    output: DocumentValue, config: Config
) -> MissingDpiaFieldOptions:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (
        _missing_privacy_ops_field_options := output.get(
            "missingPrivacyOpsFieldOptions"
        )
    ) is not None:
        kwargs["missing_privacy_ops_field_options"] = (
            _deserialize_missing_privacy_ops_field_options_list(
                _missing_privacy_ops_field_options, config
            )
        )

    return MissingDpiaFieldOptions(**kwargs)


def _deserialize_missing_dpia_objects(
    output: DocumentValue, config: Config
) -> MissingDpiaObjects:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_availability := output.get("availability")) is not None:
        kwargs["availability"] = _deserialize_missing_dpia_field_options(
            _availability, config
        )

    if (_integrity := output.get("integrity")) is not None:
        kwargs["integrity"] = _deserialize_missing_dpia_field_options(
            _integrity, config
        )

    if (_confidentiality := output.get("confidentiality")) is not None:
        kwargs["confidentiality"] = _deserialize_missing_dpia_field_options(
            _confidentiality, config
        )

    return MissingDpiaObjects(**kwargs)


def _deserialize_missing_object(output: DocumentValue, config: Config) -> MissingObject:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "id" not in output:
        raise ServiceError(
            'Expected to find "id" in the operation output, but it was not present.'
        )
    kwargs["id"] = expect_type(str, output["id"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return MissingObject(**kwargs)


def _deserialize_missing_object_list(
    output: DocumentValue, config: Config
) -> list[MissingObject]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_missing_object(e, config) for e in output]


def _deserialize_missing_privacy_ops_field_options(
    output: DocumentValue, config: Config
) -> MissingPrivacyOpsFieldOptions:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_missing_options := output.get("missingOptions")) is not None:
        kwargs["missing_options"] = _deserialize_missing_object_list(
            _missing_options, config
        )

    return MissingPrivacyOpsFieldOptions(**kwargs)


def _deserialize_missing_privacy_ops_field_options_list(
    output: DocumentValue, config: Config
) -> list[MissingPrivacyOpsFieldOptions]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_missing_privacy_ops_field_options(e, config) for e in output]


def _deserialize_missing_processing_activity_objects(
    output: DocumentValue, config: Config
) -> MissingProcessingActivityObjects:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "missingDepartments" not in output:
        raise ServiceError(
            'Expected to find "missingDepartments" in the operation output, but it was not present.'
        )
    kwargs["missing_departments"] = _deserialize_missing_object_list(
        output["missingDepartments"], config
    )

    if "missingRecipients" not in output:
        raise ServiceError(
            'Expected to find "missingRecipients" in the operation output, but it was not present.'
        )
    kwargs["missing_recipients"] = _deserialize_missing_object_list(
        output["missingRecipients"], config
    )

    if "missingAssets" not in output:
        raise ServiceError(
            'Expected to find "missingAssets" in the operation output, but it was not present.'
        )
    kwargs["missing_assets"] = _deserialize_missing_object_list(
        output["missingAssets"], config
    )

    if "missingPrivacyOpsFieldOptions" not in output:
        raise ServiceError(
            'Expected to find "missingPrivacyOpsFieldOptions" in the operation output, but it was not present.'
        )
    kwargs["missing_privacy_ops_field_options"] = (
        _deserialize_missing_privacy_ops_field_options_list(
            output["missingPrivacyOpsFieldOptions"], config
        )
    )

    if "missingInfoTypes" not in output:
        raise ServiceError(
            'Expected to find "missingInfoTypes" in the operation output, but it was not present.'
        )
    kwargs["missing_info_types"] = _deserialize_missing_object_list(
        output["missingInfoTypes"], config
    )

    return MissingProcessingActivityObjects(**kwargs)


def _deserialize_okta_user_discovery_list(
    output: DocumentValue, config: Config
) -> list[OktaUserDiscoveryListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_okta_user_discovery_list_member(e, config) for e in output]


def _deserialize_okta_user_discovery_list_member(
    output: DocumentValue, config: Config
) -> OktaUserDiscoveryListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "userId" not in output:
        raise ServiceError(
            'Expected to find "userId" in the operation output, but it was not present.'
        )
    kwargs["user_id"] = expect_type(str, output["userId"])

    if (_okta_username := output.get("oktaUsername")) is not None:
        kwargs["okta_username"] = expect_type(str, _okta_username)

    if (_first_name := output.get("firstName")) is not None:
        kwargs["first_name"] = expect_type(str, _first_name)

    if (_last_name := output.get("lastName")) is not None:
        kwargs["last_name"] = expect_type(str, _last_name)

    if (_okta_connection_id := output.get("oktaConnectionId")) is not None:
        kwargs["okta_connection_id"] = expect_type(str, _okta_connection_id)

    if (_okta_email := output.get("oktaEmail")) is not None:
        kwargs["okta_email"] = expect_type(str, _okta_email)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_added_to_register := output.get("addedToRegister")) is not None:
        kwargs["added_to_register"] = expect_type(bool, _added_to_register)

    if (_last_discovered_at := output.get("lastDiscoveredAt")) is not None:
        kwargs["last_discovered_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_discovered_at)
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return OktaUserDiscoveryListMember(**kwargs)


def _deserialize_open_properties(
    output: DocumentValue, config: Config
) -> dict[str, Document]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {k: Document(v) for k, v in output.items() if v is not None}


def _deserialize_owner_object(output: DocumentValue, config: Config) -> OwnerObject:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = Document(_meta)

    return OwnerObject(**kwargs)


def _deserialize_owner_object_list(
    output: DocumentValue, config: Config
) -> list[OwnerObject]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_owner_object(e, config) for e in output]


def _deserialize_pa_stats_per_owner(
    output: DocumentValue, config: Config
) -> dict[str, SummarizeProcessingActivityStatsOutput]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_summarize_processing_activity_stats_output(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_pa_stats_per_owner_list(
    output: DocumentValue, config: Config
) -> list[dict[str, SummarizeProcessingActivityStatsOutput]]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_pa_stats_per_owner(e, config) for e in output]


def _deserialize_pa_stats_time_series_list(
    output: DocumentValue, config: Config
) -> list[PaStatsTimeSeriesPoint]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_pa_stats_time_series_point(e, config) for e in output]


def _deserialize_pa_stats_time_series_point(
    output: DocumentValue, config: Config
) -> PaStatsTimeSeriesPoint:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "timestamp" not in output:
        raise ServiceError(
            'Expected to find "timestamp" in the operation output, but it was not present.'
        )
    kwargs["timestamp"] = expect_type(str, output["timestamp"])

    if "data" not in output:
        raise ServiceError(
            'Expected to find "data" in the operation output, but it was not present.'
        )
    kwargs["data"] = _deserialize_summarize_processing_activity_stats_output(
        output["data"], config
    )

    return PaStatsTimeSeriesPoint(**kwargs)


def _deserialize_policy_infotype_confidence_level_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_postal_address(output: DocumentValue, config: Config) -> PostalAddress:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "street" not in output:
        raise ServiceError(
            'Expected to find "street" in the operation output, but it was not present.'
        )
    kwargs["street"] = expect_type(str, output["street"])

    if "city" not in output:
        raise ServiceError(
            'Expected to find "city" in the operation output, but it was not present.'
        )
    kwargs["city"] = expect_type(str, output["city"])

    if "country" not in output:
        raise ServiceError(
            'Expected to find "country" in the operation output, but it was not present.'
        )
    kwargs["country"] = expect_type(str, output["country"])

    if "zipcode" not in output:
        raise ServiceError(
            'Expected to find "zipcode" in the operation output, but it was not present.'
        )
    kwargs["zipcode"] = expect_type(str, output["zipcode"])

    return PostalAddress(**kwargs)


def _deserialize_processing_activitiy_data_source_collection(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_processing_activity_asset_list(
    output: DocumentValue, config: Config
) -> list[AssetRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_asset_record(e, config) for e in output]


def _deserialize_processing_activity_department(
    output: DocumentValue, config: Config
) -> ProcessingActivityDepartment:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "departmentId" not in output:
        raise ServiceError(
            'Expected to find "departmentId" in the operation output, but it was not present.'
        )
    kwargs["department_id"] = expect_type(str, output["departmentId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    return ProcessingActivityDepartment(**kwargs)


def _deserialize_processing_activity_department_list(
    output: DocumentValue, config: Config
) -> list[ProcessingActivityDepartment]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_processing_activity_department(e, config) for e in output]


def _deserialize_processing_activity_employee(
    output: DocumentValue, config: Config
) -> ProcessingActivityEmployee:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "employeeId" not in output:
        raise ServiceError(
            'Expected to find "employeeId" in the operation output, but it was not present.'
        )
    kwargs["employee_id"] = expect_type(str, output["employeeId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_surname := output.get("surname")) is not None:
        kwargs["surname"] = expect_type(str, _surname)

    return ProcessingActivityEmployee(**kwargs)


def _deserialize_processing_activity_employee_list(
    output: DocumentValue, config: Config
) -> list[ProcessingActivityEmployee]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_processing_activity_employee(e, config) for e in output]


def _deserialize_processing_activity_filter_output_list(
    output: DocumentValue, config: Config
) -> list[ListProcessingActivityFilterMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [
        _deserialize_list_processing_activity_filter_member(e, config) for e in output
    ]


def _deserialize_processing_activity_list(
    output: DocumentValue, config: Config
) -> list[ProcessingActivityListRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_processing_activity_list_record(e, config) for e in output]


def _deserialize_processing_activity_list_record(
    output: DocumentValue, config: Config
) -> ProcessingActivityListRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "processingActivityId" not in output:
        raise ServiceError(
            'Expected to find "processingActivityId" in the operation output, but it was not present.'
        )
    kwargs["processing_activity_id"] = expect_type(str, output["processingActivityId"])

    if (_active := output.get("active")) is not None:
        kwargs["active"] = expect_type(bool, _active)

    if (_department_objects := output.get("departmentObjects")) is not None:
        kwargs["department_objects"] = _deserialize_processing_activity_department_list(
            _department_objects, config
        )

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_recipient_objects := output.get("recipientObjects")) is not None:
        kwargs["recipient_objects"] = _deserialize_processing_activity_recipient_list(
            _recipient_objects, config
        )

    if (_employee_objects := output.get("employeeObjects")) is not None:
        kwargs["employee_objects"] = _deserialize_processing_activity_employee_list(
            _employee_objects, config
        )

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = expect_type(str, _owner)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_language := output.get("language")) is not None:
        kwargs["language"] = expect_type(str, _language)

    if (_translations := output.get("translations")) is not None:
        kwargs["translations"] = _deserialize_field_translations(_translations, config)

    if (_framework := output.get("framework")) is not None:
        kwargs["framework"] = expect_type(str, _framework)

    if (_company_role := output.get("companyRole")) is not None:
        kwargs["company_role"] = _deserialize_company_role_list(_company_role, config)

    if (_uploaded_ta_file_id := output.get("uploadedTaFileId")) is not None:
        kwargs["uploaded_ta_file_id"] = expect_type(str, _uploaded_ta_file_id)

    if (_uploaded_dpia_file_id := output.get("uploadedDpiaFileId")) is not None:
        kwargs["uploaded_dpia_file_id"] = expect_type(str, _uploaded_dpia_file_id)

    if (_uploaded_ta_dpia_file_id := output.get("uploadedTaDpiaFileId")) is not None:
        kwargs["uploaded_ta_dpia_file_id"] = expect_type(str, _uploaded_ta_dpia_file_id)

    if (
        _related_processing_activities := output.get("relatedProcessingActivities")
    ) is not None:
        kwargs["related_processing_activities"] = expect_type(
            int, _related_processing_activities
        )

    return ProcessingActivityListRecord(**kwargs)


def _deserialize_processing_activity_of_recipient_list(
    output: DocumentValue, config: Config
) -> list[ProcessingActivityOfRecipientMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [
        _deserialize_processing_activity_of_recipient_member(e, config) for e in output
    ]


def _deserialize_processing_activity_of_recipient_member(
    output: DocumentValue, config: Config
) -> ProcessingActivityOfRecipientMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "processingActivityId" not in output:
        raise ServiceError(
            'Expected to find "processingActivityId" in the operation output, but it was not present.'
        )
    kwargs["processing_activity_id"] = expect_type(str, output["processingActivityId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    if "active" not in output:
        raise ServiceError(
            'Expected to find "active" in the operation output, but it was not present.'
        )
    kwargs["active"] = expect_type(bool, output["active"])

    if "updatedAt" not in output:
        raise ServiceError(
            'Expected to find "updatedAt" in the operation output, but it was not present.'
        )
    kwargs["updated_at"] = epoch_seconds_to_datetime(
        expect_type(int | float, output["updatedAt"])
    )

    if "createdBy" not in output:
        raise ServiceError(
            'Expected to find "createdBy" in the operation output, but it was not present.'
        )
    kwargs["created_by"] = expect_type(str, output["createdBy"])

    return ProcessingActivityOfRecipientMember(**kwargs)


def _deserialize_processing_activity_recipient_list(
    output: DocumentValue, config: Config
) -> list[ProcessingActivityRecipientMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [
        _deserialize_processing_activity_recipient_member(e, config) for e in output
    ]


def _deserialize_processing_activity_recipient_member(
    output: DocumentValue, config: Config
) -> ProcessingActivityRecipientMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_business_name := output.get("businessName")) is not None:
        kwargs["business_name"] = expect_type(str, _business_name)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_categories := output.get("categories")) is not None:
        kwargs["categories"] = _deserialize_recipient_category_collection(
            _categories, config
        )

    if (_role := output.get("role")) is not None:
        kwargs["role"] = _deserialize_recipient_role_list(_role, config)

    if (_country := output.get("country")) is not None:
        kwargs["country"] = expect_type(str, _country)

    if (_state := output.get("state")) is not None:
        kwargs["state"] = expect_type(str, _state)

    if (_dpa := output.get("dpa")) is not None:
        kwargs["dpa"] = expect_type(str, _dpa)

    if (_dpa_files := output.get("dpaFiles")) is not None:
        kwargs["dpa_files"] = _deserialize_uuid_collection(_dpa_files, config)

    if (_dpa_status := output.get("dpaStatus")) is not None:
        kwargs["dpa_status"] = expect_type(str, _dpa_status)

    if (_recipient_model_id := output.get("recipientModelId")) is not None:
        kwargs["recipient_model_id"] = expect_type(str, _recipient_model_id)

    if (_recipient_warranties := output.get("recipientWarranties")) is not None:
        kwargs["recipient_warranties"] = _deserialize_warranty_list(
            _recipient_warranties, config
        )

    if (_data_storage_location := output.get("dataStorageLocation")) is not None:
        kwargs["data_storage_location"] = _deserialize_country_list(
            _data_storage_location, config
        )

    if (_discovery_source := output.get("discoverySource")) is not None:
        kwargs["discovery_source"] = _deserialize_discovery_source_list(
            _discovery_source, config
        )

    if (_discovered_date := output.get("discoveredDate")) is not None:
        kwargs["discovered_date"] = epoch_seconds_to_datetime(
            expect_type(int | float, _discovered_date)
        )

    if (_automation_status := output.get("automationStatus")) is not None:
        kwargs["automation_status"] = expect_type(str, _automation_status)

    if (_recipient_state := output.get("recipientState")) is not None:
        kwargs["recipient_state"] = expect_type(str, _recipient_state)

    if (_contact_email := output.get("contactEmail")) is not None:
        kwargs["contact_email"] = expect_type(str, _contact_email)

    if (_privacy_policy_link := output.get("privacyPolicyLink")) is not None:
        kwargs["privacy_policy_link"] = expect_type(str, _privacy_policy_link)

    if (_recipient_id := output.get("recipientId")) is not None:
        kwargs["recipient_id"] = expect_type(str, _recipient_id)

    if (_comment := output.get("comment")) is not None:
        kwargs["comment"] = expect_type(str, _comment)

    return ProcessingActivityRecipientMember(**kwargs)


def _deserialize_properties(output: DocumentValue, config: Config) -> dict[str, str]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {k: expect_type(str, v) for k, v in output.items() if v is not None}


def _deserialize_recipient_category_collection(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_recipient_filter_output_list(
    output: DocumentValue, config: Config
) -> list[RecipientFilterOutputListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_recipient_filter_output_list_member(e, config) for e in output]


def _deserialize_recipient_filter_output_list_member(
    output: DocumentValue, config: Config
) -> RecipientFilterOutputListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_id := output.get("id")) is not None:
        kwargs["id"] = expect_type(str, _id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return RecipientFilterOutputListMember(**kwargs)


def _deserialize_recipient_for_filter_member(
    output: DocumentValue, config: Config
) -> RecipientForFilterMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "recipientId" not in output:
        raise ServiceError(
            'Expected to find "recipientId" in the operation output, but it was not present.'
        )
    kwargs["recipient_id"] = expect_type(str, output["recipientId"])

    if "name" not in output:
        raise ServiceError(
            'Expected to find "name" in the operation output, but it was not present.'
        )
    kwargs["name"] = expect_type(str, output["name"])

    return RecipientForFilterMember(**kwargs)


def _deserialize_recipient_list(
    output: DocumentValue, config: Config
) -> list[RecipientListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_recipient_list_member(e, config) for e in output]


def _deserialize_recipient_list_member(
    output: DocumentValue, config: Config
) -> RecipientListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_recipient_id := output.get("recipientId")) is not None:
        kwargs["recipient_id"] = expect_type(str, _recipient_id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_categories := output.get("categories")) is not None:
        kwargs["categories"] = _deserialize_recipient_category_collection(
            _categories, config
        )

    if (_role := output.get("role")) is not None:
        kwargs["role"] = _deserialize_recipient_role_list(_role, config)

    if (_discovery_source := output.get("discoverySource")) is not None:
        kwargs["discovery_source"] = _deserialize_discovery_source_list(
            _discovery_source, config
        )

    if (_automation_status := output.get("automationStatus")) is not None:
        kwargs["automation_status"] = expect_type(str, _automation_status)

    if (_recipient_model_id := output.get("recipientModelId")) is not None:
        kwargs["recipient_model_id"] = expect_type(str, _recipient_model_id)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_data_storage_location := output.get("dataStorageLocation")) is not None:
        kwargs["data_storage_location"] = _deserialize_country_list(
            _data_storage_location, config
        )

    if (_recipient_warranties := output.get("recipientWarranties")) is not None:
        kwargs["recipient_warranties"] = _deserialize_warranty_list(
            _recipient_warranties, config
        )

    if (_recipient_state := output.get("recipientState")) is not None:
        kwargs["recipient_state"] = expect_type(str, _recipient_state)

    if (_contact_email := output.get("contactEmail")) is not None:
        kwargs["contact_email"] = expect_type(str, _contact_email)

    if (_last_modification := output.get("lastModification")) is not None:
        kwargs["last_modification"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_modification)
        )

    if (_processing_activities := output.get("processingActivities")) is not None:
        kwargs["processing_activities"] = expect_type(int, _processing_activities)

    if (_departments := output.get("departments")) is not None:
        kwargs["departments"] = _deserialize_unique_string_list(_departments, config)

    if (_archived_at := output.get("archivedAt")) is not None:
        kwargs["archived_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _archived_at)
        )

    if (_key := output.get("key")) is not None:
        kwargs["key"] = expect_type(str, _key)

    return RecipientListMember(**kwargs)


def _deserialize_recipient_role_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_recipients_discovered_of_domain_list(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_recipients_for_filter_list(
    output: DocumentValue, config: Config
) -> list[RecipientForFilterMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_recipient_for_filter_member(e, config) for e in output]


def _deserialize_record_type(output: DocumentValue, config: Config) -> dict[str, str]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {k: expect_type(str, v) for k, v in output.items() if v is not None}


def _deserialize_report_recipients(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_report_recipients_roles(
    output: DocumentValue, config: Config
) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_report_type_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_resource_based_filter(
    output: DocumentValue, config: Config
) -> ResourceBasedFilter:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_values := output.get("values")) is not None:
        kwargs["values"] = _deserialize_unique_string_list(_values, config)

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    return ResourceBasedFilter(**kwargs)


def _deserialize_resource_based_filters(
    output: DocumentValue, config: Config
) -> list[ResourceBasedFilter]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_based_filter(e, config) for e in output]


def _deserialize_resource_columns(
    output: DocumentValue, config: Config
) -> ResourceColumns:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_resource_name := output.get("resourceName")) is not None:
        kwargs["resource_name"] = expect_type(str, _resource_name)

    if (_columns := output.get("columns")) is not None:
        kwargs["columns"] = _deserialize_unique_string_list(_columns, config)

    if (_properties := output.get("properties")) is not None:
        kwargs["properties"] = _deserialize_properties(_properties, config)

    return ResourceColumns(**kwargs)


def _deserialize_resource_columns_list(
    output: DocumentValue, config: Config
) -> list[ResourceColumns]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_columns(e, config) for e in output]


def _deserialize_resource_data_stats(
    output: DocumentValue, config: Config
) -> ResourceDataStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_size_in_bytes := output.get("sizeInBytes")) is not None:
        kwargs["size_in_bytes"] = expect_type(str, _size_in_bytes)

    if (_entity_count := output.get("entityCount")) is not None:
        kwargs["entity_count"] = expect_type(str, _entity_count)

    if (_entity_unit := output.get("entityUnit")) is not None:
        kwargs["entity_unit"] = expect_type(str, _entity_unit)

    return ResourceDataStats(**kwargs)


def _deserialize_resource_id_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_resource_inventory_list(
    output: DocumentValue, config: Config
) -> list[ResourceInventoryListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_inventory_list_member(e, config) for e in output]


def _deserialize_resource_inventory_list_member(
    output: DocumentValue, config: Config
) -> ResourceInventoryListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_failed_rules := output.get("failedRules")) is not None:
        kwargs["failed_rules"] = _deserialize_unique_string_list(_failed_rules, config)

    if (_data_classification := output.get("dataClassification")) is not None:
        kwargs["data_classification"] = _deserialize_unique_string_list(
            _data_classification, config
        )

    if (_data_categories := output.get("dataCategories")) is not None:
        kwargs["data_categories"] = _deserialize_unique_string_list(
            _data_categories, config
        )

    if (_scan := output.get("scan")) is not None:
        kwargs["scan"] = _deserialize_scan_information(_scan, config)

    if (_first_seen := output.get("firstSeen")) is not None:
        kwargs["first_seen"] = expect_type(str, _first_seen)

    if (_last_updated := output.get("lastUpdated")) is not None:
        kwargs["last_updated"] = expect_type(str, _last_updated)

    if (_severity_score := output.get("severityScore")) is not None:
        kwargs["severity_score"] = expect_type(int, _severity_score)

    if (_properties := output.get("properties")) is not None:
        kwargs["properties"] = _deserialize_open_properties(_properties, config)

    if (_aka := output.get("aka")) is not None:
        kwargs["aka"] = expect_type(str, _aka)

    if (_issue_id := output.get("issueId")) is not None:
        kwargs["issue_id"] = expect_type(str, _issue_id)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_failed_policies := output.get("failedPolicies")) is not None:
        kwargs["failed_policies"] = _deserialize_unique_string_list(
            _failed_policies, config
        )

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_resource_stats_data(_stats, config)

    if (_violation_count := output.get("violationCount")) is not None:
        kwargs["violation_count"] = _deserialize_severity_count_list(
            _violation_count, config
        )

    if (
        _framework_exceptions_count := output.get("frameworkExceptionsCount")
    ) is not None:
        kwargs["framework_exceptions_count"] = expect_type(
            int, _framework_exceptions_count
        )

    if (_cloud_account := output.get("cloudAccount")) is not None:
        kwargs["cloud_account"] = _deserialize_cloud_account(_cloud_account, config)

    return ResourceInventoryListMember(**kwargs)


def _deserialize_resource_lineage_data(
    output: DocumentValue, config: Config
) -> ResourceLineageData:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_open_properties(_meta, config)

    if (_owner := output.get("owner")) is not None:
        kwargs["owner"] = _deserialize_owner_object_list(_owner, config)

    if (_owner_email := output.get("ownerEmail")) is not None:
        kwargs["owner_email"] = expect_type(str, _owner_email)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_sample_tokens := output.get("sampleTokens")) is not None:
        kwargs["sample_tokens"] = _deserialize_tokens(_sample_tokens, config)

    if (_compliance := output.get("compliance")) is not None:
        kwargs["compliance"] = _deserialize_compliance_detail_list(_compliance, config)

    if (_last_scanned := output.get("lastScanned")) is not None:
        kwargs["last_scanned"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scanned)
        )

    if (_parent := output.get("parent")) is not None:
        kwargs["parent"] = _deserialize_resource_parent(_parent, config)

    if (_source_edges := output.get("sourceEdges")) is not None:
        kwargs["source_edges"] = _deserialize_resource_lineage_edge_list(
            _source_edges, config
        )

    if (_destination_edges := output.get("destinationEdges")) is not None:
        kwargs["destination_edges"] = _deserialize_resource_lineage_edge_list(
            _destination_edges, config
        )

    return ResourceLineageData(**kwargs)


def _deserialize_resource_lineage_edge(
    output: DocumentValue, config: Config
) -> ResourceLineageEdge:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_sql := output.get("sql")) is not None:
        kwargs["sql"] = expect_type(str, _sql)

    if (_source_resource_id := output.get("sourceResourceId")) is not None:
        kwargs["source_resource_id"] = expect_type(str, _source_resource_id)

    if (_destination_resource_id := output.get("destinationResourceId")) is not None:
        kwargs["destination_resource_id"] = expect_type(str, _destination_resource_id)

    if (_source_column := output.get("sourceColumn")) is not None:
        kwargs["source_column"] = expect_type(str, _source_column)

    if (_destination_column := output.get("destinationColumn")) is not None:
        kwargs["destination_column"] = expect_type(str, _destination_column)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = _deserialize_resource_lineage_data(_source, config)

    if (_destination := output.get("destination")) is not None:
        kwargs["destination"] = _deserialize_resource_lineage_data(_destination, config)

    return ResourceLineageEdge(**kwargs)


def _deserialize_resource_lineage_edge_list(
    output: DocumentValue, config: Config
) -> list[ResourceLineageEdge]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_lineage_edge(e, config) for e in output]


def _deserialize_resource_parent(
    output: DocumentValue, config: Config
) -> ResourceParent:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return ResourceParent(**kwargs)


def _deserialize_resource_record(
    output: DocumentValue, config: Config
) -> ResourceRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = Document(_meta)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    return ResourceRecord(**kwargs)


def _deserialize_resource_sensitive_data_details(
    output: DocumentValue, config: Config
) -> ResourceSensitiveDataDetails:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "resourceId" not in output:
        raise ServiceError(
            'Expected to find "resourceId" in the operation output, but it was not present.'
        )
    kwargs["resource_id"] = expect_type(str, output["resourceId"])

    if "resourceName" not in output:
        raise ServiceError(
            'Expected to find "resourceName" in the operation output, but it was not present.'
        )
    kwargs["resource_name"] = expect_type(str, output["resourceName"])

    if "resourceType" not in output:
        raise ServiceError(
            'Expected to find "resourceType" in the operation output, but it was not present.'
        )
    kwargs["resource_type"] = expect_type(str, output["resourceType"])

    if "dataScanned" not in output:
        raise ServiceError(
            'Expected to find "dataScanned" in the operation output, but it was not present.'
        )
    kwargs["data_scanned"] = expect_type(int, output["dataScanned"])

    if "identifierCount" not in output:
        raise ServiceError(
            'Expected to find "identifierCount" in the operation output, but it was not present.'
        )
    kwargs["identifier_count"] = expect_type(int, output["identifierCount"])

    if "identifiersFound" not in output:
        raise ServiceError(
            'Expected to find "identifiersFound" in the operation output, but it was not present.'
        )
    kwargs["identifiers_found"] = _deserialize_unique_string_list(
        output["identifiersFound"], config
    )

    if "confidenceLevels" not in output:
        raise ServiceError(
            'Expected to find "confidenceLevels" in the operation output, but it was not present.'
        )
    kwargs["confidence_levels"] = _deserialize_policy_infotype_confidence_level_list(
        output["confidenceLevels"], config
    )

    if "numberOfScans" not in output:
        raise ServiceError(
            'Expected to find "numberOfScans" in the operation output, but it was not present.'
        )
    kwargs["number_of_scans"] = expect_type(int, output["numberOfScans"])

    return ResourceSensitiveDataDetails(**kwargs)


def _deserialize_resource_sensitive_data_details_list(
    output: DocumentValue, config: Config
) -> list[ResourceSensitiveDataDetails]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_sensitive_data_details(e, config) for e in output]


def _deserialize_resources_list(
    output: DocumentValue, config: Config
) -> list[ResourceWithName]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_with_name(e, config) for e in output]


def _deserialize_resource_stats(
    output: DocumentValue, config: Config
) -> dict[str, ResourceStatsData]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_resource_stats_data(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_resource_stats_data(
    output: DocumentValue, config: Config
) -> ResourceStatsData:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_full_scan_inspected_bytes := output.get("fullScanInspectedBytes")) is not None:
        kwargs["full_scan_inspected_bytes"] = expect_type(
            int, _full_scan_inspected_bytes
        )

    if (
        _sample_scan_inspected_bytes := output.get("sampleScanInspectedBytes")
    ) is not None:
        kwargs["sample_scan_inspected_bytes"] = expect_type(
            int, _sample_scan_inspected_bytes
        )

    if (_infotypes_count := output.get("infotypesCount")) is not None:
        kwargs["infotypes_count"] = expect_type(int, _infotypes_count)

    if (_infotype_tokens_count := output.get("infotypeTokensCount")) is not None:
        kwargs["infotype_tokens_count"] = expect_type(int, _infotype_tokens_count)

    if (_scanned_resources := output.get("scannedResources")) is not None:
        kwargs["scanned_resources"] = expect_type(int, _scanned_resources)

    if (_unscanned_resources := output.get("unscannedResources")) is not None:
        kwargs["unscanned_resources"] = expect_type(int, _unscanned_resources)

    if (
        _scanned_child_resource_count := output.get("scannedChildResourceCount")
    ) is not None:
        kwargs["scanned_child_resource_count"] = expect_type(
            int, _scanned_child_resource_count
        )

    if (
        _unscanned_child_resource_count := output.get("unscannedChildResourceCount")
    ) is not None:
        kwargs["unscanned_child_resource_count"] = expect_type(
            int, _unscanned_child_resource_count
        )

    if (_total_resources := output.get("totalResources")) is not None:
        kwargs["total_resources"] = expect_type(int, _total_resources)

    if (_sample_scan_count := output.get("sampleScanCount")) is not None:
        kwargs["sample_scan_count"] = expect_type(int, _sample_scan_count)

    if (_full_scan_count := output.get("fullScanCount")) is not None:
        kwargs["full_scan_count"] = expect_type(int, _full_scan_count)

    if (_data_size := output.get("dataSize")) is not None:
        kwargs["data_size"] = _deserialize_data_size(_data_size, config)

    if (_resources_with_data_size := output.get("resourcesWithDataSize")) is not None:
        kwargs["resources_with_data_size"] = expect_type(int, _resources_with_data_size)

    if (_violation_count := output.get("violationCount")) is not None:
        kwargs["violation_count"] = expect_type(int, _violation_count)

    if (_applicable_policy_count := output.get("applicablePolicyCount")) is not None:
        kwargs["applicable_policy_count"] = expect_type(int, _applicable_policy_count)

    if (_failed_policy_count := output.get("failedPolicyCount")) is not None:
        kwargs["failed_policy_count"] = expect_type(int, _failed_policy_count)

    if (
        _deployed_connectors_count := output.get("deployedConnectorsCount")
    ) is not None:
        kwargs["deployed_connectors_count"] = expect_type(
            int, _deployed_connectors_count
        )

    return ResourceStatsData(**kwargs)


def _deserialize_resource_trends(
    output: DocumentValue, config: Config
) -> ResourceTrends:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_discovered := output.get("discovered")) is not None:
        kwargs["discovered"] = expect_type(int, _discovered)

    if (_removed := output.get("removed")) is not None:
        kwargs["removed"] = expect_type(int, _removed)

    if (_last_updated := output.get("lastUpdated")) is not None:
        kwargs["last_updated"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_updated)
        )

    if (_previous_discovered := output.get("previousDiscovered")) is not None:
        kwargs["previous_discovered"] = expect_type(int, _previous_discovered)

    if (_previous_removed := output.get("previousRemoved")) is not None:
        kwargs["previous_removed"] = expect_type(int, _previous_removed)

    if (_net_change := output.get("netChange")) is not None:
        kwargs["net_change"] = expect_type(int, _net_change)

    return ResourceTrends(**kwargs)


def _deserialize_resource_trends_list(
    output: DocumentValue, config: Config
) -> list[ResourceTrends]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_trends(e, config) for e in output]


def _deserialize_resource_type_scan_stats(
    output: DocumentValue, config: Config
) -> ResourceTypeScanStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_scan_durationin_ms := output.get("scanDurationinMs")) is not None:
        kwargs["scan_durationin_ms"] = limited_parse_float(_scan_durationin_ms)

    if (_data_scanned := output.get("dataScanned")) is not None:
        kwargs["data_scanned"] = limited_parse_float(_data_scanned)

    if (_identifiers_matched := output.get("identifiersMatched")) is not None:
        kwargs["identifiers_matched"] = expect_type(int, _identifiers_matched)

    if (_scanned_resources := output.get("scannedResources")) is not None:
        kwargs["scanned_resources"] = expect_type(int, _scanned_resources)

    if (_total_resource_count := output.get("totalResourceCount")) is not None:
        kwargs["total_resource_count"] = expect_type(int, _total_resource_count)

    if (_failed_scans := output.get("failedScans")) is not None:
        kwargs["failed_scans"] = expect_type(int, _failed_scans)

    if (_total_scans := output.get("totalScans")) is not None:
        kwargs["total_scans"] = expect_type(int, _total_scans)

    if (_successful_scans := output.get("successfulScans")) is not None:
        kwargs["successful_scans"] = expect_type(int, _successful_scans)

    return ResourceTypeScanStats(**kwargs)


def _deserialize_resource_with_name(
    output: DocumentValue, config: Config
) -> ResourceWithName:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_parent_name := output.get("parentName")) is not None:
        kwargs["parent_name"] = expect_type(str, _parent_name)

    if (_resource_status := output.get("resourceStatus")) is not None:
        kwargs["resource_status"] = expect_type(str, _resource_status)

    return ResourceWithName(**kwargs)


def _deserialize_response_type_scan_stats_summary(
    output: DocumentValue, config: Config
) -> dict[str, ResourceTypeScanStats]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_resource_type_scan_stats(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_retention_period(
    output: DocumentValue, config: Config
) -> RetentionPeriod:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_unit := output.get("unit")) is not None:
        kwargs["unit"] = expect_type(str, _unit)

    if (_value := output.get("value")) is not None:
        kwargs["value"] = expect_type(int, _value)

    return RetentionPeriod(**kwargs)


def _deserialize_sample_tokens(output: DocumentValue, config: Config) -> SampleTokens:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_token := output.get("token")) is not None:
        kwargs["token"] = expect_type(str, _token)

    if (_info_type := output.get("infoType")) is not None:
        kwargs["info_type"] = expect_type(str, _info_type)

    if (_column := output.get("column")) is not None:
        kwargs["column"] = expect_type(int, _column)

    if (_column_name := output.get("columnName")) is not None:
        kwargs["column_name"] = expect_type(str, _column_name)

    if (_row := output.get("row")) is not None:
        kwargs["row"] = expect_type(int, _row)

    if (_confidence := output.get("confidence")) is not None:
        kwargs["confidence"] = expect_type(int, _confidence)

    return SampleTokens(**kwargs)


def _deserialize_sample_tokens_list(
    output: DocumentValue, config: Config
) -> list[SampleTokens]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_sample_tokens(e, config) for e in output]


def _deserialize_scan_data_processed(
    output: DocumentValue, config: Config
) -> ScanDataProcessed:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_read_from_source_bytes := output.get("readFromSourceBytes")) is not None:
        kwargs["read_from_source_bytes"] = expect_type(int, _read_from_source_bytes)

    if (_inspected_bytes := output.get("inspectedBytes")) is not None:
        kwargs["inspected_bytes"] = expect_type(int, _inspected_bytes)

    if (_extracted_bytes := output.get("extractedBytes")) is not None:
        kwargs["extracted_bytes"] = expect_type(int, _extracted_bytes)

    return ScanDataProcessed(**kwargs)


def _deserialize_scan_detail(output: DocumentValue, config: Config) -> ScanDetail:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_scan_type := output.get("scanType")) is not None:
        kwargs["scan_type"] = expect_type(str, _scan_type)

    if (_schedule_type := output.get("scheduleType")) is not None:
        kwargs["schedule_type"] = expect_type(str, _schedule_type)

    if (_cron := output.get("cron")) is not None:
        kwargs["cron"] = expect_type(str, _cron)

    if (_schedule := output.get("schedule")) is not None:
        kwargs["schedule"] = _deserialize_scan_schedule(_schedule, config)

    if (_inspection_policy := output.get("inspectionPolicy")) is not None:
        kwargs["inspection_policy"] = _deserialize_inspection_policy(
            _inspection_policy, config
        )

    if (_confidence_snapshot := output.get("confidenceSnapshot")) is not None:
        kwargs["confidence_snapshot"] = _deserialize_inspection_confidence_snapshot(
            _confidence_snapshot, config
        )

    return ScanDetail(**kwargs)


def _deserialize_scan_execution_record(
    output: DocumentValue, config: Config
) -> ScanExecutionRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_scan_execution_id := output.get("scanExecutionId")) is not None:
        kwargs["scan_execution_id"] = expect_type(str, _scan_execution_id)

    if (_scan_id := output.get("scanId")) is not None:
        kwargs["scan_id"] = expect_type(str, _scan_id)

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_resource_id := output.get("resourceId")) is not None:
        kwargs["resource_id"] = expect_type(str, _resource_id)

    if (_resource := output.get("resource")) is not None:
        kwargs["resource"] = _deserialize_resource_record(_resource, config)

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_sample_tokens := output.get("sampleTokens")) is not None:
        kwargs["sample_tokens"] = _deserialize_tokens(_sample_tokens, config)

    if (_confidence_snapshot := output.get("confidenceSnapshot")) is not None:
        kwargs["confidence_snapshot"] = _deserialize_inspection_confidence_snapshot(
            _confidence_snapshot, config
        )

    if (_scan_iteration_id := output.get("scanIterationId")) is not None:
        kwargs["scan_iteration_id"] = expect_type(str, _scan_iteration_id)

    if (_scan_start_time := output.get("scanStartTime")) is not None:
        kwargs["scan_start_time"] = epoch_seconds_to_datetime(
            expect_type(int | float, _scan_start_time)
        )

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_scan_stats(_stats, config)

    if (_scan := output.get("scan")) is not None:
        kwargs["scan"] = _deserialize_scan_detail(_scan, config)

    return ScanExecutionRecord(**kwargs)


def _deserialize_scan_execution_records_list(
    output: DocumentValue, config: Config
) -> list[ScanExecutionRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_scan_execution_record(e, config) for e in output]


def _deserialize_scan_filter(output: DocumentValue, config: Config) -> ScanFilter:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_filters := output.get("filters")) is not None:
        kwargs["filters"] = _deserialize_unique_string_list(_filters, config)

    if (_resource_based_filters := output.get("resourceBasedFilters")) is not None:
        kwargs["resource_based_filters"] = _deserialize_resource_based_filters(
            _resource_based_filters, config
        )

    return ScanFilter(**kwargs)


def _deserialize_scan_filter_list(
    output: DocumentValue, config: Config
) -> list[ScanFilter]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_scan_filter(e, config) for e in output]


def _deserialize_scan_information(
    output: DocumentValue, config: Config
) -> ScanInformation:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_last_scan := output.get("lastScan")) is not None:
        kwargs["last_scan"] = epoch_seconds_to_datetime(
            expect_type(int | float, _last_scan)
        )

    return ScanInformation(**kwargs)


def _deserialize_scan_iteration_record(
    output: DocumentValue, config: Config
) -> ScanIterationRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "scanIterationId" not in output:
        raise ServiceError(
            'Expected to find "scanIterationId" in the operation output, but it was not present.'
        )
    kwargs["scan_iteration_id"] = expect_type(str, output["scanIterationId"])

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_resources_list(_resources, config)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_failed_resources := output.get("failedResources")) is not None:
        kwargs["failed_resources"] = _deserialize_resources_list(
            _failed_resources, config
        )

    if (_successful_resources := output.get("successfulResources")) is not None:
        kwargs["successful_resources"] = _deserialize_resources_list(
            _successful_resources, config
        )

    if (_deleted_resources := output.get("deletedResources")) is not None:
        kwargs["deleted_resources"] = _deserialize_resources_list(
            _deleted_resources, config
        )

    if (_scan_id := output.get("scanId")) is not None:
        kwargs["scan_id"] = expect_type(str, _scan_id)

    return ScanIterationRecord(**kwargs)


def _deserialize_scan_iterations_list(
    output: DocumentValue, config: Config
) -> list[ScanIterationRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_scan_iteration_record(e, config) for e in output]


def _deserialize_scan_iteration_stats(
    output: DocumentValue, config: Config
) -> ScanIterationStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_status_count := output.get("statusCount")) is not None:
        kwargs["status_count"] = _deserialize_scan_status_count(_status_count, config)

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = expect_type(int, _resources)

    return ScanIterationStats(**kwargs)


def _deserialize_scan_limits(output: DocumentValue, config: Config) -> ScanLimits:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_sample_percentage := output.get("samplePercentage")) is not None:
        kwargs["sample_percentage"] = limited_parse_float(_sample_percentage)

    if (
        _max_cumulative_data_size_mb := output.get("maxCumulativeDataSizeMb")
    ) is not None:
        kwargs["max_cumulative_data_size_mb"] = expect_type(
            int, _max_cumulative_data_size_mb
        )

    if (_items_per_batch := output.get("itemsPerBatch")) is not None:
        kwargs["items_per_batch"] = expect_type(int, _items_per_batch)

    if (_sample_duration_minutes := output.get("sampleDurationMinutes")) is not None:
        kwargs["sample_duration_minutes"] = expect_type(int, _sample_duration_minutes)

    return ScanLimits(**kwargs)


def _deserialize_scan_meta(output: DocumentValue, config: Config) -> ScanMeta:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    return ScanMeta(**kwargs)


def _deserialize_scan_parameters(
    output: DocumentValue, config: Config
) -> ScanParameters:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_scan_resources(_resources, config)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_scan_filter := output.get("scanFilter")) is not None:
        kwargs["scan_filter"] = _deserialize_scan_filter_list(_scan_filter, config)

    if (_inspection_policy := output.get("inspectionPolicy")) is not None:
        kwargs["inspection_policy"] = _deserialize_inspection_policy(
            _inspection_policy, config
        )

    return ScanParameters(**kwargs)


def _deserialize_scan_record(output: DocumentValue, config: Config) -> ScanRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "scanId" not in output:
        raise ServiceError(
            'Expected to find "scanId" in the operation output, but it was not present.'
        )
    kwargs["scan_id"] = expect_type(str, output["scanId"])

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_scan_type := output.get("scanType")) is not None:
        kwargs["scan_type"] = expect_type(str, _scan_type)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_resources := output.get("resources")) is not None:
        kwargs["resources"] = _deserialize_scan_resources(_resources, config)

    if (_connector_id := output.get("connectorId")) is not None:
        kwargs["connector_id"] = expect_type(str, _connector_id)

    if (_connector_type := output.get("connectorType")) is not None:
        kwargs["connector_type"] = expect_type(str, _connector_type)

    if (_data_plane_id := output.get("dataPlaneId")) is not None:
        kwargs["data_plane_id"] = expect_type(str, _data_plane_id)

    if (_data_plane_name := output.get("dataPlaneName")) is not None:
        kwargs["data_plane_name"] = expect_type(str, _data_plane_name)

    if (_data_plane_slug := output.get("dataPlaneSlug")) is not None:
        kwargs["data_plane_slug"] = expect_type(str, _data_plane_slug)

    if (_schedule_type := output.get("scheduleType")) is not None:
        kwargs["schedule_type"] = expect_type(str, _schedule_type)

    if (_cron := output.get("cron")) is not None:
        kwargs["cron"] = expect_type(str, _cron)

    if (_scan_filter := output.get("scanFilter")) is not None:
        kwargs["scan_filter"] = _deserialize_scan_filter_list(_scan_filter, config)

    if (_scan_limits := output.get("scanLimits")) is not None:
        kwargs["scan_limits"] = _deserialize_scan_limits(_scan_limits, config)

    if (_inspection_policy := output.get("inspectionPolicy")) is not None:
        kwargs["inspection_policy"] = _deserialize_inspection_policy(
            _inspection_policy, config
        )

    if (_snapshot := output.get("snapshot")) is not None:
        kwargs["snapshot"] = _deserialize_inspection_result_snapshot(_snapshot, config)

    if (_confidence_snapshot := output.get("confidenceSnapshot")) is not None:
        kwargs["confidence_snapshot"] = _deserialize_inspection_confidence_snapshot(
            _confidence_snapshot, config
        )

    if (_meta := output.get("meta")) is not None:
        kwargs["meta"] = _deserialize_scan_meta(_meta, config)

    if (_stats := output.get("stats")) is not None:
        kwargs["stats"] = _deserialize_scan_stats(_stats, config)

    if (_elapsed_time_ms := output.get("elapsedTimeMs")) is not None:
        kwargs["elapsed_time_ms"] = expect_type(int, _elapsed_time_ms)

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if (_schedule := output.get("schedule")) is not None:
        kwargs["schedule"] = _deserialize_scan_schedule(_schedule, config)

    if (_next_execution := output.get("nextExecution")) is not None:
        kwargs["next_execution"] = epoch_seconds_to_datetime(
            expect_type(int | float, _next_execution)
        )

    if (_created_by := output.get("createdBy")) is not None:
        kwargs["created_by"] = expect_type(str, _created_by)

    if (_latest_iteration_stats := output.get("latestIterationStats")) is not None:
        kwargs["latest_iteration_stats"] = _deserialize_scan_iteration_stats(
            _latest_iteration_stats, config
        )

    if (_false_positive_reports := output.get("falsePositiveReports")) is not None:
        kwargs["false_positive_reports"] = _deserialize_false_positive_report_list(
            _false_positive_reports, config
        )

    return ScanRecord(**kwargs)


def _deserialize_scan_resources(output: DocumentValue, config: Config) -> ScanResources:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_account_id := output.get("accountId")) is not None:
        kwargs["account_id"] = expect_type(str, _account_id)

    if (_project_id := output.get("projectId")) is not None:
        kwargs["project_id"] = expect_type(str, _project_id)

    if (_region := output.get("region")) is not None:
        kwargs["region"] = expect_type(str, _region)

    if (_regions := output.get("regions")) is not None:
        kwargs["regions"] = _deserialize_unique_string_list(_regions, config)

    if (_search := output.get("search")) is not None:
        kwargs["search"] = expect_type(str, _search)

    if (_resource_type := output.get("resourceType")) is not None:
        kwargs["resource_type"] = expect_type(str, _resource_type)

    if (_resource_ids := output.get("resourceIds")) is not None:
        kwargs["resource_ids"] = _deserialize_unique_string_list(_resource_ids, config)

    if (_parent_id := output.get("parentId")) is not None:
        kwargs["parent_id"] = expect_type(str, _parent_id)

    if (_account_ids := output.get("accountIds")) is not None:
        kwargs["account_ids"] = _deserialize_unique_string_list(_account_ids, config)

    if (_parent_ids := output.get("parentIds")) is not None:
        kwargs["parent_ids"] = _deserialize_unique_string_list(_parent_ids, config)

    if (_is_public := output.get("isPublic")) is not None:
        kwargs["is_public"] = expect_type(bool, _is_public)

    if (_is_unencrypted := output.get("isUnencrypted")) is not None:
        kwargs["is_unencrypted"] = expect_type(bool, _is_unencrypted)

    if (_tags := output.get("tags")) is not None:
        kwargs["tags"] = _deserialize_tag_filter_list(_tags, config)

    if (_database := output.get("database")) is not None:
        kwargs["database"] = _deserialize_unique_string_list(_database, config)

    if (_dataset := output.get("dataset")) is not None:
        kwargs["dataset"] = _deserialize_unique_string_list(_dataset, config)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = _deserialize_unique_string_list(_name, config)

    if (_schema := output.get("schema")) is not None:
        kwargs["schema"] = _deserialize_unique_string_list(_schema, config)

    if (_drive_id := output.get("driveId")) is not None:
        kwargs["drive_id"] = _deserialize_unique_string_list(_drive_id, config)

    if (_zendesk_group_id := output.get("zendeskGroupId")) is not None:
        kwargs["zendesk_group_id"] = _deserialize_unique_long_list(
            _zendesk_group_id, config
        )

    if (_google_groups := output.get("googleGroups")) is not None:
        kwargs["google_groups"] = _deserialize_unique_string_list(
            _google_groups, config
        )

    if (_org_unit_id := output.get("orgUnitId")) is not None:
        kwargs["org_unit_id"] = _deserialize_unique_string_list(_org_unit_id, config)

    if (_drive_type := output.get("driveType")) is not None:
        kwargs["drive_type"] = _deserialize_unique_string_list(_drive_type, config)

    if (_info_types := output.get("infoTypes")) is not None:
        kwargs["info_types"] = _deserialize_info_types_combination_filter(
            _info_types, config
        )

    if (_is_archived := output.get("isArchived")) is not None:
        kwargs["is_archived"] = expect_type(bool, _is_archived)

    if (_is_external := output.get("isExternal")) is not None:
        kwargs["is_external"] = expect_type(bool, _is_external)

    if (_team_id := output.get("teamId")) is not None:
        kwargs["team_id"] = expect_type(str, _team_id)

    if (_team_name := output.get("teamName")) is not None:
        kwargs["team_name"] = expect_type(str, _team_name)

    if (_team_url := output.get("teamUrl")) is not None:
        kwargs["team_url"] = expect_type(str, _team_url)

    if (_is_private := output.get("isPrivate")) is not None:
        kwargs["is_private"] = expect_type(bool, _is_private)

    if (_is_slack_direct_messages := output.get("isSlackDirectMessages")) is not None:
        kwargs["is_slack_direct_messages"] = expect_type(
            bool, _is_slack_direct_messages
        )

    if (_space_status := output.get("spaceStatus")) is not None:
        kwargs["space_status"] = _deserialize_unique_string_list(_space_status, config)

    if (_space_type := output.get("spaceType")) is not None:
        kwargs["space_type"] = _deserialize_unique_string_list(_space_type, config)

    if (_excluded_resources := output.get("excludedResources")) is not None:
        kwargs["excluded_resources"] = _deserialize_resource_id_list(
            _excluded_resources, config
        )

    if (_namespace := output.get("namespace")) is not None:
        kwargs["namespace"] = _deserialize_unique_string_list(_namespace, config)

    if (_set := output.get("set")) is not None:
        kwargs["set"] = _deserialize_unique_string_list(_set, config)

    if (_all := output.get("all")) is not None:
        kwargs["all"] = expect_type(bool, _all)

    return ScanResources(**kwargs)


def _deserialize_scan_resource_status_list(
    output: DocumentValue, config: Config
) -> list[ResourceWithName]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_resource_with_name(e, config) for e in output]


def _deserialize_scan_schedule(output: DocumentValue, config: Config) -> ScanSchedule:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_calendars := output.get("calendars")) is not None:
        kwargs["calendars"] = _deserialize_calendar_spec_list(_calendars, config)

    if (_timezone := output.get("timezone")) is not None:
        kwargs["timezone"] = expect_type(str, _timezone)

    return ScanSchedule(**kwargs)


def _deserialize_scans_list(output: DocumentValue, config: Config) -> list[ScanRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_scan_record(e, config) for e in output]


def _deserialize_scan_stats(output: DocumentValue, config: Config) -> ScanStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_state_change_events := output.get("stateChangeEvents")) is not None:
        kwargs["state_change_events"] = _deserialize_state_change_events_list(
            _state_change_events, config
        )

    if (_data_processed := output.get("dataProcessed")) is not None:
        kwargs["data_processed"] = _deserialize_scan_data_processed(
            _data_processed, config
        )

    if (_scan_duration := output.get("scanDuration")) is not None:
        kwargs["scan_duration"] = limited_parse_float(_scan_duration)

    return ScanStats(**kwargs)


def _deserialize_scan_status_count(
    output: DocumentValue, config: Config
) -> ScanStatusCount:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_paused := output.get("paused")) is not None:
        kwargs["paused"] = expect_type(int, _paused)

    if (_terminated := output.get("terminated")) is not None:
        kwargs["terminated"] = expect_type(int, _terminated)

    if (_scanning := output.get("scanning")) is not None:
        kwargs["scanning"] = expect_type(int, _scanning)

    if (_success := output.get("success")) is not None:
        kwargs["success"] = expect_type(int, _success)

    if (_failed := output.get("failed")) is not None:
        kwargs["failed"] = expect_type(int, _failed)

    if (_deleted := output.get("deleted")) is not None:
        kwargs["deleted"] = expect_type(int, _deleted)

    return ScanStatusCount(**kwargs)


def _deserialize_security_risk(output: DocumentValue, config: Config) -> SecurityRisk:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_failed_rules := output.get("failedRules")) is not None:
        kwargs["failed_rules"] = _deserialize_unique_string_list(_failed_rules, config)

    return SecurityRisk(**kwargs)


def _deserialize_severity_count(output: DocumentValue, config: Config) -> SeverityCount:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_severity := output.get("severity")) is not None:
        kwargs["severity"] = expect_type(str, _severity)

    if (_count := output.get("count")) is not None:
        kwargs["count"] = expect_type(int, _count)

    return SeverityCount(**kwargs)


def _deserialize_severity_count_list(
    output: DocumentValue, config: Config
) -> list[SeverityCount]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_severity_count(e, config) for e in output]


def _deserialize_sort_records(output: DocumentValue, config: Config) -> SortRecords:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_column := output.get("column")) is not None:
        kwargs["column"] = expect_type(str, _column)

    if (_order := output.get("order")) is not None:
        kwargs["order"] = expect_type(str, _order)

    return SortRecords(**kwargs)


def _deserialize_state_change_events(
    output: DocumentValue, config: Config
) -> StateChangeEvents:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_previous_status := output.get("previousStatus")) is not None:
        kwargs["previous_status"] = expect_type(str, _previous_status)

    if (_epoch := output.get("epoch")) is not None:
        kwargs["epoch"] = expect_type(int, _epoch)

    return StateChangeEvents(**kwargs)


def _deserialize_state_change_events_list(
    output: DocumentValue, config: Config
) -> list[StateChangeEvents]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_state_change_events(e, config) for e in output]


def _deserialize_suggestion(output: DocumentValue, config: Config) -> Suggestion:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_object_id := output.get("objectId")) is not None:
        kwargs["object_id"] = expect_type(str, _object_id)

    if (_object_type := output.get("objectType")) is not None:
        kwargs["object_type"] = expect_type(str, _object_type)

    if (_object_name := output.get("objectName")) is not None:
        kwargs["object_name"] = expect_type(str, _object_name)

    if (_source := output.get("source")) is not None:
        kwargs["source"] = expect_type(str, _source)

    return Suggestion(**kwargs)


def _deserialize_suggestions(output: DocumentValue, config: Config) -> list[Suggestion]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_suggestion(e, config) for e in output]


def _deserialize_summarize_processing_activity_stats_output(
    output: DocumentValue, config: Config
) -> SummarizeProcessingActivityStatsOutput:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_pa_in_draft := output.get("paInDraft")) is not None:
        kwargs["pa_in_draft"] = expect_type(int, _pa_in_draft)

    if (_pending_ta := output.get("pendingTA")) is not None:
        kwargs["pending_ta"] = expect_type(int, _pending_ta)

    if (_ta_in_draft := output.get("taInDraft")) is not None:
        kwargs["ta_in_draft"] = expect_type(int, _ta_in_draft)

    if (_dpia_optional := output.get("dpiaOptional")) is not None:
        kwargs["dpia_optional"] = expect_type(int, _dpia_optional)

    if (_dpia_recommended := output.get("dpiaRecommended")) is not None:
        kwargs["dpia_recommended"] = expect_type(int, _dpia_recommended)

    if (_dpia_required := output.get("dpiaRequired")) is not None:
        kwargs["dpia_required"] = expect_type(int, _dpia_required)

    if (_dpia_in_draft := output.get("dpiaInDraft")) is not None:
        kwargs["dpia_in_draft"] = expect_type(int, _dpia_in_draft)

    if (_dpia_completed := output.get("dpiaCompleted")) is not None:
        kwargs["dpia_completed"] = expect_type(int, _dpia_completed)

    if (_total_pa := output.get("totalPA")) is not None:
        kwargs["total_pa"] = expect_type(int, _total_pa)

    if (_complete_ta := output.get("completeTA")) is not None:
        kwargs["complete_ta"] = expect_type(int, _complete_ta)

    if (_readiness_score := output.get("readinessScore")) is not None:
        kwargs["readiness_score"] = expect_type(int, _readiness_score)

    if (_required_dpias_in_draft := output.get("requiredDpiasInDraft")) is not None:
        kwargs["required_dpias_in_draft"] = expect_type(int, _required_dpias_in_draft)

    if (_all_required_dpia := output.get("allRequiredDpia")) is not None:
        kwargs["all_required_dpia"] = expect_type(int, _all_required_dpia)

    if (_framework := output.get("framework")) is not None:
        kwargs["framework"] = expect_type(str, _framework)

    if (_organisation_id := output.get("organisationId")) is not None:
        kwargs["organisation_id"] = expect_type(int, _organisation_id)

    if (
        _resolution_period_for_p_as := output.get("resolutionPeriodForPAs")
    ) is not None:
        kwargs["resolution_period_for_p_as"] = expect_type(
            int, _resolution_period_for_p_as
        )

    if (_changes := output.get("changes")) is not None:
        kwargs["changes"] = _deserialize_change_in_processing_activity_stats_output(
            _changes, config
        )

    return SummarizeProcessingActivityStatsOutput(**kwargs)


def _deserialize_summary_scan_stats(
    output: DocumentValue, config: Config
) -> SummaryScanStats:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_resource_types := output.get("resourceTypes")) is not None:
        kwargs["resource_types"] = _deserialize_response_type_scan_stats_summary(
            _resource_types, config
        )

    if (_aggregate := output.get("aggregate")) is not None:
        kwargs["aggregate"] = _deserialize_aggregate_scan_stats(_aggregate, config)

    return SummaryScanStats(**kwargs)


def _deserialize_tag_filter(output: DocumentValue, config: Config) -> TagFilter:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "action" not in output:
        raise ServiceError(
            'Expected to find "action" in the operation output, but it was not present.'
        )
    kwargs["action"] = expect_type(str, output["action"])

    if "tagKey" not in output:
        raise ServiceError(
            'Expected to find "tagKey" in the operation output, but it was not present.'
        )
    kwargs["tag_key"] = expect_type(str, output["tagKey"])

    if (_tag_value := output.get("tagValue")) is not None:
        kwargs["tag_value"] = expect_type(str, _tag_value)

    return TagFilter(**kwargs)


def _deserialize_tag_filter_list(
    output: DocumentValue, config: Config
) -> list[TagFilter]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_tag_filter(e, config) for e in output]


def _deserialize_tagging_result(output: DocumentValue, config: Config) -> TaggingResult:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_entity_id := output.get("entityId")) is not None:
        kwargs["entity_id"] = expect_type(str, _entity_id)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    return TaggingResult(**kwargs)


def _deserialize_tagging_results_list(
    output: DocumentValue, config: Config
) -> list[TaggingResult]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_tagging_result(e, config) for e in output]


def _deserialize_tokens(
    output: DocumentValue, config: Config
) -> dict[str, list[SampleTokens]]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {
        k: _deserialize_sample_tokens_list(v, config)
        for k, v in output.items()
        if v is not None
    }


def _deserialize_tom_collection(
    output: DocumentValue, config: Config
) -> list[TomListMember]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_tom_list_member(e, config) for e in output]


def _deserialize_tom_list_member(
    output: DocumentValue, config: Config
) -> TomListMember:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_tom_id := output.get("tomId")) is not None:
        kwargs["tom_id"] = expect_type(str, _tom_id)

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_description := output.get("description")) is not None:
        kwargs["description"] = expect_type(str, _description)

    if (_list_ := output.get("list")) is not None:
        kwargs["list_"] = expect_type(str, _list_)

    if (_category := output.get("category")) is not None:
        kwargs["category"] = expect_type(str, _category)

    if (_type := output.get("type")) is not None:
        kwargs["type"] = expect_type(str, _type)

    if (_reference_code := output.get("referenceCode")) is not None:
        kwargs["reference_code"] = expect_type(str, _reference_code)

    if (_status := output.get("status")) is not None:
        kwargs["status"] = expect_type(str, _status)

    if (_note := output.get("note")) is not None:
        kwargs["note"] = expect_type(str, _note)

    return TomListMember(**kwargs)


def _deserialize_translations(output: DocumentValue, config: Config) -> dict[str, str]:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found { type(output) }")

    return {k: expect_type(str, v) for k, v in output.items() if v is not None}


def _deserialize_unique_long_list(output: DocumentValue, config: Config) -> list[int]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(int, e) for e in output]


def _deserialize_unique_string_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_url_list(
    output: DocumentValue, config: Config
) -> list[ExportedDataUrl]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_exported_data_url(e, config) for e in output]


def _deserialize_user_organisation(
    output: DocumentValue, config: Config
) -> UserOrganisation:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_organisation_id := output.get("organisationId")) is not None:
        kwargs["organisation_id"] = expect_type(int, _organisation_id)

    if "roles" not in output:
        raise ServiceError(
            'Expected to find "roles" in the operation output, but it was not present.'
        )
    kwargs["roles"] = _deserialize_dashboard_user_roles(output["roles"], config)

    if (_departments := output.get("departments")) is not None:
        kwargs["departments"] = _deserialize_uuid_collection(_departments, config)

    return UserOrganisation(**kwargs)


def _deserialize_user_organisations(
    output: DocumentValue, config: Config
) -> list[UserOrganisation]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_user_organisation(e, config) for e in output]


def _deserialize_user_profile_list(
    output: DocumentValue, config: Config
) -> list[UserProfileRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_user_profile_record(e, config) for e in output]


def _deserialize_user_profile_record(
    output: DocumentValue, config: Config
) -> UserProfileRecord:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if (_name := output.get("name")) is not None:
        kwargs["name"] = expect_type(str, _name)

    if (_connector_id := output.get("connectorId")) is not None:
        kwargs["connector_id"] = expect_type(str, _connector_id)

    if (_email := output.get("email")) is not None:
        kwargs["email"] = expect_type(str, _email)

    if (_connector_user_id := output.get("connectorUserId")) is not None:
        kwargs["connector_user_id"] = expect_type(str, _connector_user_id)

    if (_connector_source_type := output.get("connectorSourceType")) is not None:
        kwargs["connector_source_type"] = expect_type(str, _connector_source_type)

    if (_connector_username := output.get("connectorUsername")) is not None:
        kwargs["connector_username"] = expect_type(str, _connector_username)

    if (_external := output.get("external")) is not None:
        kwargs["external"] = expect_type(bool, _external)

    if (_deleted_at := output.get("deletedAt")) is not None:
        kwargs["deleted_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _deleted_at)
        )

    if (_created_at := output.get("createdAt")) is not None:
        kwargs["created_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _created_at)
        )

    if (_updated_at := output.get("updatedAt")) is not None:
        kwargs["updated_at"] = epoch_seconds_to_datetime(
            expect_type(int | float, _updated_at)
        )

    if "userId" not in output:
        raise ServiceError(
            'Expected to find "userId" in the operation output, but it was not present.'
        )
    kwargs["user_id"] = expect_type(str, output["userId"])

    return UserProfileRecord(**kwargs)


def _deserialize_users_list(
    output: DocumentValue, config: Config
) -> list[DashboardUserRecord]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_dashboard_user_record(e, config) for e in output]


def _deserialize_uuid_collection(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_warranty_list(output: DocumentValue, config: Config) -> list[str]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [expect_type(str, e) for e in output]


def _deserialize_validation_exception_field(
    output: DocumentValue, config: Config
) -> ValidationExceptionField:
    if not isinstance(output, dict):
        raise ServiceError(f"Expected dict, found {type(output)}")

    kwargs: dict[str, Any] = {}

    if "path" not in output:
        raise ServiceError(
            'Expected to find "path" in the operation output, but it was not present.'
        )
    kwargs["path"] = expect_type(str, output["path"])

    if "message" not in output:
        raise ServiceError(
            'Expected to find "message" in the operation output, but it was not present.'
        )
    kwargs["message"] = expect_type(str, output["message"])

    return ValidationExceptionField(**kwargs)


def _deserialize_validation_exception_field_list(
    output: DocumentValue, config: Config
) -> list[ValidationExceptionField]:
    if not isinstance(output, list):
        raise ServiceError(f"Expected list, found {type(output)}")
    return [_deserialize_validation_exception_field(e, config) for e in output]
