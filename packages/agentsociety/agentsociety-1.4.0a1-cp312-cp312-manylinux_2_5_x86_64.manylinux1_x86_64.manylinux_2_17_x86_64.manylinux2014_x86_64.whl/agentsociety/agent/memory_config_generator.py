import copy
from typing import Any, Callable, Optional, Union, cast

import jsonc

from ..s3 import S3Client, S3Config
from .distribution import Distribution, DistributionConfig

__all__ = [
    "MemoryConfigGenerator",
    "MemoryT",
]

MemoryT = Union[tuple[type, Any], tuple[type, Any, bool]]
"""
MemoryT is a tuple of (type, value, use embedding model)
- type: the type of the value
- value: the value
- use embedding model (optional): whether the value is generated by embedding model
"""


class MemoryConfigGenerator:
    """
    Generate memory configuration.
    """

    def __init__(
        self,
        config_func: Callable[
            [dict[str, Distribution]],
            tuple[dict[str, MemoryT], dict[str, Union[MemoryT, float]], dict[str, Any]],
        ],
        file: Optional[str] = None,
        distributions: dict[str, Union[Distribution, DistributionConfig]] = {},
        s3config: S3Config = S3Config.model_validate({}),
    ):
        """
        Initialize the memory config generator.

        - **Args**:
            - `config_func` (Callable): The function to generate the memory configuration.
            - `file` (Optional[str]): The path to the file containing the memory configuration.
            - `distributions` (dict[str, Distribution]): The distributions to use for the memory configuration. Default is empty dict.
            - `s3config` (S3Config): The S3 configuration.
        """
        self._memory_config_func = config_func
        if file is not None:
            self._memory_data = _memory_config_load_file(file, s3config)
        else:
            self._memory_data = None
        distributions = copy.deepcopy(distributions)
        # change DistributionConfig to Distribution
        for field, distribution in distributions.items():
            if isinstance(distribution, DistributionConfig):
                distributions[field] = Distribution.from_config(distribution)
        self._distributions = cast(dict[str, Distribution], distributions)

    def generate(self, i: int):
        """
        Generate memory configuration.

        Args:
            i (int): The index of the memory configuration to generate. Used to find the i-th memory configuration in the file.

        Returns:
            tuple[dict[str, MemoryT], dict[str, MemoryT], dict[str, Any]]: The memory configuration.
        """
        extra_attrs, profile, base = self._memory_config_func(self._distributions)
        if self._memory_data is not None:
            if i >= len(self._memory_data):
                raise ValueError(
                    f"Index out of range. Expected index <= {len(self._memory_data)}, got: {i}"
                )
            memory_data = self._memory_data[i]
        else:
            memory_data = {}
        return _memory_config_merge(memory_data, extra_attrs, profile, base)


# TODO: TEST THIS in V1.3
def _memory_config_load_file(file_path: str, s3config: S3Config):
    """
    Loads the memory configuration from the given file.
    - **Description**:
        - Loads the memory configuration from the given file.
        - Supports both .json and .jsonl file types.
        - For .json files, returns the parsed JSON content.
        - For .jsonl files, returns a list of parsed JSON objects from each line.

    - **Args**:
        - `file_path` (str): The path to the file containing the memory configuration.

    - **Returns**:
        - `memory_data` (Union[dict, list]): The memory data - either a single object or list of objects.

    - **Raises**:
        - `ValueError`: If the file type is not supported.
    """
    # Check file extension
    if s3config.enabled:
        s3client = S3Client(s3config)
        data_bytes = s3client.download(file_path)
        data_str = data_bytes.decode("utf-8")
    else:
        with open(file_path, "r") as f:
            data_str = f.read()

    if file_path.endswith(".json"):
        memory_data = jsonc.loads(data_str)
        if not isinstance(memory_data, list):
            raise ValueError(
                f"Invalid memory data. Expected a list, got: {memory_data}"
            )
        return memory_data
    elif file_path.endswith(".jsonl"):
        memory_data = []
        for line in data_str.splitlines():
            if line.strip():  # Skip empty lines
                memory_data.append(jsonc.loads(line))
        return memory_data
    else:
        raise ValueError(
            f"Unsupported file type. Only .json or .jsonl files are supported. Got: {file_path}"
        )


def _memory_config_merge(
    file_data: dict,
    base_extra_attrs: dict[str, MemoryT],
    base_profile: dict[str, Union[MemoryT, float]],
    base_base: dict[str, Any],
) -> dict[str, Any]:
    """
    Merges memory configuration from file with base configuration.

    - **Description**:
        - Takes file data and merges it with base configuration components.
        - Special handling for 'home' and 'work' fields which may need to be placed in correct section.

    - **Args**:
        - `file_data` (dict): Memory configuration data loaded from file.
        - `base_extra_attrs` (dict): Base extra attributes configuration.
        - `base_profile` (dict): Base profile configuration.
        - `base_base` (dict): Base memory configuration.

    - **Returns**:
        - `dict`: Merged memory configuration with proper structure.
    """
    # Create copies to avoid modifying the originals
    extra_attrs = base_extra_attrs.copy()
    profile = base_profile.copy()
    base = base_base.copy()

    # Special handling for home and work locations
    location_fields = ["home", "work"]

    for key, value in file_data.items():
        # Check where this key exists in the base configuration
        if key in extra_attrs:
            extra_attrs[key] = value
        elif key in profile:
            profile[key] = value
        elif key in location_fields:
            # Typically these would go in profile, but follow your specific needs
            base[key] = {"aoi_position": {"aoi_id": value}}
        else:
            # For any new fields not in base config, add to extra_attrs
            extra_attrs[key] = value

    return {"extra_attributes": extra_attrs, "profile": profile, "base": base}
