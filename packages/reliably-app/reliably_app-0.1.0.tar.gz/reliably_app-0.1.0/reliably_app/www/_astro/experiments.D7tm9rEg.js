import{h as c}from"./user.DMXaCJik.js";import{g}from"./experiments.rwiqw3d6.js";import{o as $,m as v}from"./user.TOXT8CXA.js";import{i as p,d as m}from"./loader.BQDlK3Tc.js";import{a as l}from"./notifications.NSMm1_5U.js";import{u as T}from"./index.CwJxcYEt.js";import{a as E}from"./index.BSdFiPHn.js";const b={ASSETS_PREFIX:void 0,BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SITE:void 0,SSR:!1},r=b===void 0?"https://62ff903e9350a1e548e1952e.mockapi.io/api":void 0,u=r==="https://62ff903e9350a1e548e1952e.mockapi.io/api",x=u?"&limit=10":"",h=u?"experiments_summary":"experiments/summary",S=u?"experiments_all":"experiments/all",j=u?"series-score-experiment":"series/scores/experiment",a=T($),w=v({page:0,experiments:[],total:0,isReady:!1});async function A(s){return w.set(s),w.get()}const L=async(s,i)=>{p();let n=`${r}/organization/${a.value}/${h}?page=${s}${x}`;i&&(n=`${r}/organization/${a.value}/${h}?pattern=${i}&page=${s}${x}`);try{const e=await fetch(n);if(e.status===403)c(a.value);else if(e.ok){const t=await e.json();let o={page:s,experiments:t.items,total:t.count,isReady:!0};A(o)}else throw new Error(e.statusText)}catch(e){const t={title:"Experiments couldn't be fetched",message:e.message,type:"error"};l(t)}finally{m()}},d=E(null);async function _(s){return d.set(s),d.get()}const N=async s=>{p();const i=`${r}/organization/${a.value}/experiments/${s}`;try{const n=await fetch(i);if(n.status===403)c(a.value);else if(n.ok){const e=await n.json(),t=`${r}/organization/${a.value}/${j}/${s}`;try{const o=await fetch(t);if(o.ok){const f=await o.json();e.score=f}else throw new Error(o.statusText)}catch(o){const f={title:"Experiment score couldn't be fetched",message:o.message,type:"error"};l(f)}_(e)}else throw new Error(n.statusText)}catch(n){const e={title:"Experiment couldn't be fetched",message:n.message,type:"error"};l(e)}finally{m()}},I=async s=>{p();let i=!0;const n=`${r}/organization/${a.value}/experiments/${s}`;try{const e=await fetch(n,{method:"DELETE"});if(e.status===403)c(a.value);else if(e.status===400){let t=await e.json();l({title:"Experiment couldn't be deleted",message:"This experiment is used by a plan. You must delete the plan before proceeding.",type:"warning"}),i=!1}else if(!e.ok)throw new Error(e.statusText)}catch(e){const t={title:"Experiment couldn't be deleted",message:e.message,type:"error"};l(t),i=!1}finally{return m(),i}},J=async(s,i,n)=>{p();const e=`${r}/organization/${a.value}/experiments/import`;try{const t=await fetch(e,{method:"POST",headers:{Accept:"application/json, text/plain, */*","Content-Type":"application/json"},body:JSON.stringify(s)});if(t.status===403)c(a.value);else{if(t.status===429)throw new Error("You've reached the limit of custom experiments allowed by your plan.");if(t.ok){const o=await t.json();if(i===!0)window.location.assign(`/plans/new/?exp=${o.id}`);else{if(n===!0)return o.id;window.location.assign(`/experiments/view/?id=${o.id}`)}}else throw new Error(t.statusText)}}catch(t){const o={title:"Experiment couldn't be imported",message:t.message,type:"error"};l(o)}finally{m()}},M=async(s,i,n)=>{p();const e=`${r}/organization/${a.value}/experiments/${s}`;try{const t=await fetch(e,{method:"PUT",headers:{Accept:"application/json, text/plain, */*","Content-Type":"application/json"},body:JSON.stringify(i)});if(t.status===403)c(a.value);else{if(t.status===404)throw new Error("This experiment doesn't exist anymore");if(t.ok){const o=await t.json();n||window.location.assign(`/experiments/view/?id=${o.id}`)}else throw new Error(t.statusText)}}catch(t){const o={title:"Experiment couldn't be edited",message:t.message,type:"error"};l(o)}finally{m()}},y=E([]);async function k(s){return y.set(s.items),y.get()}const Y=async()=>{p();const s=`${r}/organization/${a.value}/${S}`;try{const i=await fetch(s);if(i.status===403)c(a.value);else if(i.ok){const n=await i.json();k(n)}else throw new Error(i.statusText)}catch(i){const n={title:"Experiments couldn't be fetched",message:i.message,type:"error"};l(n)}finally{m()}};function B(s,i){const n=d.get();if(n){let e="";if(s==="warmup")e=n.definition.method[i].name;else if(s==="turbulence"||s==="method"){let t=0;const o=g(n.definition);o&&(t=o.workflow.warmup.length),e=n.definition.method[i+t].name}else s==="verification"||s==="hypothesis"?e=n.definition["steady-state-hypothesis"].probes[i].name:s==="rollbacks"&&(e=n.definition.rollbacks[i].name);if(e!=="")return e}return null}export{w as a,N as b,Y as c,I as d,d as e,L as f,y as g,B as h,J as i,M as o};
